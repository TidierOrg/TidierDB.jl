{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-tidierdbjl","title":"What is TidierDB.jl","text":"<p>TiderDB.jl is a 100% Julia implementation of the dbplyr R package (and similar to python's ibis package).</p> <p>The main goal of TidierDB.jl is to bring the ease of use and simple syntax of Tidier.jl to mutliple SQL backends, making data analysis smoother by abstracting away subtle syntax differences between backends.</p> <p></p> <p></p>"},{"location":"#currently-supported-backends-include","title":"Currently supported backends include:","text":"<ul> <li>DuckDB (the default) <code>set_sql_mode(:duckdb)</code></li> <li>ClickHouse <code>set_sql_mode(:clickhouse)</code></li> <li>SQLite <code>set_sql_mode(:lite)</code></li> <li>MySQL <code>set_sql_mode(:mysql)</code></li> <li>MSSQL <code>set_sql_mode(:mssql)</code></li> <li>Postgres <code>set_sql_mode(:postgres)</code></li> </ul> <p>Change the backend by using <code>set_sql_mode()</code></p> <p></p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>For the stable version:</p> <pre><code>] add TidierDB\n</code></pre> <p>TidierDB.jl currently supports the following top-level macros:</p> <ul> <li><code>@arrange</code></li> <li><code>@group_by</code></li> <li><code>@filter</code></li> <li><code>@select</code></li> <li><code>@mutate</code> supports <code>across</code></li> <li><code>@summarize</code> / <code>@summarise</code> supports <code>across</code></li> <li><code>@distinct</code></li> <li><code>@left_join</code>, <code>@right_join</code>, <code>@inner_join</code> (slight syntax differences from TidierData.jl)</li> <li><code>@count</code></li> <li><code>@slice_min</code>, <code>@slice_max</code>, <code>@slice_sample</code></li> <li><code>@window_order</code> and <code>window_frame</code></li> <li><code>@show_query</code></li> <li><code>@collect</code></li> </ul> <p>Supported helper functions for most backends include</p> <ul> <li><code>across()</code></li> <li><code>desc()</code></li> <li><code>if_else()</code> and <code>case_when()</code></li> <li><code>n()</code></li> <li><code>starts_with()</code>, <code>ends_with()</code>, and <code>contains()</code></li> <li><code>as_float()</code>, <code>as_integer()</code>, and <code>as_string()</code></li> <li><code>is_missing()</code></li> <li><code>missing_if()</code> and <code>replace_missing()</code></li> </ul> <p>From TidierStrings.jl</p> <ul> <li><code>str_detect</code>, <code>str_replace</code>, <code>str_replace_all</code>, <code>str_remove_all</code>, <code>str_remove</code></li> </ul> <p>From TidierDates.jl</p> <ul> <li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>min</code>, <code>second</code>, <code>floor_date</code>, <code>difftime</code></li> </ul> <p>Supported aggregate functions (as supported by the backend) with more to come</p> <ul> <li><code>mean</code>, <code>minimium</code>, <code>maximum</code>, <code>std</code>, <code>sum</code>, <code>cumsum</code>, <code>cor</code>, <code>cov</code>, <code>var</code></li> <li><code>copy_to</code> (for DuckDB, MySQL, SQLite)</li> </ul> <p>DuckDB specifically enables copy_to to directly reading in .parquet, .json, .csv, https file paths.</p> <pre><code>path = \"file_path.parquet\"\ncopy_to(conn, file_path, \"table_name\")\n</code></pre> <p>Bang bang <code>!!</code> Interpolation for columns and values is supported.</p> <p>There are a few subtle but important differences from Tidier.jl outlined here.</p> <p>Missing a function or backend?</p> <p>You can actually use any (non-agg) sql fucntion in mutate with the correct sql syntax and it will will still run. But open an issue, and we would be happy to address it.</p> <p>Finally, some examples</p> <pre><code>using TidierDB\nmem = duckdb_open(\":memory:\");\ndb = duckdb_connect(mem);\npath = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\ncopy_to(db, path, \"mtcars2\");\n@chain db_table(db, :mtcars2) begin\n    @filter(model != starts_with(\"M\"))\n    @group_by(cyl)\n    @summarize(mpg = mean(mpg))\n    @mutate(sqaured = mpg^2, \n               rounded = round(mpg), \n               efficiency = case_when(\n                             mpg &gt;= cyl^2 , 12,\n                             mpg &lt; 15.2 , 14,\n                              44))            \n    @filter(efficiency&gt;12)                       \n    @arrange(rounded)\n    @show_query\n    #@collect\nend\n</code></pre> <pre><code>WITH cte_1 AS (\nSELECT *\n        FROM mtcars2\n        WHERE NOT (model LIKE 'M%')),\ncte_2 AS (\nSELECT cyl, AVG(mpg) AS mpg\n        FROM cte_1\n        GROUP BY cyl),\ncte_3 AS (\nSELECT  cyl, mpg, POWER(mpg, 2) AS sqaured, ROUND(mpg) AS rounded, CASE WHEN mpg &gt;= POWER(cyl, 2) THEN 12 WHEN mpg &lt; 15.2 THEN 14 ELSE 44 END AS efficiency\n        FROM cte_2 ),\ncte_4 AS (\nSELECT *\n        FROM cte_3\n        WHERE efficiency &gt; 12)  \nSELECT *\n        FROM cte_4  \n        ORDER BY rounded ASC\n</code></pre> <p>Now instead of ending the chain with <code>@show_query</code>, we use <code>@collect</code> to pull the df into the local environment</p> <pre><code>2\u00d75 DataFrame\n Row \u2502 cyl    mpg      sqaured  rounded  efficiency \n     \u2502 Int64  Float64  Float64  Float64  Int64      \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     8  14.75    217.562     15.0          14\n   2 \u2502     6  19.7333  389.404     20.0          44\n</code></pre> <p><code>across</code> in <code>summarize</code></p> <pre><code>@chain db_table(db, :mtcars2) begin\n    @group_by(cyl)\n    @summarize(across((starts_with(\"a\"), ends_with(\"s\")), (mean, sum)))\n    #@show_query\n    @collect\nend\n</code></pre> <pre><code>3\u00d75 DataFrame\n Row \u2502 cyl    mean_am   mean_vs   sum_am  sum_vs \n     \u2502 Int64  Float64   Float64   Int64   Int64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     4  0.727273  0.909091       8      10\n   2 \u2502     6  0.428571  0.571429       3       4\n   3 \u2502     8  0.142857  0.0            2       0\n</code></pre> <p>This links to examples which achieve the same result as the SQL queries.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>TidierDB.copy_to</code></li> <li><code>TidierDB.@arrange</code></li> <li><code>TidierDB.@count</code></li> <li><code>TidierDB.@distinct</code></li> <li><code>TidierDB.@filter</code></li> <li><code>TidierDB.@group_by</code></li> <li><code>TidierDB.@inner_join</code></li> <li><code>TidierDB.@left_join</code></li> <li><code>TidierDB.@mutate</code></li> <li><code>TidierDB.@rename</code></li> <li><code>TidierDB.@right_join</code></li> <li><code>TidierDB.@select</code></li> <li><code>TidierDB.@slice_max</code></li> <li><code>TidierDB.@slice_min</code></li> <li><code>TidierDB.@slice_sample</code></li> <li><code>TidierDB.@summarise</code></li> <li><code>TidierDB.@summarize</code></li> <li><code>TidierDB.@window_frame</code></li> <li><code>TidierDB.@window_order</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>TidierDB.copy_to</code> \u2014 Method.</p> <pre><code>   copy_to(conn, df_or_path, \"name\")\n</code></pre> <p>Allows user to copy a df to the database connection. Currently supports DuckDB, SQLite, MySql</p> <p>Arguments</p> <p>-<code>conn</code>: the database connection -<code>df</code>: dataframe to be copied or path to serve as source. With DuckDB, path supports .csv, .json, .parquet to be used without copying intermediary df. -<code>name</code>: name as string for the database to be used</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"test\");\n</code></pre> <p>source</p> <p># <code>TidierDB.@arrange</code> \u2014 Macro.</p> <pre><code>@arrange(sql_query, columns...)\n</code></pre> <p>Order SQL table rows based on specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by. Can include multiple columns for nested sorting. Wrap column name with <code>desc()</code> for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @arrange(value, desc(percent))\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF       aa            1       0.6\n   2 \u2502 AA       bb            1       0.1\n   3 \u2502 AG       bb            2       0.7\n   4 \u2502 AB       aa            2       0.2\n   5 \u2502 AH       aa            3       0.8\n   6 \u2502 AC       bb            3       0.3\n   7 \u2502 AI       bb            4       0.9\n   8 \u2502 AD       aa            4       0.4\n   9 \u2502 AJ       aa            5       1.0\n  10 \u2502 AE       bb            5       0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@count</code> \u2014 Macro.</p> <pre><code>@count(sql_query, columns...)\n</code></pre> <p>Count the number of rows grouped by specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to group by before counting. If no columns are specified, counts all rows in the query.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @count(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups   count  \n     \u2502 String?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            5\n   2 \u2502 bb            5\n</code></pre> <p>source</p> <p># <code>TidierDB.@distinct</code> \u2014 Macro.</p> <pre><code>@distinct(sql_query, columns...)\n</code></pre> <p>Select distinct rows based on specified column(s). Distinct works differently in TidierData vs SQL and therefore TidierDB. Distinct will also select only the only columns it is given (or all if given none)</p> <p>Arguments</p> <p><code>sql_query</code>: The SQL query to operate on. <code>columns</code>: Columns to determine uniqueness. If no columns are specified, all columns are used to identify distinct rows.</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct(value)\n         @arrange(value)\n         @collect\n       end\n5\u00d71 DataFrame\n Row \u2502 value  \n     \u2502 Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      1\n   2 \u2502      2\n   3 \u2502      3\n   4 \u2502      4\n   5 \u2502      5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct\n         @arrange(id)\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1\n   2 \u2502 AB       aa            2       0.2\n   3 \u2502 AC       bb            3       0.3\n   4 \u2502 AD       aa            4       0.4\n   5 \u2502 AE       bb            5       0.5\n   6 \u2502 AF       aa            1       0.6\n   7 \u2502 AG       bb            2       0.7\n   8 \u2502 AH       aa            3       0.8\n   9 \u2502 AI       bb            4       0.9\n  10 \u2502 AJ       aa            5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@filter</code> \u2014 Macro.</p> <pre><code>@filter(sql_query, conditions...)\n</code></pre> <p>Filter rows in a SQL table based on specified conditions.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to filter rows from.</li> <li> <p><code>conditions</code>: Expressions specifying the conditions that rows must satisfy to be included in the output.                   Rows for which the expression evaluates to <code>true</code> will be included in the result.                   Multiple conditions can be combined using logical operators (<code>&amp;&amp;</code>, <code>||</code>). It will automatically                   detect whether the conditions belong in WHERE vs HAVING. </p> <pre><code>             Temporarily, it is best to use begin and end when filtering multiple conditions. (ex 2 below)\n</code></pre> </li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @filter(percent &gt; .5)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF       aa            1       0.6\n   2 \u2502 AG       bb            2       0.7\n   3 \u2502 AH       aa            3       0.8\n   4 \u2502 AI       bb            4       0.9\n   5 \u2502 AJ       aa            5       1.0\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(mean = mean(percent))\n         @filter begin \n           groups == \"bb\" || # logical operators can still be used like this\n           mean &gt; .5\n         end\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups   mean     \n     \u2502 String?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            0.6\n   2 \u2502 bb            0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@group_by</code> \u2014 Macro.</p> <pre><code>@group_by(sql_query, columns...)\n</code></pre> <p>Group SQL table rows by specified column(s). If grouping is performed as a terminal operation without a subsequent mutatation or summarization (as in the example below), then the resulting data frame will be ungrouped when <code>@collect</code> is applied.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions specifying the columns to group by. Columns can be specified by name.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d71 DataFrame\n Row \u2502 groups  \n     \u2502 String? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa\n   2 \u2502 bb\n</code></pre> <p>source</p> <p># <code>TidierDB.@inner_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform an inner join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @inner_join(:df_join, id2, id)\n         @collect\n       end\n5\u00d77 DataFrame\n Row \u2502 id       groups   value   percent   id2      category  score  \n     \u2502 String?  String?  Int64?  Float64?  String?  String?   Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1  AA       X             88\n   2 \u2502 AC       bb            3       0.3  AC       Y             92\n   3 \u2502 AE       bb            5       0.5  AE       X             77\n   4 \u2502 AG       bb            2       0.7  AG       Y             83\n   5 \u2502 AI       bb            4       0.9  AI       X             95\n</code></pre> <p>source</p> <p># <code>TidierDB.@left_join</code> \u2014 Macro.</p> <pre><code>@left_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform a left join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @left_join(:df_join, id2, id)\n         @collect\n       end\n10\u00d77 DataFrame\n Row \u2502 id       groups   value   percent   id2      category  score   \n     \u2502 String?  String?  Int64?  Float64?  String?  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1  AA       X              88\n   2 \u2502 AC       bb            3       0.3  AC       Y              92\n   3 \u2502 AE       bb            5       0.5  AE       X              77\n   4 \u2502 AG       bb            2       0.7  AG       Y              83\n   5 \u2502 AI       bb            4       0.9  AI       X              95\n   6 \u2502 AB       aa            2       0.2  missing  missing   missing \n   7 \u2502 AD       aa            4       0.4  missing  missing   missing \n   8 \u2502 AF       aa            1       0.6  missing  missing   missing \n   9 \u2502 AH       aa            3       0.8  missing  missing   missing \n  10 \u2502 AJ       aa            5       1.0  missing  missing   missing \n</code></pre> <p>source</p> <p># <code>TidierDB.@mutate</code> \u2014 Macro.</p> <pre><code>@mutate(sql_query, exprs...)\n</code></pre> <p>Mutate SQL table rows by adding new columns or modifying existing ones.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions for mutating the table. New columns can be added or existing columns modified using column_name = expression syntax, where expression can involve existing columns.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @mutate(value = value * 4, new_col = percent^2)\n         @collect\n       end\n10\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   new_col  \n     \u2502 String?  String?  Int64?  Float64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            4       0.1      0.01\n   2 \u2502 AB       aa            8       0.2      0.04\n   3 \u2502 AC       bb           12       0.3      0.09\n   4 \u2502 AD       aa           16       0.4      0.16\n   5 \u2502 AE       bb           20       0.5      0.25\n   6 \u2502 AF       aa            4       0.6      0.36\n   7 \u2502 AG       bb            8       0.7      0.49\n   8 \u2502 AH       aa           12       0.8      0.64\n   9 \u2502 AI       bb           16       0.9      0.81\n  10 \u2502 AJ       aa           20       1.0      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@rename</code> \u2014 Macro.</p> <pre><code>@rename(sql_query, renamings...)\n</code></pre> <p>Rename one or more columns in a SQL query.</p> <p>Arguments</p> <p>-<code>sql_query</code>: The SQL query to operate on. -<code>renamings</code>: One or more pairs of old and new column names, specified as new name = old name </p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @rename(new_name = percent)\n       @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   new_name \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1\n   2 \u2502 AB       aa            2       0.2\n   3 \u2502 AC       bb            3       0.3\n   4 \u2502 AD       aa            4       0.4\n   5 \u2502 AE       bb            5       0.5\n   6 \u2502 AF       aa            1       0.6\n   7 \u2502 AG       bb            2       0.7\n   8 \u2502 AH       aa            3       0.8\n   9 \u2502 AI       bb            4       0.9\n  10 \u2502 AJ       aa            5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@right_join</code> \u2014 Macro.</p> <pre><code>@right_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform a right join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @right_join(:df_join, id2, id)\n         @collect\n       end\n7\u00d77 DataFrame\n Row \u2502 id       groups   value    percent    id2      category  score  \n     \u2502 String?  String?  Int64?   Float64?   String?  String?   Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb             1        0.1  AA       X             88\n   2 \u2502 AC       bb             3        0.3  AC       Y             92\n   3 \u2502 AE       bb             5        0.5  AE       X             77\n   4 \u2502 AG       bb             2        0.7  AG       Y             83\n   5 \u2502 AI       bb             4        0.9  AI       X             95\n   6 \u2502 missing  missing  missing  missing    AK       Y             68\n   7 \u2502 missing  missing  missing  missing    AM       X             74\n</code></pre> <p>source</p> <p># <code>TidierDB.@select</code> \u2014 Macro.</p> <pre><code>@select(sql_query, columns)\n</code></pre> <p>Select specified columns from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to select columns from.</li> <li><code>columns</code>: Expressions specifying the columns to select. Columns can be specified by name,                and new columns can be created with expressions using existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @select(groups:percent)\n         @collect\n       end\n10\u00d73 DataFrame\n Row \u2502 groups   value   percent  \n     \u2502 String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 bb            1       0.1\n   2 \u2502 aa            2       0.2\n   3 \u2502 bb            3       0.3\n   4 \u2502 aa            4       0.4\n   5 \u2502 bb            5       0.5\n   6 \u2502 aa            1       0.6\n   7 \u2502 bb            2       0.7\n   8 \u2502 aa            3       0.8\n   9 \u2502 bb            4       0.9\n  10 \u2502 aa            5       1.0\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @select(contains(\"e\"))\n         @collect\n       end\n10\u00d72 DataFrame\n Row \u2502 value   percent  \n     \u2502 Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      1       0.1\n   2 \u2502      2       0.2\n   3 \u2502      3       0.3\n   4 \u2502      4       0.4\n   5 \u2502      5       0.5\n   6 \u2502      1       0.6\n   7 \u2502      2       0.7\n   8 \u2502      3       0.8\n   9 \u2502      4       0.9\n  10 \u2502      5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_max</code> \u2014 Macro.</p> <pre><code>@slice_max(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the largest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the largest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_max(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_max(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   rank_col \n     \u2502 String?  String?  Int64?  Float64?  Int64?   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AE       bb            5       0.5         1\n   2 \u2502 AJ       aa            5       1.0         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_min</code> \u2014 Macro.</p> <pre><code>@slice_min(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the smallest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the smallest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_min(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_min(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   rank_col \n     \u2502 String?  String?  Int64?  Float64?  Int64?   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1         1\n   2 \u2502 AF       aa            1       0.6         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_sample</code> \u2014 Macro.</p> <pre><code>@slice_sample(sql_query, n)\n</code></pre> <p>Randomly select a specified number of rows from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>n</code>: The number of rows to randomly select.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_sample(n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @slice_sample()\n       @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarise</code> \u2014 Macro.</p> <pre><code>   @summarise(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((value:percent), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups   mean_value  mean_percent  sum_value  sum_percent \n     \u2502 String?  Float64?    Float64?      Int128?    Float64?    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa              3.0           0.6         15          3.0\n   2 \u2502 bb              3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups   test      n      \n     \u2502 String?  Float64?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            3.0       5\n   2 \u2502 bb            2.5       5\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarize</code> \u2014 Macro.</p> <pre><code>   @summarize(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((ends_with(\"e\"), starts_with(\"p\")), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups   mean_value  mean_percent  sum_value  sum_percent \n     \u2502 String?  Float64?    Float64?      Int128?    Float64?    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa              3.0           0.6         15          3.0\n   2 \u2502 bb              3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups   test      n      \n     \u2502 String?  Float64?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            3.0       5\n   2 \u2502 bb            2.5       5\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_frame</code> \u2014 Macro.</p> <pre><code>@window_frame(sql_query, frame_start::Int, frame_end::Int)\n</code></pre> <p>Define the window frame for window functions in a SQL query, specifying the range of rows to include in the calculation relative to the current row.</p> <p>Arguments</p> <p>sql_query: The SQL query to operate on, expected to be an instance of SQLQuery.</p> <ul> <li><code>frame_start</code>: The starting point of the window frame. A positive value indicates the start after the current row (FOLLOWING), a negative value indicates before the current row (PRECEDING), and 0 indicates the current row.</li> <li><code>frame_end</code>: The ending point of the window frame. A positive value indicates the end after the current row (FOLLOWING), a negative value indicates before the current row (PRECEDING), and 0 indicates the current row.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_order</code> \u2014 Macro.</p> <pre><code>   @window_order(sql_query, columns...)\n</code></pre> <p>Specify the order of rows for window functions within a SQL query.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by for the window function. Can include multiple columns for nested sorting. Prepend a column name with - for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":""},{"location":"examples/generated/UserGuide/getting_started/","title":"Getting Started","text":"<p>To use TidierDB.jl, you will have to set up a connection. TidierDB.jl gives you access to duckdb via <code>duckdb_open</code> and <code>duckdb_connect</code>. However, to use MySql, ClickHouse, MSSQL, Postgres, or SQLite, you will have to load those packages in first.</p> <p>If you plan to use TidierDB.jl with TidierData.jl or Tidier.jl, it is most convenenient to load the packages as follows:</p> <pre><code>using TidierData\nimport TidierDB as DB\n</code></pre> <p>Alternatively, <code>using Tidier</code> will import TidierDB in the above manner for you, where TidierDB functions and macros will be available as <code>DB.@mutate()</code> and so on, and the TidierData equivalent would be <code>@mutate()</code>.</p> <p>The associated databased packages used to set up connections are currently as follows</p> <ul> <li>ClickHouse: ClickHouse.jl</li> <li>MySQL: MySQL.jl</li> <li>MSSQL:  ODBC.jl</li> <li>Postgres: LibPQ.jl</li> <li>SQLite: SQLite.jl</li> </ul> <p>For DuckDB, SQLite, and MySQL, <code>copy_to()</code> lets you copy data to the database and query there. ClickHouse, MSSQL, and Postgres support for <code>copy_to()</code> has not been added yet.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/key_differences/","title":"Key Differences from TidierData.jl","text":"<p>There are a few important syntax and behavior differences between TidierDB.jl and TidierData.jl outlined below.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#creating-a-database","title":"Creating a database","text":"<p>For these examples we will use DuckDB, the default backend, although SQLite, Postgres, MySQL, MSSQL, and ClickHouse are possible. If you have an existing DuckDB connection, then this step is not required. For these examples, we will create a data frame and copy it to an in-memory DuckDB database.</p> <pre><code>using DataFrames, TidierDB\n\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\n mem = duckdb_open(\":memory:\");\n db = duckdb_connect(mem);\n\ncopy_to(db, df, \"df_mem\"); # copying over the data frame to an in-memory database\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#row-ordering","title":"Row ordering","text":"<p>DuckDB benefits from aggressive parallelization of pipelines. This means that if you have multiple threads enabled in Julia, which you can check or set using <code>Threads.nthreads()</code>, DuckDB will use multiple threads. However, because many operations are multi-threaded, the resulting row order is inconsistent. If row order needs to be deterministic for your use case, make sure to apply an <code>@arrange(column_name_1, column_name_2, etc...)</code> prior to collecting the results.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#starting-a-chain","title":"Starting a chain","text":"<p>When using TidierDB, <code>db_table(connection, :table_name)</code> is used to start a chain.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#grouped-mutation","title":"Grouped mutation","text":"<p>In TidierDB, when performing <code>@group_by</code> then <code>@mutate</code>, the table will be ungrouped after applying all of the mutations in the clause to the grouped data. To perform subsequent grouped operations, the user would have to regroup the data. This is demonstrated below.</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @summarize(mean_percent = mean(percent))\n    @collect\n end\n\n@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @mutate(max = maximum(percent), min = minimum(percent))\n    @group_by(groups)\n    @summarise(mean_percent = mean(percent))\n    @collect\nend\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentString?Float64?1bb0.52aa0.6 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#joining","title":"Joining","text":"<p>There are 2 key differences for joining:</p> <ol> <li>When joining 2 tables, the new table you are choosing to join must be prefixed with a colon.</li> <li>The column on both the new and old table must be specified. They do not need to be the same, and given SQL behavior where both columns are kept when joining two tables, it is preferable if they have different names. This avoids \"ambiguous reference\" errors that would otherwise come up and complicate the use of tidy selection for columns.</li> </ol> <pre><code>df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\n copy_to(db, df2, \"df_join\");\n\n@chain db_table(db, :df_mem) begin\n    @left_join(:df_join, id2, id)\n    @collect\nend\n</code></pre> 10\u00d77 DataFrame Rowidgroupsvaluepercentid2categoryscoreString?String?Int64?Float64?String?String?Int64?1AAbb10.1AAX882ACbb30.3ACY923AEbb50.5AEX774AGbb20.7AGY835AIbb40.9AIX956ABaa20.2missingmissingmissing7ADaa40.4missingmissingmissing8AFaa10.6missingmissingmissing9AHaa30.8missingmissingmissing10AJaa51.0missingmissingmissing <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#differences-in-case_when","title":"Differences in <code>case_when()</code>","text":"<p>In TidierDB, after the clause is completed, the result for the new column should is separated by a comma <code>,</code> in contrast to TidierData.jl, where the result for the new column is separated by a <code>=&gt;</code> .</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @mutate(new_col = case_when(percent &gt; .5, \"Pass\",  # in TidierData, percent &gt; .5 =&gt; \"Pass\",\n                                percent &lt;= .5, \"Try Again\", # percent &lt;= .5 =&gt; \"Try Again\"\n                                true, \"middle\"))\n    @collect\n end\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentnew_colString?String?Int64?Float64?String?1AAbb10.1Try Again2ABaa20.2Try Again3ACbb30.3Try Again4ADaa40.4Try Again5AEbb50.5Try Again6AFaa10.6Pass7AGbb20.7Pass8AHaa30.8Pass9AIbb40.9Pass10AJaa51.0Pass <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#interpolation","title":"Interpolation","text":"<p>To use !! Interpolation, instead of being able to define the alternate names/value in the global context, the user has to <code>add_interp_parameter!</code>. This will hopefully be fixed in future versions. Otherwise, the behavior is the same.</p> <p>Also, when using interpolation with exponenents, the interpolated value must go inside of parenthesis.</p> <pre><code>add_interp_parameter!(:test, :percent) # this still supports strings, vectors of names, and values\n\n@chain db_table(db, :df_mem) begin\n    @mutate(new_col = case_when((!!test)^2 &gt; .5, \"Pass\",\n                                (!!test)^2 &lt; .5, \"Try Again\",\n                                \"middle\"))\n    @collect\nend\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentnew_colString?String?Int64?Float64?String?1AAbb10.1Try Again2ABaa20.2Try Again3ACbb30.3Try Again4ADaa40.4Try Again5AEbb50.5Try Again6AFaa10.6Try Again7AGbb20.7Try Again8AHaa30.8Pass9AIbb40.9Pass10AJaa51.0Pass <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#slicing-ties","title":"Slicing ties","text":"<p><code>slice_min()</code> and <code>@slice_max()</code> will always return ties due to SQL behavior.</p> <p>This page was generated using Literate.jl.</p>"}]}