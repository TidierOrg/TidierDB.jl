{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-tidierdbjl","title":"What is TidierDB.jl?","text":"<p>TiderDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package.</p> <p>The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.</p> <p></p> <p></p>"},{"location":"#currently-supported-backends-include","title":"Currently supported backends include:","text":"DuckDB (default) <code>duckdb()</code> ClickHouse <code>clickhouse()</code> SQLite <code>sqlite()</code> Postgres <code>postgres()</code> MySQL <code>mysql()</code> MariaDB <code>mysql()</code> MSSQL <code>mssql()</code> Athena <code>athena()</code> Snowflake <code>snowflake()</code> Databricks <code>databricks()</code> Google Big Query <code>gbq()</code> Oracle <code>oracle()</code> <p>Change the backend using <code>set_sql_mode()</code> - for example  - <code>set_sql_mode(databricks())</code></p> <p></p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>For the stable version:</p> <pre><code>] add TidierDB\n</code></pre> <p>TidierDB.jl currently supports:</p> Category Supported Macros and Functions Data Manipulation <code>@arrange</code>, <code>@group_by</code>, <code>@filter</code>, <code>@select</code>, <code>@mutate</code> (supports <code>across</code>), <code>@summarize</code>/<code>@summarise</code> (supports <code>across</code>), <code>@distinct</code> Joining <code>@left_join</code>, <code>@right_join</code>, <code>@inner_join</code>, <code>@anti_join</code>, <code>@full_join</code>, <code>@semi_join</code>, <code>@union</code> Slice and Order <code>@slice_min</code>, <code>@slice_max</code>, <code>@slice_sample</code>, <code>@order</code>, <code>@window_order</code>, <code>@window_frame</code> Utility <code>@show_query</code>, <code>@collect</code>, <code>@head</code>, <code>@count</code>, <code>show_tables</code>, <code>@create_view</code> , <code>drop_view</code> Helper Functions <code>across</code>, <code>desc</code>, <code>if_else</code>, <code>case_when</code>, <code>n</code>, <code>starts_with</code>, <code>ends_with</code>, <code>contains</code>, <code>as_float</code>, <code>as_integer</code>, <code>as_string</code>, <code>is_missing</code>, <code>missing_if</code>, <code>replace_missing</code> TidierStrings.jl Functions <code>str_detect</code>, <code>str_replace</code>, <code>str_replace_all</code>, <code>str_remove_all</code>, <code>str_remove</code> TidierDates.jl Functions <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>min</code>, <code>second</code>, <code>floor_date</code>, <code>difftime</code>, <code>mdy</code>, <code>ymd</code>, <code>dmy</code> Aggregate Functions <code>mean</code>, <code>minimum</code>, <code>maximum</code>, <code>std</code>, <code>sum</code>, <code>cumsum</code>, <code>cor</code>, <code>cov</code>, <code>var</code>, all aggregate sql fxns <p><code>@summarize</code> supports any SQL aggregate function in addition to the list above. Simply write the function as written in SQL syntax and it will work.    <code>@mutate</code> supports all builtin SQL functions as well.                                                                                                 </p> <p>When using the DuckDB backend, if <code>db_table</code> recieves a file path ( <code>.parquet</code>, <code>.json</code>, <code>.csv</code>, <code>iceberg</code> or <code>delta</code>), it does not copy it into memory. This allows for queries on files too big for memory. <code>db_table</code> also supports S3 bucket locations via DuckDB.</p> <p></p> <p></p>"},{"location":"#what-is-the-recommended-way-to-use-tidierdb","title":"What is the recommended way to use TidierDB?","text":"<p>Typically, you will want to use TidierDB alongside TidierData because there are certain functionality (such as pivoting) which are only supported in TidierData and can only be performed on data frames.</p> <p>Our recommended path for using TidierDB is to import the package so that there are no namespace conflicts with TidierData. Once TidierDB is integrated with Tidier, then Tidier will automatically load the packages in this fashion.</p> <p>First, let's develop and execute a query using TidierDB. Notice that all top-level macros and functions originating from TidierDB start with a <code>DB</code> prefix. Any functions defined within macros do not need to be prefixed within <code>DB</code> because they are actually pseudofunctions that are in actuality converted into SQL code.</p> <p>Even though the code reads similarly to TidierData, note that no computational work actually occurs until you run <code>DB.@collect()</code>, which runs the SQL query and instantiates the result as a DataFrame.</p> <pre><code>using TidierData\nimport TidierDB as DB\n\ndb = DB.connect(DB.duckdb());\npath_or_name = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n\n@chain DB.db_table(db, path_or_name) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\nend\n</code></pre> <pre><code>2\u00d75 DataFrame\n Row \u2502 cyl     mpg       mpg_squared  mpg_rounded  mpg_efficiency \n     \u2502 Int64?  Float64?  Float64?     Float64?     String?        \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4   27.3444      747.719         27.0  efficient\n   2 \u2502      6   19.7333      389.404         20.0  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-if-we-wanted-to-pivot-the-result","title":"What if we wanted to pivot the result?","text":"<p>We cannot do this using TidierDB. However, we can call <code>@pivot_longer()</code> from TidierData after the result of the query has been instantiated as a DataFrame, like this: </p> <pre><code>@chain DB.db_table(db, path_or_name) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\n    @pivot_longer(everything(), names_to = \"variable\", values_to = \"value\")\nend\n</code></pre> <pre><code>10\u00d72 DataFrame\n Row \u2502 variable        value     \n     \u2502 String          Any       \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 cyl             4\n   2 \u2502 cyl             6\n   3 \u2502 mpg             27.3444\n   4 \u2502 mpg             19.7333\n   5 \u2502 mpg_squared     747.719\n   6 \u2502 mpg_squared     389.404\n   7 \u2502 mpg_rounded     27.0\n   8 \u2502 mpg_rounded     20.0\n   9 \u2502 mpg_efficiency  efficient\n  10 \u2502 mpg_efficiency  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-sql-query-does-tidierdb-generate-for-a-given-piece-of-julia-code","title":"What SQL query does TidierDB generate for a given piece of Julia code?","text":"<p>We can replace <code>DB.collect()</code> with <code>DB.@show_query</code> to reveal the underlying SQL query being generated by TidierDB. To handle complex queries, TidierDB makes heavy use of Common Table Expressions (CTE), which are a useful tool to organize long queries.</p> <pre><code>@chain DB.db_table(db, path_or_name) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@show_query\nend\n</code></pre> <pre><code>WITH cte_1 AS (\nSELECT *\n        FROM mtcars\n        WHERE NOT (starts_with(model, 'M'))),\ncte_2 AS (\nSELECT cyl, AVG(mpg) AS mpg\n        FROM cte_1\n        GROUP BY cyl),\ncte_3 AS (\nSELECT  cyl, mpg, POWER(mpg, 2) AS mpg_squared, ROUND(mpg) AS mpg_rounded, CASE WHEN mpg &gt;= POWER(cyl, 2) THEN 'efficient' WHEN mpg &lt; 15.2 THEN 'inefficient' ELSE 'moderate' END AS mpg_efficiency\n        FROM cte_2 ),\ncte_4 AS (\nSELECT *\n        FROM cte_3\n        WHERE mpg_efficiency in ('moderate', 'efficient'))  \nSELECT *\n        FROM cte_4  \n        ORDER BY mpg_rounded DESC\n</code></pre> <p></p> <p></p>"},{"location":"#tidierdb-is-already-quite-fully-featured-supporting-advanced-tidierdata-functions-like-across-for-multi-column-selection","title":"TidierDB is already quite fully-featured, supporting advanced TidierData functions like <code>across()</code> for multi-column selection.","text":"<pre><code>@chain DB.db_table(db, path_or_name) begin\n    DB.@group_by(cyl)\n    DB.@summarize(across((starts_with(\"a\"), ends_with(\"s\")), (mean, sum)))\n    DB.@collect\nend\n</code></pre> <pre><code>3\u00d75 DataFrame\n Row \u2502 cyl     am_mean   vs_mean   am_sum   vs_sum  \n     \u2502 Int64?  Float64?  Float64?  Int128?  Int128? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4  0.727273  0.909091        8       10\n   2 \u2502      6  0.428571  0.571429        3        4\n   3 \u2502      8  0.142857  0.0             2        0\n</code></pre> <p>Bang bang <code>!!</code> interpolation for columns and values is also supported.</p> <p>There are a few subtle but important differences from Tidier.jl outlined here.</p> <p></p> <p></p>"},{"location":"#missing-a-function-or-backend","title":"Missing a function or backend?","text":"<p>You can use any existing SQL function within <code>@mutate</code> with the correct SQL syntax and it should just work.</p> <p>But if you run into problems please open an issue, and we will be happy to take a look!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>TidierDB.connect</code></li> <li><code>TidierDB.copy_to</code></li> <li><code>TidierDB.db_table</code></li> <li><code>TidierDB.show_tables</code></li> <li><code>TidierDB.warnings</code></li> <li><code>TidierDB.@anti_join</code></li> <li><code>TidierDB.@arrange</code></li> <li><code>TidierDB.@collect</code></li> <li><code>TidierDB.@count</code></li> <li><code>TidierDB.@create_view</code></li> <li><code>TidierDB.@distinct</code></li> <li><code>TidierDB.@filter</code></li> <li><code>TidierDB.@full_join</code></li> <li><code>TidierDB.@group_by</code></li> <li><code>TidierDB.@head</code></li> <li><code>TidierDB.@inner_join</code></li> <li><code>TidierDB.@left_join</code></li> <li><code>TidierDB.@mutate</code></li> <li><code>TidierDB.@rename</code></li> <li><code>TidierDB.@right_join</code></li> <li><code>TidierDB.@select</code></li> <li><code>TidierDB.@semi_join</code></li> <li><code>TidierDB.@slice_max</code></li> <li><code>TidierDB.@slice_min</code></li> <li><code>TidierDB.@slice_sample</code></li> <li><code>TidierDB.@summarise</code></li> <li><code>TidierDB.@summarize</code></li> <li><code>TidierDB.@union</code></li> <li><code>TidierDB.@window_frame</code></li> <li><code>TidierDB.@window_order</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>TidierDB.connect</code> \u2014 Method.</p> <pre><code>connect(backend; kwargs...)\n</code></pre> <p>This function establishes a database connection based on the specified backend and connection parameters and sets the SQL mode</p> <p>Arguments</p> <ul> <li> <p><code>backend</code>: type specifying the database backend to connect to. Supported backends are:</p> <ul> <li><code>duckdb()</code>, <code>sqlite()</code>(SQLite), <code>mssql()</code>, <code>mysql()</code>(for MariaDB and MySQL), <code>clickhouse()</code>, <code>postgres()</code></li> <li> <p><code>kwargs</code>: Keyword arguments specifying the connection parameters for the selected backend. The required parameters vary depending on the backend:</p> </li> <li> <p>MySQL:</p> <ul> <li><code>host</code>: The host name or IP address of the MySQL server. Default is \"localhost\".</li> <li><code>user</code>: The username for authentication. Default is an empty string.</li> <li><code>password</code>: The password for authentication.</li> <li><code>db</code>: The name of the database to connect to (optional).</li> <li><code>port</code>: The port number of the MySQL server (optional).</li> </ul> </li> </ul> </li> </ul> <p>Returns</p> <ul> <li>A database connection object based on the selected backend.</li> </ul> <p>Examples</p> <pre><code># Connect to MySQL\n# conn = connect(mysql(); host=\"localhost\", user=\"root\", password=\"password\", db=\"mydb\")\n# Connect to PostgreSQL using LibPQ\n# conn = connect(postgres(); host=\"localhost\", dbname=\"mydb\", user=\"postgres\", password=\"password\")\n# Connect to ClickHouse\n# conn = connect(clickhouse(); host=\"localhost\", port=9000, database=\"mydb\", user=\"default\", password=\"\")\n# Connect to SQLite\n# conn = connect(sqlite())\n# Connect to Google Big Query\n# conn = connect(gbq(), \"json_user_key_path\", \"location\")\n# Connect to Snowflake\n# conn = connect(snowflake(), \"ac_id\", \"token\", \"Database_name\", \"Schema_name\", \"warehouse_name\")\n# Connect to Microsoft SQL Server\n# conn = connect(mssql(), \"DRIVER={ODBC Driver 18 for SQL Server};SERVER=host,1433;UID=sa;PWD=YourPassword;Encrypt=no;TrustServerCertificate=yes\")\n# Connect to DuckDB\n# connect to Google Cloud via DuckDB\n# google_db = connect(duckdb(), :gbq, access_key=\"string\", secret_key=\"string\")\n# Connect to AWS via DuckDB\n# aws_db = connect2(duckdb(), :aws, aws_access_key_id=get(ENV, \"AWS_ACCESS_KEY_ID\", \"access_key\"), aws_secret_access_key=get(ENV, \"AWS_SECRET_ACCESS_KEY\", \"secret_access key\"), aws_region=get(ENV, \"AWS_DEFAULT_REGION\", \"us-east-1\"))\n# Connect to MotherDuck\n# connect(duckdb(), \"\"md://...\"\") for first connection, vs connect(duckdb(), \"md:\") for reconnection\n# Connect to exisiting database file\n# connect(duckdb(), \"path/to/database.duckdb\")\n# Open an in-memory database\njulia&gt; db = connect(duckdb())\nDuckDB.Connection(\":memory:\")\n</code></pre> <p>source</p> <p># <code>TidierDB.copy_to</code> \u2014 Method.</p> <pre><code>   copy_to(conn, df_or_path, \"name\")\n</code></pre> <p>Allows user to copy a df to the database connection. Currently supports DuckDB, SQLite, MySql</p> <p>Arguments</p> <p>-<code>conn</code>: the database connection -<code>df</code>: dataframe to be copied or path to serve as source. With DuckDB, path supports .csv, .json, .parquet to be used without copying intermediary df. -<code>name</code>: name as string for the database to be used</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"test\");\n</code></pre> <p>source</p> <p># <code>TidierDB.db_table</code> \u2014 Function.</p> <pre><code>db_table(database, table_name, athena_params, delta = false, iceberg = false)\n</code></pre> <p><code>db_table</code> starts the underlying SQL query struct, adding the metadata and table. If paths are passed directly to db*table instead of a  name it will not copy it to memory, but rather ready directly from the file. <code>db*table</code>only supports direct file paths to a table. It does not support database file paths such as<code>dbname.duckdb</code>or<code>dbname.sqlite</code>. Such files must be used with<code>connect first</code></p> <p>Arguments</p> <ul> <li><code>database</code>: The Database or connection object</li> <li> <p><code>table_name</code>: tablename as a string (name, local path, or URL).     - CSV/TSV       - Parquet     - Json      - Iceberg     - Delta     - S3 tables from AWS or Google Cloud </p> <ul> <li>DuckDB and ClickHouse support vectors of paths and URLs.</li> <li>DuckDB and ClickHouse also support use of <code>*</code> wildcards to read all files of a type in a location such as:</li> <li><code>db_table(db, \"Path/to/testing_files/*.parquet\")</code></li> <li><code>delta</code>: must be true to read delta files</li> <li><code>iceberg</code>: must be true to read iceberg finalize_ctes</li> </ul> </li> </ul> <p>Example</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; db_table(db, \"df_mem\")\nTidierDB.SQLQuery(\"\", \"df_mem\", \"\", \"\", \"\", \"\", \"\", \"\", false, false, 4\u00d74 DataFrame\n Row \u2502 name     type     current_selxn  table_name \n     \u2502 String?  String?  Int64          String     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 id       VARCHAR              1  df_mem\n   2 \u2502 groups   VARCHAR              1  df_mem\n   3 \u2502 value    BIGINT               1  df_mem\n   4 \u2502 percent  DOUBLE               1  df_mem, false, DuckDB.Connection(\":memory:\"), TidierDB.CTE[], 0, nothing)\n</code></pre> <p>source</p> <p># <code>TidierDB.show_tables</code> \u2014 Method.</p> <pre><code>show_tables(con; GBQ_datasetname)\n</code></pre> <p>Shows tables available in database. currently supports DuckDB, databricks, Snowflake, GBQ, SQLite, LibPQ</p> <p>Arguments</p> <ul> <li><code>con</code> : connection to backend</li> <li><code>GBQ_datasetname</code> : string of dataset name</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; show_tables(db);\n</code></pre> <p>source</p> <p># <code>TidierDB.warnings</code> \u2014 Method.</p> <pre><code>warnings(show::Bool)\n</code></pre> <p>Sets the global warning flag to the specified boolean value.</p> <p>Arguments</p> <ul> <li><code>flag::Bool</code>: A boolean value to set the warning flag. If <code>true</code>, warnings will be enabled; if <code>false</code>, warnings will be disabled.</li> </ul> <p>Default Behavior</p> <p>By default, the warning flag is set to <code>false</code>, meaning that warnings are disabled unless explicitly enabled by setting this function with <code>true</code>.</p> <p>Example</p> <pre><code>julia&gt; warnings(true);\n</code></pre> <p>source</p> <p># <code>TidierDB.@anti_join</code> \u2014 Macro.</p> <pre><code>@anti_join(sql_query, join_table, orignal_table_col = new_table_col)\n</code></pre> <p>Perform an anti join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n        @anti_join(\"df_join\", id = id2)\n        @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa          2      0.2\n   2 \u2502 AD      aa          4      0.4\n   3 \u2502 AF      aa          1      0.6\n   4 \u2502 AH      aa          3      0.8\n   5 \u2502 AJ      aa          5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@arrange</code> \u2014 Macro.</p> <pre><code>@arrange(sql_query, columns...)\n</code></pre> <p>Order SQL table rows based on specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by. Can include multiple columns for nested sorting. Wrap column name with <code>desc()</code> for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @arrange(value, desc(percent))\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF      aa          1      0.6\n   2 \u2502 AA      bb          1      0.1\n   3 \u2502 AG      bb          2      0.7\n   4 \u2502 AB      aa          2      0.2\n   5 \u2502 AH      aa          3      0.8\n   6 \u2502 AC      bb          3      0.3\n   7 \u2502 AI      bb          4      0.9\n   8 \u2502 AD      aa          4      0.4\n   9 \u2502 AJ      aa          5      1.0\n  10 \u2502 AE      bb          5      0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@collect</code> \u2014 Macro.</p> <pre><code>@collect(sql_query, stream = false)\n</code></pre> <p><code>db_table</code> starts the underlying SQL query struct, adding the metadata and table. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>stream</code>: optional streaming for query/execution of results when using duck db. Defaults to false</li> </ul> <p>Example</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @collect db_table(db, \"df_mem\")\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n   2 \u2502 AB      aa          2      0.2\n   3 \u2502 AC      bb          3      0.3\n   4 \u2502 AD      aa          4      0.4\n   5 \u2502 AE      bb          5      0.5\n   6 \u2502 AF      aa          1      0.6\n   7 \u2502 AG      bb          2      0.7\n   8 \u2502 AH      aa          3      0.8\n   9 \u2502 AI      bb          4      0.9\n  10 \u2502 AJ      aa          5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@count</code> \u2014 Macro.</p> <pre><code>@count(sql_query, columns...)\n</code></pre> <p>Count the number of rows grouped by specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to group by before counting. If no columns are specified, counts all rows in the query.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @count(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups  count \n     \u2502 String  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          5\n   2 \u2502 bb          5\n</code></pre> <p>source</p> <p># <code>TidierDB.@create_view</code> \u2014 Macro.</p> <pre><code>@view(sql_query, name, replace = true)\n</code></pre> <p>Create a view from a SQL query. Currently supports DuckDB, MySQL, GBQ, Postgres</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to create a view from.</li> <li><code>name</code>: The name of the view to create.</li> <li><code>replace</code>: defaults to true if view should be replaced</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(id = [1, 2, 3], value = [10, 20, 30]);\n\njulia&gt; copy_to(db, df, \"df1\");\n\njulia&gt; @chain db_table(db, \"df1\") @create_view(viewer);\n\njulia&gt; db_table(db, \"viewer\")\nTidierDB.SQLQuery(\"\", \"viewer\", \"\", \"\", \"\", \"\", \"\", \"\", false, false, 2\u00d74 DataFrame\n Row \u2502 name    type    current_selxn  table_name \n     \u2502 String  String  Int64          String     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 id      BIGINT              1  viewer\n   2 \u2502 value   BIGINT              1  viewer, false, DuckDB.DB(\":memory:\"), TidierDB.CTE[], 0, nothing, \"\", \"\", 0)\n</code></pre> <p>source</p> <p># <code>TidierDB.@distinct</code> \u2014 Macro.</p> <pre><code>@distinct(sql_query, columns...)\n</code></pre> <p>Select distinct rows based on specified column(s). Distinct works differently in TidierData vs SQL and therefore TidierDB. Distinct will also select only the only columns it is given (or all if given none)</p> <p>Arguments</p> <p><code>sql_query</code>: The SQL query to operate on. <code>columns</code>: Columns to determine uniqueness. If no columns are specified, all columns are used to identify distinct rows.</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct(value)\n         @arrange(value)\n         @collect\n       end\n5\u00d71 DataFrame\n Row \u2502 value \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1\n   2 \u2502     2\n   3 \u2502     3\n   4 \u2502     4\n   5 \u2502     5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct\n         @arrange(id)\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n   2 \u2502 AB      aa          2      0.2\n   3 \u2502 AC      bb          3      0.3\n   4 \u2502 AD      aa          4      0.4\n   5 \u2502 AE      bb          5      0.5\n   6 \u2502 AF      aa          1      0.6\n   7 \u2502 AG      bb          2      0.7\n   8 \u2502 AH      aa          3      0.8\n   9 \u2502 AI      bb          4      0.9\n  10 \u2502 AJ      aa          5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@filter</code> \u2014 Macro.</p> <pre><code>@filter(sql_query, conditions...)\n</code></pre> <p>Filter rows in a SQL table based on specified conditions.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to filter rows from.</li> <li> <p><code>conditions</code>: Expressions specifying the conditions that rows must satisfy to be included in the output.                   Rows for which the expression evaluates to <code>true</code> will be included in the result.                   Multiple conditions can be combined using logical operators (<code>&amp;&amp;</code>, <code>||</code>). It will automatically                   detect whether the conditions belong in WHERE vs HAVING. </p> <pre><code>             Temporarily, it is best to use begin and end when filtering multiple conditions. (ex 2 below)\n</code></pre> </li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @filter(percent &gt; .5)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF      aa          1      0.6\n   2 \u2502 AG      bb          2      0.7\n   3 \u2502 AH      aa          3      0.8\n   4 \u2502 AI      bb          4      0.9\n   5 \u2502 AJ      aa          5      1.0\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(mean = mean(percent))\n         @filter begin \n           groups == \"bb\" || # logical operators can still be used like this\n           mean &gt; .5\n         end\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups  mean    \n     \u2502 String  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          0.6\n   2 \u2502 bb          0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@full_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, orignal_table_col = new_table_col)\n</code></pre> <p>Perform an full join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @full_join((@chain db_table(db, \"df_join\") @filter(score &gt; 70)), id = id2)\n         #@aside @show_query _\n         @collect\n       end\n11\u00d77 DataFrame\n Row \u2502 id       groups   value    percent    id2      category  score   \n     \u2502 String?  String?  Int64?   Float64?   String?  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb             1        0.1  AA       X              88\n   2 \u2502 AC       bb             3        0.3  AC       Y              92\n   3 \u2502 AE       bb             5        0.5  AE       X              77\n   4 \u2502 AG       bb             2        0.7  AG       Y              83\n   5 \u2502 AI       bb             4        0.9  AI       X              95\n   6 \u2502 AB       aa             2        0.2  missing  missing   missing \n   7 \u2502 AD       aa             4        0.4  missing  missing   missing \n   8 \u2502 AF       aa             1        0.6  missing  missing   missing \n   9 \u2502 AH       aa             3        0.8  missing  missing   missing \n  10 \u2502 AJ       aa             5        1.0  missing  missing   missing \n  11 \u2502 missing  missing  missing  missing    AM       X              74\n</code></pre> <p>source</p> <p># <code>TidierDB.@group_by</code> \u2014 Macro.</p> <pre><code>@group_by(sql_query, columns...)\n</code></pre> <p>Group SQL table rows by specified column(s). If grouping is performed as a terminal operation without a subsequent mutatation or summarization (as in the example below), then the resulting data frame will be ungrouped when <code>@collect</code> is applied.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions specifying the columns to group by. Columns can be specified by name.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d71 DataFrame\n Row \u2502 groups \n     \u2502 String \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa\n   2 \u2502 bb\n</code></pre> <p>source</p> <p># <code>TidierDB.@head</code> \u2014 Macro.</p> <pre><code>@head(sql_query, value)\n</code></pre> <p>Limit SQL table number of rows returned based on specified value.  <code>LIMIT</code> in SQL</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>value</code>: Number to limit how many rows are returned. If left empty, it will default to 6 rows</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; copy_to(db, df, \"df_mem\");                     \n\njulia&gt; @chain db_table(db, :df_mem) begin\n        @head(1) ## supports expressions ie `3-2` would return the same df below\n        @collect\n       end\n1\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n</code></pre> <p>source</p> <p># <code>TidierDB.@inner_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, orignal_table_col = new_table_col)\n</code></pre> <p>Perform an inner join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @inner_join(\"df_join\", \"id\" = id2)\n         @collect\n       end\n5\u00d77 DataFrame\n Row \u2502 id      groups  value  percent  id2     category  score \n     \u2502 String  String  Int64  Float64  String  String    Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1  AA      X            88\n   2 \u2502 AC      bb          3      0.3  AC      Y            92\n   3 \u2502 AE      bb          5      0.5  AE      X            77\n   4 \u2502 AG      bb          2      0.7  AG      Y            83\n   5 \u2502 AI      bb          4      0.9  AI      X            95\n</code></pre> <p>source</p> <p># <code>TidierDB.@left_join</code> \u2014 Macro.</p> <pre><code>@left_join(sql_query, join_table, orignal_table_col = new_table_col)\n</code></pre> <p>Perform a left join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, \"df_mem\") begin\n         @left_join(\"df_join\", \"id\" = \"id2\" )\n         @collect\n       end\n10\u00d77 DataFrame\n Row \u2502 id      groups  value  percent  id2      category  score   \n     \u2502 String  String  Int64  Float64  String?  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1  AA       X              88\n   2 \u2502 AC      bb          3      0.3  AC       Y              92\n   3 \u2502 AE      bb          5      0.5  AE       X              77\n   4 \u2502 AG      bb          2      0.7  AG       Y              83\n   5 \u2502 AI      bb          4      0.9  AI       X              95\n   6 \u2502 AB      aa          2      0.2  missing  missing   missing \n   7 \u2502 AD      aa          4      0.4  missing  missing   missing \n   8 \u2502 AF      aa          1      0.6  missing  missing   missing \n   9 \u2502 AH      aa          3      0.8  missing  missing   missing \n  10 \u2502 AJ      aa          5      1.0  missing  missing   missing \n\njulia&gt; query = @chain db_table(db, \"df_join\") begin\n                  @filter(score &gt; 85) # only show scores above 85 in joining table\n                end;\n\njulia&gt; @chain db_table(db, \"df_mem\") begin\n         @left_join(t(query), id = id2)\n         @collect\n       end\n10\u00d77 DataFrame\n Row \u2502 id      groups  value  percent  id2      category  score   \n     \u2502 String  String  Int64  Float64  String?  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1  AA       X              88\n   2 \u2502 AC      bb          3      0.3  AC       Y              92\n   3 \u2502 AI      bb          4      0.9  AI       X              95\n   4 \u2502 AB      aa          2      0.2  missing  missing   missing \n   5 \u2502 AD      aa          4      0.4  missing  missing   missing \n   6 \u2502 AE      bb          5      0.5  missing  missing   missing \n   7 \u2502 AF      aa          1      0.6  missing  missing   missing \n   8 \u2502 AG      bb          2      0.7  missing  missing   missing \n   9 \u2502 AH      aa          3      0.8  missing  missing   missing \n  10 \u2502 AJ      aa          5      1.0  missing  missing   missing \n</code></pre> <p>source</p> <p># <code>TidierDB.@mutate</code> \u2014 Macro.</p> <pre><code>@mutate(sql_query, exprs...)\n</code></pre> <p>Mutate SQL table rows by adding new columns or modifying existing ones.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions for mutating the table. New columns can be added or existing columns modified using column_name = expression syntax, where expression can involve existing columns.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @mutate(value = value * 4, new_col = percent^2)\n         @collect\n       end\n10\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  new_col \n     \u2502 String  String  Int64  Float64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          4      0.1     0.01\n   2 \u2502 AB      aa          8      0.2     0.04\n   3 \u2502 AC      bb         12      0.3     0.09\n   4 \u2502 AD      aa         16      0.4     0.16\n   5 \u2502 AE      bb         20      0.5     0.25\n   6 \u2502 AF      aa          4      0.6     0.36\n   7 \u2502 AG      bb          8      0.7     0.49\n   8 \u2502 AH      aa         12      0.8     0.64\n   9 \u2502 AI      bb         16      0.9     0.81\n  10 \u2502 AJ      aa         20      1.0     1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@rename</code> \u2014 Macro.</p> <pre><code>@rename(sql_query, renamings...)\n</code></pre> <p>Rename one or more columns in a SQL query.</p> <p>Arguments</p> <p>-<code>sql_query</code>: The SQL query to operate on. -<code>renamings</code>: One or more pairs of old and new column names, specified as new name = old name </p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @rename(new_name = percent)\n       @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  new_name \n     \u2502 String  String  Int64  Float64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1       0.1\n   2 \u2502 AB      aa          2       0.2\n   3 \u2502 AC      bb          3       0.3\n   4 \u2502 AD      aa          4       0.4\n   5 \u2502 AE      bb          5       0.5\n   6 \u2502 AF      aa          1       0.6\n   7 \u2502 AG      bb          2       0.7\n   8 \u2502 AH      aa          3       0.8\n   9 \u2502 AI      bb          4       0.9\n  10 \u2502 AJ      aa          5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@right_join</code> \u2014 Macro.</p> <pre><code>@right_join(sql_query, join_table, orignal_table_col = new_table_col)\n</code></pre> <p>Perform a right join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @right_join(\"df_join\", id = id2)\n         @collect\n       end\n7\u00d77 DataFrame\n Row \u2502 id       groups   value    percent    id2     category  score \n     \u2502 String?  String?  Int64?   Float64?   String  String    Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb             1        0.1  AA      X            88\n   2 \u2502 AC       bb             3        0.3  AC      Y            92\n   3 \u2502 AE       bb             5        0.5  AE      X            77\n   4 \u2502 AG       bb             2        0.7  AG      Y            83\n   5 \u2502 AI       bb             4        0.9  AI      X            95\n   6 \u2502 missing  missing  missing  missing    AK      Y            68\n   7 \u2502 missing  missing  missing  missing    AM      X            74\n\njulia&gt; query = @chain db_table(db, \"df_join\") begin\n                  @filter(score &gt;= 74) # only show scores above 85 in joining table\n                end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @right_join(t(query), id = id2)\n         @collect\n       end\n6\u00d77 DataFrame\n Row \u2502 id       groups   value    percent    id2     category  score \n     \u2502 String?  String?  Int64?   Float64?   String  String    Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb             1        0.1  AA      X            88\n   2 \u2502 AC       bb             3        0.3  AC      Y            92\n   3 \u2502 AE       bb             5        0.5  AE      X            77\n   4 \u2502 AG       bb             2        0.7  AG      Y            83\n   5 \u2502 AI       bb             4        0.9  AI      X            95\n   6 \u2502 missing  missing  missing  missing    AM      X            74\n</code></pre> <p>source</p> <p># <code>TidierDB.@select</code> \u2014 Macro.</p> <pre><code>@select(sql_query, columns)\n</code></pre> <p>Select specified columns from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to select columns from.</li> <li><code>columns</code>: Expressions specifying the columns to select. Columns can be specified by name,                and new columns can be created with expressions using existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; df_mem = db_table(db, :df_mem);\n\njulia&gt; @chain t(df_mem) begin\n         @select(groups:percent)\n         @collect\n       end\n10\u00d73 DataFrame\n Row \u2502 groups  value  percent \n     \u2502 String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 bb          1      0.1\n   2 \u2502 aa          2      0.2\n   3 \u2502 bb          3      0.3\n   4 \u2502 aa          4      0.4\n   5 \u2502 bb          5      0.5\n   6 \u2502 aa          1      0.6\n   7 \u2502 bb          2      0.7\n   8 \u2502 aa          3      0.8\n   9 \u2502 bb          4      0.9\n  10 \u2502 aa          5      1.0\n\njulia&gt; @chain t(df_mem) begin\n         @select(contains(\"e\"))\n         @collect\n       end\n10\u00d72 DataFrame\n Row \u2502 value  percent \n     \u2502 Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      0.1\n   2 \u2502     2      0.2\n   3 \u2502     3      0.3\n   4 \u2502     4      0.4\n   5 \u2502     5      0.5\n   6 \u2502     1      0.6\n   7 \u2502     2      0.7\n   8 \u2502     3      0.8\n   9 \u2502     4      0.9\n  10 \u2502     5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@semi_join</code> \u2014 Macro.</p> <pre><code>@semi_join(sql_query, join_table, orignal_table_col = new_table_col)\n</code></pre> <p>Perform an semi join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @semi_join(\"df_join\", id = id2)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n   2 \u2502 AC      bb          3      0.3\n   3 \u2502 AE      bb          5      0.5\n   4 \u2502 AG      bb          2      0.7\n   5 \u2502 AI      bb          4      0.9\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_max</code> \u2014 Macro.</p> <pre><code>@slice_max(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the largest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the largest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_max(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_max(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AE      bb          5      0.5         1\n   2 \u2502 AJ      aa          5      1.0         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_min</code> \u2014 Macro.</p> <pre><code>@slice_min(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the smallest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the smallest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_min(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_min(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1         1\n   2 \u2502 AF      aa          1      0.6         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_sample</code> \u2014 Macro.</p> <pre><code>@slice_sample(sql_query, n)\n</code></pre> <p>Randomly select a specified number of rows from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>n</code>: The number of rows to randomly select.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_sample(n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @slice_sample()\n       @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarise</code> \u2014 Macro.</p> <pre><code>   @summarise(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((value:percent), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups  value_mean  percent_mean  value_sum  percent_sum \n     \u2502 String  Float64     Float64       Int128     Float64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa             3.0           0.6         15          3.0\n   2 \u2502 bb             3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups  test     n     \n     \u2502 String  Float64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          3.0      5\n   2 \u2502 bb          2.5      5\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarize</code> \u2014 Macro.</p> <pre><code>   @summarize(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((ends_with(\"e\"), starts_with(\"p\")), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups  value_mean  percent_mean  value_sum  percent_sum \n     \u2502 String  Float64     Float64       Int128     Float64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa             3.0           0.6         15          3.0\n   2 \u2502 bb             3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups  test     n     \n     \u2502 String  Float64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          3.0      5\n   2 \u2502 bb          2.5      5\n</code></pre> <p>source</p> <p># <code>TidierDB.@union</code> \u2014 Macro.</p> <pre><code>@union(sql_query1, sql_query2)\n</code></pre> <p>Combine two SQL queries using the <code>UNION</code> operator.</p> <p>Arguments</p> <ul> <li><code>sql_query1</code>: The first SQL query to combine.</li> <li><code>sql_query2</code>: The second SQL query to combine.</li> </ul> <p>Returns</p> <ul> <li>A new SQL query struct representing the combined queries.</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df1 = DataFrame(id = [1, 2, 3], value = [10, 20, 30]);\n\njulia&gt; df2 = DataFrame(id = [4, 5, 6], value = [40, 50, 60]);\n\njulia&gt; copy_to(db, df1, \"df1\");\n\njulia&gt; copy_to(db, df2, \"df2\");\n\njulia&gt; df1_table = db_table(db, \"df1\");\n\njulia&gt; df2_table = db_table(db, \"df2\");\n\njulia&gt; @chain t(df1_table) @union(df2_table) @collect\n6\u00d72 DataFrame\n Row \u2502 id     value \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10\n   2 \u2502     2     20\n   3 \u2502     3     30\n   4 \u2502     4     40\n   5 \u2502     5     50\n   6 \u2502     6     60\n\njulia&gt; query = @chain t(df2_table) @filter(value == 50);\n\njulia&gt; @chain t(df1_table) begin \n        @union(t(query))\n        @collect\n       end\n4\u00d72 DataFrame\n Row \u2502 id     value \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10\n   2 \u2502     2     20\n   3 \u2502     3     30\n   4 \u2502     5     50\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_frame</code> \u2014 Macro.</p> <pre><code>@window_frame(sql_query, args...)\n</code></pre> <p>Define the window frame for window functions in a SQL query, specifying the range of rows to include in the calculation relative to the current row.</p> <p>Arguments</p> <ul> <li><code>sqlquery::SQLQuery</code>: The SQLQuery instance to which the window frame will be applied.</li> <li> <p><code>args...</code>: A variable number of arguments specifying the frame boundaries. These can be:</p> <ul> <li><code>from</code>: The starting point of the frame. Can be a positive or negative integer, 0 or empty. When empty, it will use UNBOUNDED</li> <li><code>to</code>: The ending point of the frame. Can be a positive or negative integer,  0 or empty. When empty, it will use UNBOUNDED</li> <li>if only one integer is provided without specifying <code>to</code> or <code>from</code> it will default to from, and to will be UNBOUNDED.</li> <li>if no arguments are given, both will be UNBOUNDED</li> </ul> </li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; df_mem = db_table(db, :df_mem);\n\njulia&gt; @chain t(df_mem) begin\n        @group_by groups\n        @window_frame(3)\n        @mutate(avg = mean(percent))\n        #@show_query\n       end;\n\njulia&gt; @chain t(df_mem) begin\n        @group_by groups\n        @window_frame(-3, 3)\n        @mutate(avg = mean(percent))\n        #@show_query\n       end;\n\njulia&gt; @chain t(df_mem) begin\n        @group_by groups\n       # @window_frame(to = -3)\n        @mutate(avg = mean(percent))\n        #@show_query\n        @collect\n       end;\n\njulia&gt; @chain t(df_mem) begin\n        @group_by groups\n        @window_frame()\n        @mutate(avg = mean(percent))\n        #@show_query\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_order</code> \u2014 Macro.</p> <pre><code>   @window_order(sql_query, columns...)\n</code></pre> <p>Specify the order of rows for window functions within a SQL query.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by for the window function. Can include multiple columns for nested sorting. Prepend a column name with - for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n        @group_by groups\n        @window_frame(3)\n        @window_order(desc(percent))\n        @mutate(avg = mean(value))\n       #@show_query \n       end;\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":""},{"location":"examples/generated/UserGuide/Snowflake/","title":"Using Snowflake","text":"<p>Establishing a connection with the Snowflake SQL Rest API requires a OAuth token specific to the Role the user will use to query tables with.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/Snowflake/#connecting","title":"Connecting","text":"<p>Connection is established with the <code>connect</code> function as shown below. Connection requires 5 items as strings</p> <ul> <li>Account Identifier</li> <li>OAuth token</li> <li>Database Name</li> <li>Schema Name</li> <li>Compute Warehouse name</li> </ul> <p>Two things to note:</p> <ul> <li>Your OAuth Token may frequently expire, which may require you to rerun your connection line.</li> <li> <p>Since each time <code>db_table</code> runs, it runs a query to pull the metadata, you may choose to use run <code>db_table</code> and save the results, and use these results with<code>from_query()</code></p> <ul> <li>This will reduce the number of queries to your database</li> <li>Allow you to build a a SQL query and <code>@show_query</code> even if the OAuthtoken has expired. To <code>@collect</code> you will have to reconnect and rerun dbtable if your OAuth token has expired</li> </ul> </li> </ul> <pre><code>set_sql_mode(snowflake())\nac_id = \"string_id\"\ntoken = \"OAuth_token_string\"\ncon = connect(:snowflake, ac_id, token, \"DEMODB\", \"PUBLIC\", \"COMPUTE_WH\")\n# After connection is established, a you may begin querying.\nstable_table_metadata = db_table(con, \"MTCARS\")\n@chain from_query(stable_table_metadata) begin\n   @select(WT)\n   @mutate(TEST = WT *2)\n   #@aside @show_query _\n   @collect\nend\n</code></pre> <pre><code>32\u00d72 DataFrame\n Row \u2502 WT       TEST\n     \u2502 Float64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502   2.62     5.24\n   2 \u2502   2.875    5.75\n   3 \u2502   2.32     4.64\n   4 \u2502   3.215    6.43\n  \u22ee  \u2502    \u22ee        \u22ee\n  29 \u2502   3.17     6.34\n  30 \u2502   2.77     5.54\n  31 \u2502   3.57     7.14\n  32 \u2502   2.78     5.56\n         24 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/athena/","title":"Using Athena","text":"<p>To use the Athena AWS backend with TidierDB, set up and a small syntax difference are covered here.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#connecting","title":"Connecting","text":"<p>Connection is established through AWS.jl as shwon below.</p> <pre><code>using TidierDB, AWS\nset_sql_mode(athena())\n# Replace your credentials as needed below\naws_access_key_id = get(ENV,\"AWS_ACCESS_KEY_ID\",\"key\")\naws_secret_access_key = get(ENV, \"AWS_SECRET_ACCESS_KEY\",\"secret_key\")\naws_region = get(ENV,\"AWS_DEFAULT_REGION\",\"region\")\n\nconst AWS_GLOBAL_CONFIG = Ref{AWS.AWSConfig}()\ncreds = AWSCredentials(aws_access_key_id, aws_secret_access_key)\n\nAWS_GLOBAL_CONFIG[] = AWS.global_aws_config(region=aws_region, creds=creds)\n\ncatalog = \"AwsDataCatalog\"\nworkgroup = \"primary\"\ndb = \"demodb\"\nall_results = true\nresults_per_increment = 10\nout_loc = \"s3://location/\"\n\nathena_params = Dict(\n    \"ResultConfiguration\" =&gt; Dict(\n        \"OutputLocation\" =&gt; out_loc\n    ),\n    \"QueryExecutionContext\" =&gt; Dict(\n        \"Database\" =&gt; db,\n        \"Catalog\" =&gt; catalog\n    ),\n    \"Workgroup\" =&gt; workgroup\n)\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#db_table-differences","title":"<code>db_table</code> differences","text":"<p>There are two differences for <code>db_table</code> which are seen in the query below</p> <ol> <li>The table needs to be passed as a string in the format database.table, ie <code>\"demodb.table_name</code></li> <li><code>db_table</code> requires a third argument: the athena_params from above.</li> </ol> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#leveraging-from_query-with-athena-to-reduce-number-of-queries","title":"Leveraging <code>from_query</code> with Athena to reduce number of queries","text":"<p>Throughout TidierDB, each time <code>db_table</code> is called, it queries the databases to get the metadata. Consider how AWS Athena logs queries, a user may want to reduce the number of queries. This can be done saving the results of <code>db_table</code>, and then using from_query with those results for furthe queries as shown below.</p> <pre><code>mtcars = db_table(AWS_GLOBAL_CONFIG[], \"demodb.mtcars\", athena_params)\n@chain from_query(mtcars) begin\n    @filter(cyl &gt; 4)\n    @group_by(cyl)\n    @summarize(mpg = mean(mpg))\n   #@show_query\n    @collect\nend\n</code></pre> <pre><code>2\u00d72 DataFrame\n Row \u2502 cyl    mpg\n     \u2502 Int64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     6  19.7429\n   2 \u2502     8  15.1\n</code></pre> <p>I would like to acknowledge the work of Manu Francis and this blog post, which helped guide this process</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/databricks/","title":"Using Databricks","text":"<p>Establishing a connection with the Databricks SQL Rest API requires a token.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/databricks/#connecting","title":"Connecting","text":"<p>Connection is established with the <code>connect</code> function as shown below. Connection requires 5 items as strings</p> <ul> <li>Account Instance : how to find your instance</li> <li>OAuth token : how to generate your token</li> <li>Database Name</li> <li>Schema Name</li> <li>warehouse_id</li> </ul> <p>One thing to note, Since each time <code>db_table</code> runs, it runs a query to pull the metadata, you may choose to use run <code>db_table</code> and save the results, and use these results with <code>from_query()</code>. This will reduce the number of queries to your database and is illustrated below.</p> <pre><code>set_sql_mode(databricks())\ninstance_id = \"string_id\"\ntoken \"string_token\"\nwarehouse_id = \"e673cd4f387f964a\"\ncon = connect(:databricks, instance_id, token, \"DEMODB\", \"PUBLIC\", warehouse_id)\n# After connection is established, a you may begin querying.\nstable_table_metadata = db_table(con, \"mtcars\")\n@chain from_query(stable_table_metadata) begin\n   @select(wt)\n   @mutate(test = wt *2)\n   #@aside @show_query _\n   @collect\nend\n</code></pre> <pre><code>32\u00d72 DataFrame\n Row \u2502 wt       test\n     \u2502 Float64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502   2.62     5.24\n   2 \u2502   2.875    5.75\n   3 \u2502   2.32     4.64\n   4 \u2502   3.215    6.43\n  \u22ee  \u2502    \u22ee        \u22ee\n  29 \u2502   3.17     6.34\n  30 \u2502   2.77     5.54\n  31 \u2502   3.57     7.14\n  32 \u2502   2.78     5.56\n         24 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/","title":"Reproduce a duckplyr example","text":"<p>In this example, we will reproduce a DuckDB and duckplyr blog post example to demonstrate TidierDB's v0.5.0 capability.</p> <p>The (example by Hannes)[https://duckdb.org/2024/10/09/analyzing-open-government-data-with-duckplyr.html] that is being reproduced is exploring Open Data from the New Zealand government that is ~ 1GB.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/#set-up","title":"Set up","text":"<p>First we will set up the local duckdb database and pull in the metadata for the files. Notice we are not reading this data into memory, only the paths and and column, and table names. To follow along, copy the set up code below after downloading the data, but add the directory to the local data.</p> <pre><code>import TidierDB as DB\ndb = DB.connect(DB.duckdb())\n\ndir = \"/Downloads/nzcensus/\"\ndata   = dir * \"Data8277.csv\"\nage    = dir * \"DimenLookupAge8277.csv\"\narea   = dir * \"DimenLookupArea8277.csv\"\nethnic = dir * \"DimenLookupEthnic8277.csv\"\nsex    = dir * \"DimenLookupSex8277.csv\"\nyear   = dir * \"DimenLookupYear8277.csv\"\n\ndata = DB.db_table(db, data);\nage = DB.db_table(db, age);\narea = DB.db_table(db, area);\nethnic = DB.db_table(db, ethnic);\nsex = DB.db_table(db, sex);\nyear = DB.db_table(db, year);\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/#exploration","title":"Exploration","text":"<p>While this long chain could be broken up into multiple smaller chains, lets reproduce the duckplyr code from example and demonstrate how TidierDB also supports multiple joins after filtering, mutating, etc the joining tables. 6 different tables are being joined together through sequential inner joins.</p> <pre><code>@chain DB.t(data) begin\n  DB.@filter(str_detect(count, r\"^\\d+$\"))\n  DB.@mutate(count_ = \"TRY_CAST(count AS INT)\")\n  DB.@filter(count_ &gt; 0)\n  DB.@inner_join(\n    (@chain DB.t(age) begin\n    DB.@filter(str_detect(Description, r\"^\\d+ years$\"))\n    DB.@mutate(age_ = as_integer(str_remove(Code, \"years\"))) end),\n    Age = Code\n  )\n  DB.@inner_join((@chain DB.t(year) DB.@mutate(year_ = Description)), year = Code)\n  DB.@inner_join((@chain DB.t(area) begin\n    DB.@mutate(area_ = Description)\n    DB.@filter(!str_detect(area_, r\"^Total\"))\n  end)\n    , Area = Code)\n    DB.@inner_join((@chain DB.t(ethnic) begin\n      DB.@mutate(ethnic_ = Description)\n      DB.@filter(!str_detect( ethnic_, r\"^Total\",)) end), Ethnic = Code)\n  DB.@inner_join((@chain DB.t(sex) begin\n    DB.@mutate(sex_ = Description)\n    DB.@filter(!str_detect( sex_, r\"^Total\"))\n  end)\n   , Sex = Code)\n  DB.@inner_join((@chain DB.t(year) DB.@mutate(year_ = Description)), Year = Code)\n  @aside DB.@show_query _\n  DB.@create_view(joined_up)\nend;\n\n@chain DB.db_table(db, \"joined_up\") begin\n  DB.@filter begin\n    age_ &gt;= 20\n    age_ &lt;= 40\n    str_detect(area_, r\"^Auckland\")\n    year_ == \"2018\"\n    ethnic_ != \"European\"\n    end\n  DB.@group_by sex_\n  DB.@summarise(group_count = sum(count_))\n  DB.@collect\nend\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/#results","title":"Results","text":"<p>When we collect this to a local dataframe, we can see that the results match the duckplyr/DuckDB example.</p> <pre><code>2\u00d72 DataFrame\n Row \u2502 sex_    group_count\n     \u2502 String  Int128\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Female       398556\n   2 \u2502 Male         397326\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/ex_joining/","title":"Joining Tables","text":"<p>This page will illustrate how to join different tables in TidierDB. The examples will use the <code>mtcars</code> dataset and a synthetic dataset called <code>mt2</code> hosted on a personal MotherDuck instance. Examples will cover how to join tables with different schemas in different databases, and how to write queries on tables and then join them together, and how to do this by levaraging views.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#setup","title":"Setup","text":"<pre><code>using TidierDB\ndb = connect(duckdb(), \"md:\")\n\nmtcars = db_table(db, \"my_db.mtcars\")\nmt2 = db_table(db, \"ducks_db.mt2\")\n</code></pre>"},{"location":"examples/generated/UserGuide/ex_joining/#wrangle-tables-and-self-join","title":"Wrangle tables and self join","text":"<pre><code>query = @chain t(mtcars) begin\n    @group_by cyl\n    @summarize begin\n        across(mpg, (mean, minimum, maximum))\n        num_cars = n()\n        end\n    @mutate begin\n        efficiency = case_when(\n            mpg_mean &gt;= 25, \"High\",\n            mpg_mean &gt;= 15, \"Moderate\",\n            \"Low\" )\n      end\nend;\n\nquery2 = @chain t(mtcars) @filter(mpg&gt;20) @mutate(mpg = mpg *4);\n\n@chain t(query) begin\n    @left_join(t(query2), cyl, cyl)\n    @group_by(efficiency)\n    @summarize(avg_mean = mean(mpg))\n    @mutate(mean = avg_mean / 4 )\n    @aside @show_query _\n    @collect\nend\n</code></pre> <pre><code>2\u00d73 DataFrame\n Row \u2502 efficiency  avg_mean  mean\n     \u2502 String      Float64   Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 High        106.655   26.6636\n   2 \u2502 Moderate     84.5333  21.1333\n</code></pre>"},{"location":"examples/generated/UserGuide/ex_joining/#different-schemas","title":"Different schemas","text":"<p>To connect to a table in a different schema, prefix it with a dot. For example, \"schemaname.tablename\". In this query, we are also filtering out cars that contain \"M\" in the name from the <code>mt2</code> table before joining.</p> <pre><code>other_db = @chain db_table(db, \"ducks_db.mt2\") @filter(!str_detect(car, \"M\"))\n@chain t(mtcars) begin\n    @left_join(t(other_db), car, model)\n    @select(car, model)\n    @head(5)\n    @collect\nend\n</code></pre> <pre><code>5\u00d72 DataFrame\n Row \u2502 car                model\n     \u2502 String             String\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Datsun 710         Datsun 710\n   2 \u2502 Hornet 4 Drive     Hornet 4 Drive\n   3 \u2502 Hornet Sportabout  Hornet Sportabout\n   4 \u2502 Valiant            Valiant\n   5 \u2502 Duster 360         Duster 360\n</code></pre> <p>To join directly to the table, you can use the <code>@left_join</code> macro with the table name as a string.</p> <pre><code>@chain t(mtcars) begin\n    @left_join(\"ducks_db.mt2\", car, model)\n    @select(car, model)\n    @head(5)\n    @collect\nend\n</code></pre> <pre><code>5\u00d72 DataFrame\n Row \u2502 car                model\n     \u2502 String             String\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4          Mazda RX4\n   2 \u2502 Mazda RX4 Wag      Mazda RX4 Wag\n   3 \u2502 Datsun 710         Datsun 710\n   4 \u2502 Hornet 4 Drive     Hornet 4 Drive\n   5 \u2502 Hornet Sportabout  Hornet Sportabout\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#using-a-view","title":"Using a View","text":"<p>You can also use <code>@create_view</code> to create views and then join them. This is an alternate reuse complex queries.</p> <pre><code># notice, this is not begin saved, bc a view is created in the database at the end of the chain\n@chain t(mtcars) begin\n       @group_by cyl\n       @summarize begin\n            across(mpg, (mean, minimum, maximum))\n            num_cars = n()\n        end\n       @mutate begin\n           efficiency = case_when(\n           mpg_mean &gt;= 25, \"High\",\n           mpg_mean &gt;= 15, \"Moderate\",\n              \"Low\" )\n        end\n       #create a view in the database\n       @create_view(viewer)\nend;\n\n# access the view like as if it was any other table\n@chain db_table(db, \"viewer\") begin\n    @left_join(t(query2), cyl, cyl)\n    @group_by(efficiency)\n    @summarize(avg_mean = mean(mpg))\n    @mutate(mean = avg_mean / 4 )\n    @collect\nend\n</code></pre> <pre><code>2\u00d73 DataFrame\n Row \u2502 efficiency  avg_mean  mean\n     \u2502 String      Float64   Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 High        106.655   26.6636\n   2 \u2502 Moderate     84.5333  21.1333\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/from_queryex/","title":"Reusing a Query (and Views)","text":"<p>While using TidierDB, you may need to generate part of a query and reuse it multiple times. There are two ways to do this</p> <ol> <li><code>from_query(query)</code> or <code>t(query)</code></li> <li><code>@create_view(name)</code></li> </ol> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/from_queryex/#setup","title":"Setup","text":"<pre><code>import TidierDB as DB\ncon = DB.connect(duckdb())\nmtcars_path = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\nmtcars = DB.db_table(con, mtcars_path)\n</code></pre> <p>Start a query to analyze fuel efficiency by number of cylinders. However, to further build on this query later, end the chain without using <code>@show_query</code> or <code>@collect</code></p> <pre><code>query = DB.@chain DB.t(query) begin\n    DB.@group_by cyl\n    DB.@summarize begin\n        across(mpg, (mean, minimum, maximum))\n        num_cars = n()\n        end\n    DB.@mutate begin\n        efficiency = case_when(\n            mpg_mean &gt;= 25, \"High\",\n            mpg_mean &gt;= 15, \"Moderate\",\n            \"Low\" )\n       end\nend;\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/from_queryex/#from_query-or-tquery","title":"<code>from_query()</code> or <code>t(query)</code>","text":"<p>Now, <code>from_query</code>, or <code>t()</code> a convienece wrapper, will allow you to reuse the query to calculate the average horsepower for each efficiency category</p> <pre><code>DB.@chain DB.t(query) begin\n   DB.@left_join(\"mtcars2\", cyl, cyl)\n   DB.@group_by(efficiency)\n   DB.@summarize(avg_hp = mean(hp))\n   DB.@collect\nend\n</code></pre> <pre><code>2\u00d72 DataFrame\n Row \u2502 efficiency  avg_hp\n     \u2502 String?     Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Moderate    180.238\n   2 \u2502 High         82.6364\n</code></pre> <p>Reuse the query again to find the car with the highest MPG for each cylinder category</p> <pre><code>DB.@chain DB.t(mtcars)  begin\n   DB.@left_join(\"mtcars2\", cyl, cyl)\n   DB.@group_by cyl\n   DB.@slice_max(mpg)\n   DB.@select model cyl mpg\n   DB.@collect\nend\n</code></pre> <pre><code>3\u00d73 DataFrame\n Row \u2502 model             cyl     mpg\n     \u2502 String?           Int64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Pontiac Firebird       8      19.2\n   2 \u2502 Toyota Corolla         4      33.9\n   3 \u2502 Hornet 4 Drive         6      21.4\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/from_queryex/#create_view","title":"@create_view","text":"<p>This can also be done with <code>@create_view</code>.</p> <pre><code>query2 = @chain t(mtcars) @filter(mpg&gt;20) @mutate(mpg = mpg *4);\nDB.@chain  DB.db_table(db, \"mtcars\") begin\n           DB.@group_by cyl\n           DB.@summarize begin\n               across(mpg, (mean, minimum, maximum))\n               num_cars = n()\n               end\n           DB.@mutate begin\n               efficiency = case_when(\n                   mpg_mean &gt;= 25, \"High\",\n                   mpg_mean &gt;= 15, \"Moderate\",\n                   \"Low\" )\n             end\n       DB.@create_view(viewer)\n       end;\n\n\nDB.@chain DB.db_table(db, \"viewer\") begin\n           DB.@left_join(DB.t(query2), cyl, cyl)\n           DB.@group_by(efficiency)\n           DB.@summarize(avg_mean = mean(mpg))\n           DB.@mutate(mean = avg_mean / 4 )\n           @aside DB.@show_query _\n           DB.@collect\nend\n2\u00d73 DataFrame\n Row \u2502 efficiency  avg_mean  mean\n     \u2502 String      Float64   Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 High        106.655   26.6636\n   2 \u2502 Moderate     84.5333  21.1333\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/from_queryex/#preview-or-save-an-intermediate-table","title":"Preview or save an intermediate table","text":"<p>While querying a dataset, you may wish to see an intermediate table, or even save it. You can use <code>@aside</code> and <code>from_query(_)</code>, illustrated below, to do just that. While we opted to print the results in this simple example below, we could have saved them by using <code>name = DB.@chain...</code></p> <pre><code>import ClickHouse;\nconn = conn = DB.connect(DB.clickhouse(); host=\"localhost\", port=19000, database=\"default\", user=\"default\", password=\"\")\npath = \"https://huggingface.co/datasets/maharshipandya/spotify-tracks-dataset/resolve/refs%2Fconvert%2Fparquet/default/train/0000.parquet\"\nDB.@chain DB.db_table(conn, path) begin\n   DB.@count(cyl)\n   @aside println(DB.@chain DB.from_query(_) DB.@head(5) DB.@collect)\n   DB.@arrange(desc(count))\n   DB.@collect\nend\n</code></pre> <pre><code>5\u00d72 DataFrame\n Row \u2502 artists  count\n     \u2502 String?  UInt64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 missing       1\n   2 \u2502 Wizo          3\n   3 \u2502 MAGIC!        3\n   4 \u2502 Macaco        1\n   5 \u2502 SOYOU         1\n31438\u00d72 DataFrame\n   Row \u2502 artists          count\n       \u2502 String?          UInt64\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     1 \u2502 The Beatles         279\n     2 \u2502 George Jones        271\n     3 \u2502 Stevie Wonder       236\n     4 \u2502 Linkin Park         224\n     5 \u2502 Ella Fitzgerald     222\n     6 \u2502 Prateek Kuhad       217\n     7 \u2502 Feid                202\n   \u22ee   \u2502        \u22ee           \u22ee\n 31432 \u2502 Leonard               1\n 31433 \u2502 marcos g              1\n 31434 \u2502 BLVKSHP               1\n 31435 \u2502 Memtrix               1\n 31436 \u2502 SOYOU                 1\n 31437 \u2502 Macaco                1\n 31438 \u2502 missing               1\n               31424 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/","title":"Writing Functions with TidierDB Chains","text":"<p>On this page, we'll briefly explore how to use TidierDB macros and <code>$</code> witth <code>@eval</code> to bulid a function</p> <p>For a more indepth explanation, please check out the TidierData page on interpolation</p> <pre><code>using TidierDB, DataFrames;\n\ndb = connect(duckdb());\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\ncopy_to(db, df, \"dfm\");\ndf_mem = db_table(db, \"dfm\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#interpolation","title":"Interpolation","text":"<p>Variables are interpoated using <code>@eval</code> and <code>$</code>. Place <code>@eval</code> before you begin the chain or call a TidierDb macro Why Use @eval? In Julia, macros like @filter are expanded at parse time, before runtime variables like vals are available. By using @eval, we force the expression to be evaluated at runtime, allowing us to interpolate the variable into the macro.</p> <pre><code>num = [3];\ncolumn = :id;\n@eval @chain t(df_mem) begin\n        @filter(value in $num)\n        @select($column)\n        @collect\n    end\n</code></pre> 2\u00d71 DataFrame RowidString1AC2AH <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#function-set-up","title":"Function set up","text":"<p>Begin by defining your function as your normally would, but before <code>@chain</code> you need to use <code>@eval</code>. For the variables to be interpolated in need to be started with <code>$</code></p> <pre><code>function test(vals, cols)\n    @eval @chain t(df_mem) begin\n        @filter(value in $vals)\n        @select($cols)\n        @collect\n    end\nend;\n\nvals = [1,  2,  3, 3];\ntest(vals, [:groups, :value, :percent])\n</code></pre> 6\u00d73 DataFrame RowgroupsvaluepercentStringInt64Float641bb10.12aa10.63aa20.24bb20.75bb30.36aa30.8 <p>Now with a new variable</p> <pre><code>other_vals = [1];\ncols = [:value, :percent];\ntest(other_vals, cols)\n</code></pre> 2\u00d72 DataFrame RowvaluepercentInt64Float64110.1210.6 <p>Defineing a new function</p> <pre><code>function gs(groups, aggs, new_name, threshold)\n    @eval @chain t(df_mem) begin\n        @group_by($groups)\n        @summarize($new_name = mean($aggs))\n        @filter($new_name &gt; $threshold)\n        @collect\n    end\nend;\n\ngs(:groups, :percent, :mean_percent, .5)\n</code></pre> 1\u00d72 DataFrame Rowgroupsmean_percentStringFloat641aa0.6 <p>Change the column and threshold</p> <pre><code>gs(:groups, :value, :mean_value, 2)\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_valueStringFloat641bb3.02aa3.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#write-pipeline-function-to-use-inside-of-chains","title":"Write pipeline function to use inside of chains","text":"<p>Lets say there is a particular sequence of macros that you want repeatedly use. Wrap this series into a function that accepts a <code>t(query</code> as its first argument and returns a <code>SQLquery</code> and you can easily resuse it.</p> <pre><code>function moving_aggs(table, start, stop, group, order, col)\n    qry = @eval @chain $table begin\n        @group_by $group\n        @window_frame $start $stop\n        @window_order $order\n        @mutate(across($col, (minimum, maximum, mean)))\n    end\n    return qry\nend;\n\n@chain t(df_mem) begin\n    moving_aggs(-2, 1, :groups, :percent, :value)\n    @filter value_mean &gt; 2.75\n    @aside @show_query _\n    @collect\nend\n</code></pre> 6\u00d77 DataFrame Rowidgroupsvaluepercentvalue_minimumvalue_maximumvalue_meanStringStringInt64Float64Int64Int64Float641ABaa20.2243.02AHaa30.8153.253AJaa51.0153.04ACbb30.3153.05AGbb20.7253.56AIbb40.9253.66667 <p>Filtering before the window functions</p> <pre><code>@chain t(df_mem) begin\n    @filter(value &gt;=2 )\n    moving_aggs(-1, 1, :groups, :percent, :value)\n    @aside @show_query _\n    @collect\nend\n</code></pre> 8\u00d77 DataFrame Rowidgroupsvaluepercentvalue_minimumvalue_maximumvalue_meanStringStringInt64Float64Int64Int64Float641ABaa20.2243.02ADaa40.4243.03AHaa30.8354.04AJaa51.0354.05ACbb30.3354.06AEbb50.5253.333337AGbb20.7253.666678AIbb40.9243.0 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/getting_started/","title":"Getting Started","text":"<p>To use TidierDB.jl, you will have to set up a connection. TidierDB.jl gives you access to duckdb via <code>duckdb_open</code> and <code>duckdb_connect</code>. However, to use MySql, ClickHouse, MSSQL, Postgres, or SQLite, you will have to load those packages in first.</p> <p>If you plan to use TidierDB.jl with TidierData.jl or Tidier.jl, it is most convenenient to load the packages as follows:</p> <pre><code>using TidierData\nimport TidierDB as DB\n</code></pre> <p>Alternatively, <code>using Tidier</code> will import TidierDB in the above manner for you, where TidierDB functions and macros will be available as <code>DB.@mutate()</code> and so on, and the TidierData equivalent would be <code>@mutate()</code>.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#connecting","title":"Connecting","text":"<p>To connect to a database, you can uset the <code>connect</code> function  as shown below, or establish your own connection through the respecitve libraries.</p> <p>For example Connecting to MySQL</p> <pre><code>conn = DB.connect(DB.mysql(); host=\"localhost\", user=\"root\", password=\"password\", db=\"mydb\")\n</code></pre> <p>versus connecting to DuckDB</p> <pre><code>conn = DB.connect(DB.duckdb())\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#connect-to-a-local-database-file","title":"Connect to a local database file","text":"<p>You can also connect to an existing database by passing the database file path as a string.</p> <pre><code>db = DB.connect(DB.duckdb(), \"mydb.duckdb\")\n</code></pre> <p>You can also establish any DuckDB connection through an alternate method that you prefer, and use that as your connection as well.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#package-extensions","title":"Package Extensions","text":"<p>The following backends utilize package extensions. To use one of backends listed below, you will need to write <code>using Library</code></p> <ul> <li>ClickHouse: <code>import ClickHouse</code></li> <li>MySQL and MariaDB: <code>using MySQL</code></li> <li>MSSQL: <code>using ODBC</code></li> <li>Postgres: <code>using LibPQ</code></li> <li>SQLite: <code>using SQLite</code></li> <li>Athena: <code>using AWS</code></li> <li>Oracle: <code>using ODBC</code></li> <li>Google BigQuery: <code>using GoogleCloud</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#db_table","title":"<code>db_table</code>","text":"<p>What does <code>db_table</code> do?</p> <p><code>db_table</code> starts the underlying SQL query struct, in addition to pulling the table metadata and storing it there. Storing metadata is what enables a lazy interface that also supports tidy selection.</p> <ul> <li><code>db_table</code> has two required arguments: <code>connection</code> and <code>table</code></li> <li> <p><code>table</code> can be a table name on a database or a path/url to file to read.  When passing <code>db_table</code> a path or url, the table is not copied into memory.</p> <ul> <li>Of note, <code>db_table</code> only support direct file paths to a table. It does not support database file paths such as <code>dbname.duckdb</code> or <code>dbname.sqlite</code>. Such files must be used with <code>connect</code> first.</li> <li>With DuckDB and ClickHouse, if you have a folder of multiple files to read, you can use <code>*</code> read in all files matching the pattern.</li> <li>For example, the below would read all files that end in <code>.csv</code> in the given folder.</li> </ul> </li> </ul> <pre><code>db_table(db, \"folder/path/*.csv\")\n</code></pre> <p><code>db_table</code> also supports iceberg, delta, and S3 file paths via DuckDB.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#minimizing-compute-costs","title":"Minimizing Compute Costs","text":"<p>If you are working with a backend where compute cost is important, it will be important to minimize using <code>db_table</code> as this will requery for metadata each time. Compute costs are relevant to backends such as AWS, databricks and Snowflake.</p> <p>To do this, save the results of <code>db_table</code> and use them with <code>t</code>. Using <code>t</code> pulls the relevant information (metadata, con, etc) from the mutable SQLquery struct, allowing you to repeatedly query and collect the table without requerying for the metadata each time</p> <p>!Tip: <code>t()</code> is an alias for <code>from_query</code> This means after saving the results of <code>db_table</code>, use <code>t(table)</code> to refer to the table or prior query</p> <pre><code>table = DB.db_table(con, \"path\")\n@chain DB.t(table) begin\n    ## data wrangling here\nend\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/ibis_comp/","title":"TidierDB.jl vs Ibis","text":""},{"location":"examples/generated/UserGuide/ibis_comp/#comparing-tidierdb-vs-ibis","title":"Comparing TidierDB vs Ibis","text":"<p>TidierDB is a reimplementation of dbplyr from R, so the syntax is remarkably similar. But how does TidierDB compare to Python's Ibis? This page will perform a similar comparison to the Ibis Documentation comparing Ibis and dplyr</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#set-up","title":"Set up","text":"<p>Ibis</p> <pre><code>import ibis\nimport ibis.selectors as s # allows for different styles of column selection\nfrom ibis import _ # eliminates need to type table name before each column vs typing cols as strings\nibis.options.interactive = True # automatically collects first 10 rows of table\n\ncon = ibis.connect(\"duckdb://\")\n</code></pre> <p>TidierDB</p> <pre><code>using TidierDB\ndb = connect(duckdb())\n</code></pre> <p>Of note, TidierDB does not yet have an \"interactive mode\" so each example result will be collected.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#loading-data","title":"Loading Data","text":"<p>With Ibis, there are specific functions to read in different file types</p> <pre><code>mtcars = con.read_csv(\"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\")\n</code></pre> <p>In TidierDB, there is only <code>db_table</code>, which determines the file type and generates the syntax appropriate for the backend in use.</p> <pre><code>mtcars = db_table(db, \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#previewing-the-data","title":"Previewing the data","text":"<p>TidierDB and Ibis use <code>head</code>/<code>@head</code> to preview the first rows of a dataset.</p> <p>Ibis</p> <pre><code>mtcars.head(6)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model             \u2503 mpg     \u2503 cyl   \u2503 disp    \u2503 hp    \u2503 drat    \u2503 wt      \u2503 qsec    \u2503 vs    \u2503 am    \u2503 gear  \u2503 carb  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 float64 \u2502 int64 \u2502 float64 \u2502 int64 \u2502 float64 \u2502 float64 \u2502 float64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502    21.0 \u2502     6 \u2502   160.0 \u2502   110 \u2502    3.90 \u2502   2.620 \u2502   16.46 \u2502     0 \u2502     1 \u2502     4 \u2502     4 \u2502\n\u2502 Mazda RX4 Wag     \u2502    21.0 \u2502     6 \u2502   160.0 \u2502   110 \u2502    3.90 \u2502   2.875 \u2502   17.02 \u2502     0 \u2502     1 \u2502     4 \u2502     4 \u2502\n\u2502 Datsun 710        \u2502    22.8 \u2502     4 \u2502   108.0 \u2502    93 \u2502    3.85 \u2502   2.320 \u2502   18.61 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Hornet 4 Drive    \u2502    21.4 \u2502     6 \u2502   258.0 \u2502   110 \u2502    3.08 \u2502   3.215 \u2502   19.44 \u2502     1 \u2502     0 \u2502     3 \u2502     1 \u2502\n\u2502 Hornet Sportabout \u2502    18.7 \u2502     8 \u2502   360.0 \u2502   175 \u2502    3.15 \u2502   3.440 \u2502   17.02 \u2502     0 \u2502     0 \u2502     3 \u2502     2 \u2502\n\u2502 Valiant           \u2502    18.1 \u2502     6 \u2502   225.0 \u2502   105 \u2502    2.76 \u2502   3.460 \u2502   20.22 \u2502     1 \u2502     0 \u2502     3 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain t(mtcars) @head(6) @collect\n</code></pre> <pre><code>6\u00d712 DataFrame\n Row \u2502 model              mpg       cyl     disp      hp      drat      wt        qsec      vs      am      gear    carb\n     \u2502 String?            Float64?  Int64?  Float64?  Int64?  Float64?  Float64?  Float64?  Int64?  Int64?  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4              21.0       6     160.0     110      3.9      2.62      16.46       0       1       4       4\n   2 \u2502 Mazda RX4 Wag          21.0       6     160.0     110      3.9      2.875     17.02       0       1       4       4\n   3 \u2502 Datsun 710             22.8       4     108.0      93      3.85     2.32      18.61       1       1       4       1\n   4 \u2502 Hornet 4 Drive         21.4       6     258.0     110      3.08     3.215     19.44       1       0       3       1\n   5 \u2502 Hornet Sportabout      18.7       8     360.0     175      3.15     3.44      17.02       0       0       3       2\n   6 \u2502 Valiant                18.1       6     225.0     105      2.76     3.46      20.22       1       0       3       1\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#filtering","title":"Filtering","text":"<p>The example below demonstrates how to filter using multiple criteria in both Ibis and TidierData Ibis</p> <pre><code>mtcars.filter(((_.mpg &gt; 22) &amp; (_.drat &gt; 4) | (_.hp == 113)))\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model          \u2503 mpg     \u2503 cyl   \u2503 disp    \u2503 hp    \u2503 drat    \u2503 wt      \u2503 qsec    \u2503 vs    \u2503 am    \u2503 gear  \u2503 carb  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string         \u2502 float64 \u2502 int64 \u2502 float64 \u2502 int64 \u2502 float64 \u2502 float64 \u2502 float64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Lotus Europa   \u2502    30.4 \u2502     4 \u2502    95.1 \u2502   113 \u2502    3.77 \u2502   1.513 \u2502   16.90 \u2502     1 \u2502     1 \u2502     5 \u2502     2 \u2502\n\u2502 Fiat 128       \u2502    32.4 \u2502     4 \u2502    78.7 \u2502    66 \u2502    4.08 \u2502   2.200 \u2502   19.47 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Honda Civic    \u2502    30.4 \u2502     4 \u2502    75.7 \u2502    52 \u2502    4.93 \u2502   1.615 \u2502   18.52 \u2502     1 \u2502     1 \u2502     4 \u2502     2 \u2502\n\u2502 Toyota Corolla \u2502    33.9 \u2502     4 \u2502    71.1 \u2502    65 \u2502    4.22 \u2502   1.835 \u2502   19.90 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Fiat X1-9      \u2502    27.3 \u2502     4 \u2502    79.0 \u2502    66 \u2502    4.08 \u2502   1.935 \u2502   18.90 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Porsche 914-2  \u2502    26.0 \u2502     4 \u2502   120.3 \u2502    91 \u2502    4.43 \u2502   2.140 \u2502   16.70 \u2502     0 \u2502     1 \u2502     5 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain t(mtcars) begin\n       @filter((mpg &gt; 22 &amp;&amp; drat &gt; 4) || hp == 113)\n       @collect\nend\n</code></pre> <pre><code>6\u00d712 DataFrame\n Row \u2502 model           mpg       cyl     disp      hp      drat      wt        qsec      vs      am      gear    carb\n     \u2502 String?         Float64?  Int64?  Float64?  Int64?  Float64?  Float64?  Float64?  Int64?  Int64?  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Lotus Europa        30.4       4      95.1     113      3.77     1.513     16.9        1       1       5       2\n   2 \u2502 Fiat 128            32.4       4      78.7      66      4.08     2.2       19.47       1       1       4       1\n   3 \u2502 Honda Civic         30.4       4      75.7      52      4.93     1.615     18.52       1       1       4       2\n   4 \u2502 Toyota Corolla      33.9       4      71.1      65      4.22     1.835     19.9        1       1       4       1\n   5 \u2502 Fiat X1-9           27.3       4      79.0      66      4.08     1.935     18.9        1       1       4       1\n   6 \u2502 Porsche 914-2       26.0       4     120.3      91      4.43     2.14      16.7        0       1       5       2\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#creating-new-columns","title":"Creating new columns","text":"<p>Both TidierDB and Ibis use <code>mutate</code>/<code>@mutate</code> to add new columns</p> <p>Ibis</p> <pre><code>(\n   mtcars\n        .mutate(kpg = _.mpg * 1.61)\n        .select(\"model\", \"kpg\")\n)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model             \u2503 kpg     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502  33.810 \u2502\n\u2502 Mazda RX4 Wag     \u2502  33.810 \u2502\n\u2502 Datsun 710        \u2502  36.708 \u2502\n\u2502 Hornet 4 Drive    \u2502  34.454 \u2502\n\u2502 Hornet Sportabout \u2502  30.107 \u2502\n\u2502 Valiant           \u2502  29.141 \u2502\n\u2502 Duster 360        \u2502  23.023 \u2502\n\u2502 Merc 240D         \u2502  39.284 \u2502\n\u2502 Merc 230          \u2502  36.708 \u2502\n\u2502 Merc 280          \u2502  30.912 \u2502\n\u2502 \u2026                 \u2502       \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain t(mtcars) begin\n       @mutate(kpg = mpg * 1.61)\n       @select(model, kpg)\n       @collect\nend\n</code></pre> <pre><code>32\u00d72 DataFrame\n Row \u2502 model              kpg\n     \u2502 String?            Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4            33.81\n   2 \u2502 Mazda RX4 Wag        33.81\n   3 \u2502 Datsun 710           36.708\n   4 \u2502 Hornet 4 Drive       34.454\n   5 \u2502 Hornet Sportabout    30.107\n   6 \u2502 Valiant              29.141\n  \u22ee  \u2502         \u22ee             \u22ee\n  27 \u2502 Porsche 914-2        41.86\n  28 \u2502 Lotus Europa         48.944\n  29 \u2502 Ford Pantera L       25.438\n  30 \u2502 Ferrari Dino         31.717\n  31 \u2502 Maserati Bora        24.15\n  32 \u2502 Volvo 142E           34.454\n                    20 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#sorting-columns","title":"Sorting columns","text":"<p>Ibis uses <code>order_by</code> similar to SQLs <code>ORDER BY</code></p> <p>Ibis</p> <pre><code>mtcars.order_by(_.mpg)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model               \u2503 mpg     \u2503 cyl   \u2503 disp    \u2503 hp    \u2503 drat    \u2503 wt      \u2503 qsec    \u2503 vs    \u2503 am    \u2503 gear  \u2503 carb  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string              \u2502 float64 \u2502 int64 \u2502 float64 \u2502 int64 \u2502 float64 \u2502 float64 \u2502 float64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Cadillac Fleetwood  \u2502    10.4 \u2502     8 \u2502   472.0 \u2502   205 \u2502    2.93 \u2502   5.250 \u2502   17.98 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Lincoln Continental \u2502    10.4 \u2502     8 \u2502   460.0 \u2502   215 \u2502    3.00 \u2502   5.424 \u2502   17.82 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Camaro Z28          \u2502    13.3 \u2502     8 \u2502   350.0 \u2502   245 \u2502    3.73 \u2502   3.840 \u2502   15.41 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Duster 360          \u2502    14.3 \u2502     8 \u2502   360.0 \u2502   245 \u2502    3.21 \u2502   3.570 \u2502   15.84 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Chrysler Imperial   \u2502    14.7 \u2502     8 \u2502   440.0 \u2502   230 \u2502    3.23 \u2502   5.345 \u2502   17.42 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Maserati Bora       \u2502    15.0 \u2502     8 \u2502   301.0 \u2502   335 \u2502    3.54 \u2502   3.570 \u2502   14.60 \u2502     0 \u2502     1 \u2502     5 \u2502     8 \u2502\n\u2502 Merc 450SLC         \u2502    15.2 \u2502     8 \u2502   275.8 \u2502   180 \u2502    3.07 \u2502   3.780 \u2502   18.00 \u2502     0 \u2502     0 \u2502     3 \u2502     3 \u2502\n\u2502 AMC Javelin         \u2502    15.2 \u2502     8 \u2502   304.0 \u2502   150 \u2502    3.15 \u2502   3.435 \u2502   17.30 \u2502     0 \u2502     0 \u2502     3 \u2502     2 \u2502\n\u2502 Dodge Challenger    \u2502    15.5 \u2502     8 \u2502   318.0 \u2502   150 \u2502    2.76 \u2502   3.520 \u2502   16.87 \u2502     0 \u2502     0 \u2502     3 \u2502     2 \u2502\n\u2502 Ford Pantera L      \u2502    15.8 \u2502     8 \u2502   351.0 \u2502   264 \u2502    4.22 \u2502   3.170 \u2502   14.50 \u2502     0 \u2502     1 \u2502     5 \u2502     4 \u2502\n\u2502 \u2026                   \u2502       \u2026 \u2502     \u2026 \u2502       \u2026 \u2502     \u2026 \u2502       \u2026 \u2502       \u2026 \u2502       \u2026 \u2502     \u2026 \u2502     \u2026 \u2502     \u2026 \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>While TidierDB uses <code>@arrange</code> like TidierData.jl</p> <p>TidierDB</p> <pre><code>@chain t(mtcars) @arrange(mpg) @collect\n</code></pre> <pre><code>32\u00d712 DataFrame\n Row \u2502 model                mpg       cyl     disp      hp      drat      wt        qsec      vs      am      gear    carb\n     \u2502 String?              Float64?  Int64?  Float64?  Int64?  Float64?  Float64?  Float64?  Int64?  Int64?  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Cadillac Fleetwood       10.4       8     472.0     205      2.93     5.25      17.98       0       0       3       4\n   2 \u2502 Lincoln Continental      10.4       8     460.0     215      3.0      5.424     17.82       0       0       3       4\n   3 \u2502 Camaro Z28               13.3       8     350.0     245      3.73     3.84      15.41       0       0       3       4\n   4 \u2502 Duster 360               14.3       8     360.0     245      3.21     3.57      15.84       0       0       3       4\n   5 \u2502 Chrysler Imperial        14.7       8     440.0     230      3.23     5.345     17.42       0       0       3       4\n   6 \u2502 Maserati Bora            15.0       8     301.0     335      3.54     3.57      14.6        0       1       5       8\n  \u22ee  \u2502          \u22ee              \u22ee        \u22ee        \u22ee        \u22ee        \u22ee         \u22ee         \u22ee        \u22ee       \u22ee       \u22ee       \u22ee\n  27 \u2502 Porsche 914-2            26.0       4     120.3      91      4.43     2.14      16.7        0       1       5       2\n  28 \u2502 Fiat X1-9                27.3       4      79.0      66      4.08     1.935     18.9        1       1       4       1\n  29 \u2502 Honda Civic              30.4       4      75.7      52      4.93     1.615     18.52       1       1       4       2\n  30 \u2502 Lotus Europa             30.4       4      95.1     113      3.77     1.513     16.9        1       1       5       2\n  31 \u2502 Fiat 128                 32.4       4      78.7      66      4.08     2.2       19.47       1       1       4       1\n  32 \u2502 Toyota Corolla           33.9       4      71.1      65      4.22     1.835     19.9        1       1       4       1\n                                                                                                              20 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#selecting-columns","title":"Selecting columns","text":"<p>In Ibis, columns must be prefixed with the table name, or in this case <code>_</code>, or they can be given as a string. Finally to using helper functions like <code>startswith</code> requires importing selectors as above.</p> <p>Ibis</p> <pre><code>mtcars.select(s.startswith(\"m\"), \"drat\", _.wt)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model             \u2503 mpg     \u2503 drat    \u2503 wt      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 float64 \u2502 float64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502    21.0 \u2502    3.90 \u2502   2.620 \u2502\n\u2502 Mazda RX4 Wag     \u2502    21.0 \u2502    3.90 \u2502   2.875 \u2502\n\u2502 Datsun 710        \u2502    22.8 \u2502    3.85 \u2502   2.320 \u2502\n\u2502 Hornet 4 Drive    \u2502    21.4 \u2502    3.08 \u2502   3.215 \u2502\n\u2502 Hornet Sportabout \u2502    18.7 \u2502    3.15 \u2502   3.440 \u2502\n\u2502 Valiant           \u2502    18.1 \u2502    2.76 \u2502   3.460 \u2502\n\u2502 Duster 360        \u2502    14.3 \u2502    3.21 \u2502   3.570 \u2502\n\u2502 Merc 240D         \u2502    24.4 \u2502    3.69 \u2502   3.190 \u2502\n\u2502 Merc 230          \u2502    22.8 \u2502    3.92 \u2502   3.150 \u2502\n\u2502 Merc 280          \u2502    19.2 \u2502    3.92 \u2502   3.440 \u2502\n\u2502 \u2026                 \u2502       \u2026 \u2502       \u2026 \u2502       \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB does not require names to be prefixed and, like TidierData, tidy column selection with <code>starts_with</code>, <code>ends_with</code>, and <code>contains</code> is supported at base. TidierDB also supports providing column names as strings, although this would only be needed in the setting of renaming a column with a space in it.</p> <p>TidierDB</p> <pre><code>@chain t(mtcars) @select(starts_with(\"m\"), \"drat\", wt) @collect\n</code></pre> <pre><code>32\u00d74 DataFrame\n Row \u2502 model              mpg       drat      wt\n     \u2502 String?            Float64?  Float64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4              21.0      3.9      2.62\n   2 \u2502 Mazda RX4 Wag          21.0      3.9      2.875\n   3 \u2502 Datsun 710             22.8      3.85     2.32\n   4 \u2502 Hornet 4 Drive         21.4      3.08     3.215\n   5 \u2502 Hornet Sportabout      18.7      3.15     3.44\n   6 \u2502 Valiant                18.1      2.76     3.46\n  \u22ee  \u2502         \u22ee             \u22ee         \u22ee         \u22ee\n  27 \u2502 Porsche 914-2          26.0      4.43     2.14\n  28 \u2502 Lotus Europa           30.4      3.77     1.513\n  29 \u2502 Ford Pantera L         15.8      4.22     3.17\n  30 \u2502 Ferrari Dino           19.7      3.62     2.77\n  31 \u2502 Maserati Bora          15.0      3.54     3.57\n  32 \u2502 Volvo 142E             21.4      4.11     2.78\n                                        20 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#multi-step-queries-and-summarizing","title":"Multi step queries and summarizing","text":"<p>Aggregating data is done with <code>aggregate</code> in Ibis and <code>@summarize</code> in TidierDB. To group data, both utilze <code>group_by</code>/<code>@group_by</code> Ibis</p> <pre><code>mtcars.group_by(._cyl).aggregate(\n    total_hp=_.hp.sum(),\n    avg_hp=_.hp.mean()\n).filter(_.total_hp &lt; 1000)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 cyl   \u2503 total_hp \u2503 avg_hp     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64    \u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     6 \u2502      856 \u2502 122.285714 \u2502\n\u2502     4 \u2502      909 \u2502  82.636364 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In TidierDB, <code>@filter</code> will automatically determine whether the criteria belong in a <code>WHERE</code> or <code>HAVING</code> SQL clause.</p> <p>TidierDB</p> <pre><code>@chain t(mtcars) begin\n    @group_by(cyl)\n    @summarize(total_hp = sum(hp),\n               avg_hp = avg(hp))\n    @filter(total_hp &lt; 1000)\n    @collect\nend\n</code></pre> <pre><code>2\u00d73 DataFrame\n Row \u2502 cyl     total_hp  avg_hp\n     \u2502 Int64?  Int128?   Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      6       856  122.286\n   2 \u2502      4       909   82.6364\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#renaming-columns","title":"Renaming columns","text":"<p>Both tools use <code>rename</code>/@rename to rename columns</p> <p>Ibis</p> <pre><code>mtcars.rename(make_model = \"model\").select(_.make_model)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 make_model        \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502\n\u2502 Mazda RX4 Wag     \u2502\n\u2502 Datsun 710        \u2502\n\u2502 Hornet 4 Drive    \u2502\n\u2502 Hornet Sportabout \u2502\n\u2502 Valiant           \u2502\n\u2502 Duster 360        \u2502\n\u2502 Merc 240D         \u2502\n\u2502 Merc 230          \u2502\n\u2502 Merc 280          \u2502\n\u2502 \u2026                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain t(mtcars) @rename(model_make = model) @select(model_make) @collect\n</code></pre> <pre><code>32\u00d71 DataFrame\n Row \u2502 model_make\n     \u2502 String?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4\n   2 \u2502 Mazda RX4 Wag\n   3 \u2502 Datsun 710\n   4 \u2502 Hornet 4 Drive\n   5 \u2502 Hornet Sportabout\n   6 \u2502 Valiant\n  \u22ee  \u2502         \u22ee\n  27 \u2502 Porsche 914-2\n  28 \u2502 Lotus Europa\n  29 \u2502 Ford Pantera L\n  30 \u2502 Ferrari Dino\n  31 \u2502 Maserati Bora\n  32 \u2502 Volvo 142E\n          20 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/key_differences/","title":"Key Differences from TidierData.jl","text":"<p>There are a few important syntax and behavior differences between TidierDB.jl and TidierData.jl outlined below.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#creating-a-database","title":"Creating a database","text":"<p>For these examples we will use DuckDB, the default backend, although SQLite, Postgres, MySQL, MariaDB, MSSQL, and ClickHouse are possible. If you have an existing DuckDB connection, then this step is not required. For these examples, we will create a data frame and copy it to an in-memory DuckDB database.</p> <pre><code>using DataFrames, TidierDB\n\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\ndb = connect(duckdb());\n\ncopy_to(db, df, \"df_mem\"); # copying over the data frame to an in-memory database\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#row-ordering","title":"Row ordering","text":"<p>DuckDB benefits from aggressive parallelization of pipelines. This means that if you have multiple threads enabled in Julia, which you can check or set using <code>Threads.nthreads()</code>, DuckDB will use multiple threads. However, because many operations are multi-threaded, the resulting row order is inconsistent. If row order needs to be deterministic for your use case, make sure to apply an <code>@arrange(column_name_1, column_name_2, etc...)</code> prior to collecting the results.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#starting-a-chain","title":"Starting a chain","text":"<p>When using TidierDB, <code>db_table(connection, :table_name)</code> is used to start a chain.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#grouped-mutation","title":"Grouped mutation","text":"<p>In TidierDB, when performing <code>@group_by</code> then <code>@mutate</code>, the table will be ungrouped after applying all of the mutations in the clause to the grouped data. To perform subsequent grouped operations, the user would have to regroup the data. This is demonstrated below.</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @summarize(mean_percent = mean(percent))\n    @collect\n end\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentStringFloat641bb0.52aa0.6 <p>Regrouping following <code>@mutate</code></p> <pre><code>@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @mutate(max = maximum(percent), min = minimum(percent))\n    @group_by(groups)\n    @summarise(mean_percent = mean(percent))\n    @collect\nend\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentStringFloat641aa0.62bb0.5 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#differences-in-case_when","title":"Differences in <code>case_when()</code>","text":"<p>In TidierDB, after the clause is completed, the result for the new column should is separated by a comma <code>,</code> in contrast to TidierData.jl, where the result for the new column is separated by a <code>=&gt;</code> .</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @mutate(new_col = case_when(percent &gt; .5, \"Pass\",  # in TidierData, percent &gt; .5 =&gt; \"Pass\",\n                                percent &lt;= .5, \"Try Again\", # percent &lt;= .5 =&gt; \"Try Again\"\n                                true, \"middle\"))\n    @collect\n end\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentnew_colStringStringInt64Float64String1AAbb10.1Try Again2ABaa20.2Try Again3ACbb30.3Try Again4ADaa40.4Try Again5AEbb50.5Try Again6AFaa10.6Pass7AGbb20.7Pass8AHaa30.8Pass9AIbb40.9Pass10AJaa51.0Pass <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#joining-tables","title":"Joining Tables","text":"<p>When joining a table, the column from both tables will be present, in contrast to TidierData which will keep one column</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/outofmemex/","title":"Working With Larger than RAM Datasets","text":"<p>While using the DuckDB backend, TidierDB's lazy intferace enables querying datasets larger than your available RAM.</p> <p>To illustrate this, we will recreate the Hugging Face x Polars example. The final table results are shown below and in this Hugging Face x DuckDB example</p> <p>First we will load TidierDB, set up a local database and then set the URLs for the 2 training datasets from huggingface.co</p> <pre><code>using TidierDB\ndb = connect(duckdb())\n\nurls = [\"https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0000.parquet\",\n \"https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0001.parquet\"];\n</code></pre> <p>Here, we pass the vector of URLs to <code>db_table</code>, which will not copy them into memory. Since these datasets are so large, we will also set <code>stream = true</code> in <code>@collect</code> to stream the results. If we wanted to read all the files in the folder we could have replace the <code>0000</code> with <code>*</code> (wildcard) <code>db_table(db, \"Path/to/folder/*.parquet\")</code> Of note, reading these files from URLs is not as rapid as reading them from local files.</p> <pre><code>@chain db_table(db, urls) begin\n    @group_by(horoscope)\n    @summarise(count = n(), avg_blog_length = mean(length(text)))\n    @arrange(desc(count))\n    @aside @show_query _\n    @collect(stream = true)\nend\n</code></pre> <p>Placing <code>@aside @show_query _</code> before <code>@collect</code> above lets us see the SQL query and collect it to a local DataFrame at the same time.</p> <pre><code>SELECT horoscope, COUNT(*) AS count, AVG(length(text)) AS avg_blog_length\n        FROM read_parquet(['https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0000.parquet', 'https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0001.parquet'])\n        GROUP BY horoscope\n        ORDER BY avg_blog_length DESC\n12\u00d73 DataFrame\n Row \u2502 horoscope    count   avg_blog_length\n     \u2502 String?      Int64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Aquarius      49568         1125.83\n   2 \u2502 Cancer        63512         1097.96\n   3 \u2502 Libra         60304         1060.61\n   4 \u2502 Capricorn     49402         1059.56\n   5 \u2502 Sagittarius   50431         1057.46\n   6 \u2502 Leo           58010         1049.6\n   7 \u2502 Taurus        61571         1022.69\n   8 \u2502 Gemini        52925         1020.26\n   9 \u2502 Scorpio       56495         1014.03\n  10 \u2502 Pisces        53812         1011.75\n  11 \u2502 Virgo         64629          996.684\n  12 \u2502 Aries         69134          918.081\n</code></pre> <p>To learn more about memory efficient queries on larger than RAM files, this blog from DuckDB will help maximize your local <code>db</code></p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/s3viaduckdb/","title":"S3 + DuckDB + TidierDB","text":"<p>TidierDB allows you leverage DuckDB's seamless database integration.</p> <p>Using DuckDB, you can connect to an AWS or GoogleCloud Database to query directly without making any local copies.</p> <p>You can also use <code>DBInterface.execute</code> to set up any DuckDB database connection you need and then use that db to query with TidierDB</p> <pre><code>using TidierDB\n\n#Connect to Google Cloud via DuckDB\n#google_db = connect(duckdb(), :gbq, access_key=\"string\", secret_key=\"string\")\n\n#Connect to AWS via DuckDB\naws_db = connect(duckdb(), :aws, aws_access_key_id= \"string\",\n                                aws_secret_access_key= \"string\",\n                                aws_region=\"us-east-1\")\ns3_csv_path = \"s3://path/to_data.csv\"\n\n@chain db_table(aws_db, s3_csv_path) begin\n    @filter(!starts_with(column1, \"M\"))\n    @group_by(cyl)\n    @summarize(mpg = mean(mpg))\n    @mutate(mpg_squared = mpg^2,\n               mpg_rounded = round(mpg),\n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))\n    @filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    @arrange(desc(mpg_rounded))\n    @collect\nend\n</code></pre> <pre><code>2\u00d75 DataFrame\n Row \u2502 cyl     mpg       mpg_squared  mpg_rounded  mpg_efficiency\n     \u2502 Int64?  Float64?  Float64?     Float64?     String?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4   27.3444      747.719         27.0  efficient\n   2 \u2502      6   19.7333      389.404         20.0  moderate\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/udfs_ex/","title":"Flexible Syntax and UDFs","text":"<p>TidierDB is unique in its statement parsing flexiblility.  This means that using any built in SQL function or user defined functions (or UDFS) or is readily avaialable. To use any function built into a database in <code>@mutate</code> or in <code>@summarize</code>, simply correctly write the correctly, but replace <code>'</code> with <code>\"</code>. This also applies to any UDF. The example below will illustrate UDFs in the context of DuckDB.</p> <pre><code># Set up the connection\nusing TidierDB  #rexports DuckDB\ndb = DuckDB.DB()\ncon = DuckDB.connect(db) # this will be important for UDFs\nmtcars_path = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\nmtcars = db_tbable(con, mtcars_path);\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#aggregate-function-in-summarize","title":"aggregate function in <code>@summarize</code>","text":"<p>Lets use the DuckDB <code>kurtosis</code> aggregate function</p> <pre><code>@chain t(mtcars) begin\n      @group_by cyl\n      @summarize(kurt = kurtosis(mpg))\n      @collect\nend\n3\u00d72 DataFrame\n Row \u2502 cyl     kurt\n     \u2502 Int64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4  -1.43411\n   2 \u2502      6  -1.82944\n   3 \u2502      8   0.330061\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#aggregate-functions-in-mutate","title":"aggregate functions in <code>@mutate</code>","text":"<p>To aggregate sql functions that are builtin to any database, but exist outside of the TidierDB parser, simply wrap the function call in <code>agg()</code></p> <pre><code>@chain t(mtcars) begin\n    @group_by(cyl)\n    @mutate(kurt = agg(kurtosis(mpg)))\n    @select cyl mpg kurt\n    @collect\nend\n\n32\u00d73 DataFrame\n Row \u2502 cyl     mpg       kurt\n     \u2502 Int64?  Float64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      8      18.7   0.330061\n   2 \u2502      8      14.3   0.330061\n   3 \u2502      8      16.4   0.330061\n   4 \u2502      8      17.3   0.330061\n   5 \u2502      8      15.2   0.330061\n   6 \u2502      8      10.4   0.330061\n   7 \u2502      8      10.4   0.330061\n  \u22ee  \u2502   \u22ee        \u22ee          \u22ee\n  27 \u2502      6      21.0  -1.82944\n  28 \u2502      6      21.4  -1.82944\n  29 \u2502      6      18.1  -1.82944\n  30 \u2502      6      19.2  -1.82944\n  31 \u2502      6      17.8  -1.82944\n  32 \u2502      6      19.7  -1.82944\n                    19 rows omitted\nend\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#duckdb-function-chaining","title":"DuckDB function chaining","text":"<p>In DuckDB, functions can be chained together with <code>.</code>. TidierDB lets you leverage this.</p> <pre><code>@chain t(mtcars) begin\n    @mutate(model2 = model.upper().string_split(\" \").list_aggr(\"string_agg\",\".\").concat(\".\"))\n    @select model model2\n    @collect\nend\n32\u00d72 DataFrame\n Row \u2502 model              model2\n     \u2502 String?            String?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4          MAZDA.RX4.\n   2 \u2502 Mazda RX4 Wag      MAZDA.RX4.WAG.\n   3 \u2502 Datsun 710         DATSUN.710.\n   4 \u2502 Hornet 4 Drive     HORNET.4.DRIVE.\n   5 \u2502 Hornet Sportabout  HORNET.SPORTABOUT.\n   6 \u2502 Valiant            VALIANT.\n   7 \u2502 Duster 360         DUSTER.360.\n  \u22ee  \u2502         \u22ee                  \u22ee\n  27 \u2502 Porsche 914-2      PORSCHE.914-2.\n  28 \u2502 Lotus Europa       LOTUS.EUROPA.\n  29 \u2502 Ford Pantera L     FORD.PANTERA.L.\n  30 \u2502 Ferrari Dino       FERRARI.DINO.\n  31 \u2502 Maserati Bora      MASERATI.BORA.\n  32 \u2502 Volvo 142E         VOLVO.142E.\n                              19 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#rowid-and-pseudocolumns","title":"<code>rowid</code> and pseudocolumns","text":"<p>When a table is not being read directly from a file, <code>rowid</code> is avaialable for use. In general, TidierDB should support all pseudocolumns.</p> <pre><code>copy_to(db, mtcars_path, \"mtcars\"); # copying table in for demostration purposes\n@chain db_table(con, :mtcars) begin\n      @filter(rowid == 4)\n      @select(model:hp)\n      @collect\nend\n1\u00d75 DataFrame\n Row \u2502 model              mpg       cyl     disp      hp\n     \u2502 String?            Float64?  Int64?  Float64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Hornet Sportabout      18.7       8     360.0     175\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#udf-sqlite-example","title":"UDF SQLite Example","text":"<pre><code>using SQLite\nsql = connect(sqlite());\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\ncopy_to(db, sql, \"df_mem\");\nSQLite.@register sql function diff_of_squares(x, y)\n              x^2 - y^2\n              end;\n\n@chain db_table(sql, \"df_mem\") begin\n      @select(value, percent)\n      @mutate(plus3 = diff_of_squares(value, percent))\n      @collect\nend\n10\u00d73 DataFrame\n Row \u2502 value  percent  plus3\n     \u2502 Int64  Float64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      0.1     0.99\n   2 \u2502     2      0.2     3.96\n   3 \u2502     3      0.3     8.91\n   4 \u2502     4      0.4    15.84\n   5 \u2502     5      0.5    24.75\n   6 \u2502     1      0.6     0.64\n   7 \u2502     2      0.7     3.51\n   8 \u2502     3      0.8     8.36\n   9 \u2502     4      0.9    15.19\n  10 \u2502     5      1.0    24.0\n</code></pre>"},{"location":"examples/generated/UserGuide/udfs_ex/#how-to-create-udf-in-duckdb","title":"How to create UDF in DuckDB","text":"<p>Example coming soon..</p> <p>This page was generated using Literate.jl.</p>"}]}