{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-tidierdbjl","title":"What is TidierDB.jl?","text":"<p>TiderDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package.</p> <p>The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.</p> <p></p> <p></p>"},{"location":"#currently-supported-backends-include","title":"Currently supported backends include:","text":"DuckDB (default) <code>duckdb()</code> ClickHouse <code>clickhouse()</code> SQLite <code>sqlite()</code> Postgres <code>postgres()</code> MySQL <code>mysql()</code> MariaDB <code>mysql()</code> MSSQL <code>mssql()</code> Athena <code>athena()</code> Snowflake <code>snowflake()</code> Databricks <code>databricks()</code> Google Big Query <code>gbq()</code> Oracle <code>oracle()</code> <p>Change the backend using <code>set_sql_mode()</code> - for example  - <code>set_sql_mode(databricks())</code></p> <p></p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>For the stable version:</p> <pre><code>] add TidierDB\n</code></pre> <p>TidierDB.jl currently supports:</p> Category Supported Macros and Functions Data Manipulation <code>@arrange</code>, <code>@group_by</code>, <code>@filter</code>, <code>@select</code>, <code>@mutate</code> (supports <code>across</code>), <code>@summarize</code>/<code>@summarise</code> (supports <code>across</code>), <code>@distinct</code>, <code>@relocate</code>, <code>@transmute</code> Joining/Setting <code>@left_join</code>, <code>@right_join</code>, <code>@inner_join</code>, <code>@anti_join</code>, <code>@full_join</code>, <code>@semi_join</code>, <code>@union</code>, <code>@union_all</code>, <code>@intersect</code>, <code>@setdiff</code> Slice and Order <code>@slice_min</code>, <code>@slice_max</code>, <code>@slice_sample</code>, <code>@order</code>, <code>@window_order</code>, <code>@window_frame</code> Utility <code>@show_query</code>, <code>@collect</code>, <code>@head</code>, <code>@count</code>, <code>@drop_missing</code>, <code>show_tables</code>, <code>@create_view</code> , <code>drop_view</code> Helper Functions <code>across</code>, <code>desc</code>, <code>if_else</code>, <code>case_when</code>, <code>n</code>, <code>starts_with</code>, <code>ends_with</code>, <code>contains</code>, <code>as_float</code>, <code>as_integer</code>, <code>as_string</code>, <code>is_missing</code>, <code>missing_if</code>, <code>replace_missing</code> TidierStrings.jl Functions <code>str_detect</code>, <code>str_replace</code>, <code>str_replace_all</code>, <code>str_remove_all</code>, <code>str_remove</code> TidierDates.jl Functions <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>min</code>, <code>second</code>, <code>floor_date</code>, <code>difftime</code>, <code>mdy</code>, <code>ymd</code>, <code>dmy</code> Aggregate Functions <code>mean</code>, <code>minimum</code>, <code>maximum</code>, <code>std</code>, <code>sum</code>, <code>cumsum</code>, and nearly all aggregate sql fxns supported Window Functions <code>lead</code>, <code>lag</code>, <code>dense_rank</code>, <code>nth_value</code>, <code>ntile</code>, <code>rank_dense</code>, <code>row_number</code>, <code>first_value</code>, <code>last_value</code>, <code>cume_dist</code>, <code>@window_order</code>, <code>@window_frame</code>, or <code>_by</code>, <code>_order</code>, and <code>_frame</code> within <code>@mutate</code> Unnesting <code>unnest_wider</code> and <code>unnest_longer</code> <p><code>@summarize</code> supports any SQL aggregate function in addition to the list above. Simply write the function as written in SQL syntax and it will work.    <code>@mutate</code> supports all builtin SQL functions as well.                                                                                                 </p> <p>When using the DuckDB backend, if <code>db_table</code>, aka <code>dt</code>, recieves a file path ( <code>.parquet</code>, <code>.json</code>, <code>.csv</code>, <code>iceberg</code> or <code>delta</code>), it does not copy it into memory. This allows for queries on files too big for memory. <code>db_table</code> also supports S3 bucket locations and Google Sheets via DuckDB.</p> <p></p> <p></p>"},{"location":"#what-is-the-recommended-way-to-use-tidierdb","title":"What is the recommended way to use TidierDB?","text":"<p>Typically, you will want to use TidierDB alongside TidierData because there are certain functionality (such as pivoting) which are only supported in TidierData and can only be performed on data frames.</p> <p>Our recommended path for using TidierDB is to import the package so that there are no namespace conflicts with TidierData. Once TidierDB is integrated with Tidier, then Tidier will automatically load the packages in this fashion.</p> <p>First, let's develop and execute a query using TidierDB. Notice that all top-level macros and functions originating from TidierDB start with a <code>DB</code> prefix. Any functions defined within macros do not need to be prefixed within <code>DB</code> because they are actually pseudofunctions that are in actuality converted into SQL code.</p> <p>Even though the code reads similarly to TidierData, note that no computational work actually occurs until you run <code>DB.@collect()</code>, which runs the SQL query and instantiates the result as a DataFrame.</p> <pre><code>using TidierData\nimport TidierDB as DB\n\ndb = DB.connect(DB.duckdb());\npath_or_name = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\n\n@chain DB.dt(db, path_or_name) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\nend\n</code></pre> <pre><code>2\u00d75 DataFrame\n Row \u2502 cyl     mpg       mpg_squared  mpg_rounded  mpg_efficiency \n     \u2502 Int64?  Float64?  Float64?     Float64?     String?        \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4   27.3444      747.719         27.0  efficient\n   2 \u2502      6   19.7333      389.404         20.0  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-if-we-wanted-to-pivot-the-result","title":"What if we wanted to pivot the result?","text":"<p>We cannot do this using TidierDB. However, we can call <code>@pivot_longer()</code> from TidierData after the result of the query has been instantiated as a DataFrame, like this: </p> <pre><code>@chain DB.db_table(db, path_or_name) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\n    @pivot_longer(everything(), names_to = \"variable\", values_to = \"value\")\nend\n</code></pre> <pre><code>10\u00d72 DataFrame\n Row \u2502 variable        value     \n     \u2502 String          Any       \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 cyl             4\n   2 \u2502 cyl             6\n   3 \u2502 mpg             27.3444\n   4 \u2502 mpg             19.7333\n   5 \u2502 mpg_squared     747.719\n   6 \u2502 mpg_squared     389.404\n   7 \u2502 mpg_rounded     27.0\n   8 \u2502 mpg_rounded     20.0\n   9 \u2502 mpg_efficiency  efficient\n  10 \u2502 mpg_efficiency  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-sql-query-does-tidierdb-generate-for-a-given-piece-of-julia-code","title":"What SQL query does TidierDB generate for a given piece of Julia code?","text":"<p>We can replace <code>DB.collect()</code> with <code>DB.@show_query</code> to reveal the underlying SQL query being generated by TidierDB. To handle complex queries, TidierDB makes heavy use of Common Table Expressions (CTE), which are a useful tool to organize long queries.</p> <pre><code>@chain DB.dt(db, path_or_name) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@show_query\nend\n</code></pre> <pre><code>WITH cte_1 AS (\nSELECT  *\n        FROM 'https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv' AS mtcars \n        WHERE NOT (starts_with(model, 'M'))),\ncte_2 AS (\nSELECT cyl, AVG(mpg) AS mpg\n        FROM cte_1\n        GROUP BY cyl),\ncte_3 AS (\nSELECT  cyl, mpg, POWER(mpg, 2) AS mpg_squared, ROUND(mpg) AS mpg_rounded, CASE WHEN mpg &gt;= POWER(cyl, 2) THEN 'efficient' WHEN mpg &lt; 15.2 THEN 'inefficient' ELSE 'moderate' END AS mpg_efficiency\n        FROM cte_2 )  \nSELECT *\n        FROM cte_3  \n        WHERE mpg_efficiency in ('moderate', 'efficient')  \n        ORDER BY mpg_rounded DESC\n</code></pre> <p></p> <p></p>"},{"location":"#tidierdb-is-already-quite-fully-featured-supporting-advanced-tidierdata-functions-like-across-for-multi-column-selection","title":"TidierDB is already quite fully-featured, supporting advanced TidierData functions like <code>across()</code> for multi-column selection.","text":"<pre><code>@chain DB.dt(db, path_or_name) begin\n    DB.@group_by(cyl)\n    DB.@summarize(across((starts_with(\"a\"), ends_with(\"s\")), (mean, sum)))\n    DB.@collect\nend\n</code></pre> <pre><code>3\u00d75 DataFrame\n Row \u2502 cyl     am_mean   vs_mean   am_sum   vs_sum  \n     \u2502 Int64?  Float64?  Float64?  Int128?  Int128? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4  0.727273  0.909091        8       10\n   2 \u2502      6  0.428571  0.571429        3        4\n   3 \u2502      8  0.142857  0.0             2        0\n</code></pre> <p>There are a few subtle but important differences from Tidier.jl outlined here.</p> <p></p> <p></p>"},{"location":"#missing-a-function-or-backend","title":"Missing a function or backend?","text":"<p>You can use any existing SQL function within <code>@mutate</code> with the correct SQL syntax and it should just work.</p> <p>But if you run into problems please open an issue, and we will be happy to take a look!</p>"},{"location":"reference/","title":"References/Docstrings","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>TidierDB.aggregate_and_window_functions</code></li> <li><code>TidierDB.connect</code></li> <li><code>TidierDB.copy_to</code></li> <li><code>TidierDB.db_table</code></li> <li><code>TidierDB.drop_view</code></li> <li><code>TidierDB.show_tables</code></li> <li><code>TidierDB.warnings</code></li> <li><code>TidierDB.write_file</code></li> <li><code>TidierDB.@anti_join</code></li> <li><code>TidierDB.@arrange</code></li> <li><code>TidierDB.@collect</code></li> <li><code>TidierDB.@count</code></li> <li><code>TidierDB.@create_view</code></li> <li><code>TidierDB.@distinct</code></li> <li><code>TidierDB.@drop_missing</code></li> <li><code>TidierDB.@filter</code></li> <li><code>TidierDB.@full_join</code></li> <li><code>TidierDB.@group_by</code></li> <li><code>TidierDB.@head</code></li> <li><code>TidierDB.@inner_join</code></li> <li><code>TidierDB.@intersect</code></li> <li><code>TidierDB.@left_join</code></li> <li><code>TidierDB.@mutate</code></li> <li><code>TidierDB.@pivot_longer</code></li> <li><code>TidierDB.@pivot_wider</code></li> <li><code>TidierDB.@relocate</code></li> <li><code>TidierDB.@rename</code></li> <li><code>TidierDB.@right_join</code></li> <li><code>TidierDB.@select</code></li> <li><code>TidierDB.@semi_join</code></li> <li><code>TidierDB.@separate</code></li> <li><code>TidierDB.@setdiff</code></li> <li><code>TidierDB.@slice_max</code></li> <li><code>TidierDB.@slice_min</code></li> <li><code>TidierDB.@slice_sample</code></li> <li><code>TidierDB.@summarise</code></li> <li><code>TidierDB.@summarize</code></li> <li><code>TidierDB.@summary</code></li> <li><code>TidierDB.@transmute</code></li> <li><code>TidierDB.@union</code></li> <li><code>TidierDB.@union_all</code></li> <li><code>TidierDB.@unite</code></li> <li><code>TidierDB.@unnest_longer</code></li> <li><code>TidierDB.@unnest_wider</code></li> <li><code>TidierDB.@window_frame</code></li> <li><code>TidierDB.@window_order</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>TidierDB.connect</code> \u2014 Method.</p> <pre><code>connect(backend; kwargs...)\n</code></pre> <p>This function establishes a database connection based on the specified backend and connection parameters and sets the SQL mode</p> <p>Arguments</p> <ul> <li> <p><code>backend</code>: type specifying the database backend to connect to. Supported backends are:</p> <ul> <li><code>duckdb()</code>, <code>sqlite()</code>(SQLite), <code>mssql()</code>, <code>mysql()</code>(for MariaDB and MySQL), <code>clickhouse()</code>, <code>postgres()</code></li> <li><code>kwargs</code>: Keyword arguments specifying the connection parameters for the selected backend. The required parameters vary depending on the backend:</li> </ul> </li> </ul> <p>Returns</p> <ul> <li>A database connection object based on the selected backend.</li> </ul> <p>Examples</p> <pre><code># Connect to MySQL\n# conn = connect(mysql(); host=\"localhost\", user=\"root\", password=\"password\", db=\"mydb\")\n# Connect to PostgreSQL using LibPQ\n# conn = connect(postgres(); host=\"localhost\", dbname=\"mydb\", user=\"postgres\", password=\"password\")\n# Connect to ClickHouse\n# conn = connect(clickhouse(); host=\"localhost\", port=9000, database=\"mydb\", user=\"default\", password=\"\")\n# Connect to SQLite\n# conn = connect(sqlite())\n# Connect to Google Big Query\n# conn = connect(gbq(), \"json_user_key_path\", \"location\")\n# Connect to Snowflake\n# conn = connect(snowflake(), \"ac_id\", \"token\", \"Database_name\", \"Schema_name\", \"warehouse_name\")\n# Connect to Microsoft SQL Server\n# conn = connect(mssql(), \"DRIVER={ODBC Driver 18 for SQL Server};SERVER=host,1433;UID=sa;PWD=YourPassword;Encrypt=no;TrustServerCertificate=yes\")\n# Connect to DuckDB\n# connect to Google Cloud via DuckDB\n# google_db = connect(duckdb(), :gbq, access_key=\"string\", secret_key=\"string\")\n# Connect to AWS via DuckDB\n# aws_db = connect2(duckdb(), :aws, aws_access_key_id=get(ENV, \"AWS_ACCESS_KEY_ID\", \"access_key\"), aws_secret_access_key=get(ENV, \"AWS_SECRET_ACCESS_KEY\", \"secret_access key\"), aws_region=get(ENV, \"AWS_DEFAULT_REGION\", \"us-east-1\"))\n# Connect to MotherDuck\n# connect(duckdb(), \"\"md://...\"\") for first connection, vs connect(duckdb(), \"md:\") for reconnection\n# Connect to exisiting database file\n# connect(duckdb(), \"path/to/database.duckdb\")\n# Open an in-memory database\njulia&gt; db = connect(duckdb())\nDuckDB.DB(\":memory:\")\n</code></pre> <p>source</p> <p># <code>TidierDB.copy_to</code> \u2014 Method.</p> <pre><code>   copy_to(conn, df_or_path, \"name\"; overwrite = false )\n</code></pre> <p>Allows user to copy a df to the database connection. Currently supports DuckDB, SQLite, MySql</p> <p>Arguments</p> <ul> <li><code>conn</code>: the database connection</li> <li><code>df</code>: dataframe to be copied or path to serve as source. With DuckDB, path supports .csv, .json, .parquet</li> <li><code>name</code>: name as string for the database to be used</li> <li><code>overwrite</code>: whether or not table with chosen name should be overwritten if it exists, defaults to <code>false</code></li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; copy_to(db, df, \"test\");\n</code></pre> <p>source</p> <p># <code>TidierDB.db_table</code> \u2014 Function.</p> <pre><code>db_table(database, table_name, athena_params, delta = false, iceberg = false, alias = \"\", df_name)\ndt(database, table_name, athena_params, delta = false, iceberg = false, alias = \"\", df_name)\n</code></pre> <p><code>db_table</code> starts the underlying SQL query struct, adding the metadata and table. If paths are passed directly to <code>db_table</code> instead of a  name it will not copy it to memory, but rather read directly from the file. <code>db_table</code>  only supports direct file paths to a table. DataFrames  are read as a view. It does not support database file paths such as  <code>dbname.duckdb</code>  or  <code>dbname.sqlite</code>. Database files must be used with <code>connect(db, \"path_to_db.duckdb\")</code> first  to allow <code>db_table</code> to read the db tables.</p> <p>Arguments</p> <ul> <li><code>database</code>: The Database or connection object</li> <li> <p><code>table_name</code>: tablename as a string (dataframe, name, local path, or URL).     - CSV/TSV       - Parquet     - Json      - Iceberg     - Delta     - S3 tables from AWS or Google Cloud      - Google Sheets spreadsheet link</p> <ul> <li>DuckDB and ClickHouse support vectors of paths and URLs.</li> <li> <p>DuckDB and ClickHouse also support use of <code>*</code> wildcards to read all files of a type in a location such as:</p> <ul> <li><code>db_table(db, \"Path/to/testing_files/*.parquet\")</code><ul> <li>Use any DuckDB reader \"readcsv('filepath', additional arguments allowed)\" .</li> </ul> </li> <li><code>delta</code>: must be true to read delta files</li> <li><code>iceberg</code>: must be true to read iceberg finalize_ctes</li> <li><code>alias</code>: optional argument when using a <code>*</code> wildcard in a file path, that allows user to determine an alias for the data being read in. If empty, it will refer to table as <code>data</code>.</li> <li><code>df_name</code> when using a DataFrame as the second argument, a third string argument must be supplied to become the name of the view.</li> </ul> </li> </ul> </li> </ul> <p>Example</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; dt(db, df, \"df_mem\");\n\njulia&gt; db_table(db, \"main.df_mem\");\n\njulia&gt; dt(db, \"df_mem\" , alias = \"my_table\");\n</code></pre> <p>source</p> <p># <code>TidierDB.drop_view</code> \u2014 Method.</p> <pre><code>drop_view(sql_query, name)\n</code></pre> <p>Drop a view. Currently supports DuckDB, MySQL, GBQ, Postgres</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to create a view from.</li> <li><code>name</code>: The name of the view to drop.</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(id = [1, 2, 3], value = [10, 20, 30]);\n\njulia&gt; @chain dt(db, df, \"df1\") @create_view(viewer);\n\njulia&gt; drop_view(db, \"viewer\");\n</code></pre> <p>source</p> <p># <code>TidierDB.show_tables</code> \u2014 Method.</p> <pre><code>show_tables(con; GBQ_datasetname)\n</code></pre> <p>Shows tables available in database. currently supports DuckDB, databricks, Snowflake, GBQ, SQLite, LibPQ</p> <p>Arguments</p> <ul> <li><code>con</code> : connection to backend</li> <li><code>GBQ_datasetname</code> : string of dataset name</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; show_tables(db);\n</code></pre> <p>source</p> <p># <code>TidierDB.warnings</code> \u2014 Method.</p> <pre><code>warnings(show::Bool)\n</code></pre> <p>Sets the global warning flag to the specified boolean value.</p> <p>Arguments</p> <ul> <li><code>flag::Bool</code>: A boolean value to set the warning flag. If <code>true</code>, warnings will be enabled; if <code>false</code>, warnings will be disabled.</li> </ul> <p>Default Behavior</p> <p>By default, the warning flag is set to <code>false</code>, meaning that warnings are disabled unless explicitly enabled by setting this function with <code>true</code>.</p> <p>Example</p> <pre><code>julia&gt; warnings(true);\n</code></pre> <p>source</p> <p># <code>TidierDB.write_file</code> \u2014 Function.</p> <pre><code> write_file(sql_query::SQLQuery, path)\n</code></pre> <p>Write a local file to from sql_query. Only supports DuckDB at this time.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>path</code>: file path with file type suffix ie \"path.csv\", \"path.parquet\", etc</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(a = [\"1-1\", \"2-2\", \"3-3-3\"]); \n\njulia&gt; @chain dt(db, df, \"df\") @filter(a == \"2-2\") write_file(\"test.parquet\")\n(Count = [1],)\n</code></pre> <p>source</p> <p># <code>TidierDB.@anti_join</code> \u2014 Macro.</p> <pre><code>@anti_join(sql_query, join_table, orignal_table_col == new_table_col)\n</code></pre> <p>Perform an anti join between two SQL queries based on a specified condition.  Joins can be equi joins or inequality joins. For equi joins, the joining table  key column is dropped. Inequality joins can be made into AsOf or rolling joins  by wrapping the inequality in closest(key &gt;= key2). With inequality joins, the  columns from both tables are kept. Multiple joining criteria can be added, but  need to be separated by commas, ie <code>closest(key &gt;= key2), key3 == key3</code></p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table::{SQLQuery, String}</code>: The secondary SQL table to join with the primary query table. Table that exist on the database already should be written as a string of the name</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; dfj = dt(db, df2, \"df_join\");\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n        @anti_join(t(dfj), id == id2)\n        @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa          2      0.2\n   2 \u2502 AD      aa          4      0.4\n   3 \u2502 AF      aa          1      0.6\n   4 \u2502 AH      aa          3      0.8\n   5 \u2502 AJ      aa          5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@arrange</code> \u2014 Macro.</p> <pre><code>@arrange(sql_query, columns...)\n</code></pre> <p>Order SQL table rows based on specified column(s). Of note, <code>@arrange</code> should not be used when performing ordered window functions,  <code>@window_order</code>, or preferably the <code>_order</code> argument in <code>@mutate</code> should be used instead</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to arrange</li> <li><code>columns</code>: Columns to order the rows by. Can include multiple columns for nested sorting. Wrap column name with <code>desc()</code> for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @arrange(value, desc(percent))\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF      aa          1      0.6\n   2 \u2502 AA      bb          1      0.1\n   3 \u2502 AG      bb          2      0.7\n   4 \u2502 AB      aa          2      0.2\n   5 \u2502 AH      aa          3      0.8\n   6 \u2502 AC      bb          3      0.3\n   7 \u2502 AI      bb          4      0.9\n   8 \u2502 AD      aa          4      0.4\n   9 \u2502 AJ      aa          5      1.0\n  10 \u2502 AE      bb          5      0.5\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @arrange(desc(df_view.value))\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AE      bb          5      0.5\n   2 \u2502 AJ      aa          5      1.0\n   3 \u2502 AD      aa          4      0.4\n   4 \u2502 AI      bb          4      0.9\n   5 \u2502 AC      bb          3      0.3\n   6 \u2502 AH      aa          3      0.8\n   7 \u2502 AB      aa          2      0.2\n   8 \u2502 AG      bb          2      0.7\n   9 \u2502 AA      bb          1      0.1\n  10 \u2502 AF      aa          1      0.6\n</code></pre> <p>source</p> <p># <code>TidierDB.@collect</code> \u2014 Macro.</p> <pre><code>@collect(sql_query, stream = false)\n</code></pre> <p><code>db_table</code> starts the underlying SQL query struct, adding the metadata and table. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>stream</code>: optional streaming for query/execution of results when using DuckDB. Defaults to false</li> </ul> <p>Example</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\n\njulia&gt; @collect dt(db, \"df_mem\")\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n   2 \u2502 AB      aa          2      0.2\n   3 \u2502 AC      bb          3      0.3\n   4 \u2502 AD      aa          4      0.4\n   5 \u2502 AE      bb          5      0.5\n   6 \u2502 AF      aa          1      0.6\n   7 \u2502 AG      bb          2      0.7\n   8 \u2502 AH      aa          3      0.8\n   9 \u2502 AI      bb          4      0.9\n  10 \u2502 AJ      aa          5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@count</code> \u2014 Macro.</p> <pre><code>@count(sql_query, columns...)\n</code></pre> <p>Count the number of rows grouped by specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to group by before counting. If no columns are specified, counts all rows in the query.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @count(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups  n     \n     \u2502 String  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          5\n   2 \u2502 bb          5\n</code></pre> <p>source</p> <p># <code>TidierDB.@create_view</code> \u2014 Macro.</p> <pre><code>@create_view(sql_query, name, replace = true)\n</code></pre> <p>Create a view from a SQL query. Currently supports DuckDB, MySQL, GBQ, Postgres</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to create a view from.</li> <li><code>name</code>: The name of the view to create.</li> <li><code>replace</code>: Boolean value that defaults to false so as not to replace exisiting views</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(id = [1, 2, 3], value = [10, 20, 30]);\n\njulia&gt; @chain dt(db, df, \"df1\") @create_view(viewer); # will not overwrite existing view\n\njulia&gt; dt(db, \"viewer\");\n\njulia&gt; @chain dt(db, df, \"df1\") @create_view(viewer, true); # will overwrite exisiting view\n</code></pre> <p>source</p> <p># <code>TidierDB.@distinct</code> \u2014 Macro.</p> <pre><code>@distinct(sql_query, columns...)\n</code></pre> <p>Select distinct rows based on specified column(s). Distinct works differently in TidierData vs SQL and therefore TidierDB. Distinct will also select only the only columns it is given (or all if given none)</p> <p>Arguments</p> <p><code>sql_query::SQLQuery</code>: The SQL query to operate on. <code>columns</code>: Columns to determine uniqueness. If no columns are specified, all columns are used to identify distinct rows.</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @distinct(value)\n         @arrange(value)\n         @collect\n       end\n5\u00d71 DataFrame\n Row \u2502 value \n     \u2502 Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1\n   2 \u2502     2\n   3 \u2502     3\n   4 \u2502     4\n   5 \u2502     5\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @distinct\n         @arrange(id)\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n   2 \u2502 AB      aa          2      0.2\n   3 \u2502 AC      bb          3      0.3\n   4 \u2502 AD      aa          4      0.4\n   5 \u2502 AE      bb          5      0.5\n   6 \u2502 AF      aa          1      0.6\n   7 \u2502 AG      bb          2      0.7\n   8 \u2502 AH      aa          3      0.8\n   9 \u2502 AI      bb          4      0.9\n  10 \u2502 AJ      aa          5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@drop_missing</code> \u2014 Macro.</p> <pre><code>@drop_missing(sql_query, [cols...])\n</code></pre> <p>Drop all rows with missing values.</p> <p>When called without arguments, <code>@drop_missing()</code> drops all rows with missing values in any column. If columns are provided as an optional argument, only missing values from named columns are considered when dropping rows.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>cols...</code>: An optional column, or multiple columns separated by commas or specified using selection helpers.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(\n              a = [1, 2, missing, 4],\n              b = [1, missing, 3, 4]\n            )\n4\u00d72 DataFrame\n Row \u2502 a        b       \n     \u2502 Int64?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502       1        1\n   2 \u2502       2  missing \n   3 \u2502 missing        3\n   4 \u2502       4        4\n\njulia&gt; db = connect(duckdb()); dbdf = dt(db, df, \"df\");\n\njulia&gt; @chain dbdf @drop_missing() @collect\n2\u00d72 DataFrame\n Row \u2502 a      b     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1\n   2 \u2502     4      4\n\njulia&gt; @chain dbdf @drop_missing(a) @collect\n3\u00d72 DataFrame\n Row \u2502 a      b       \n     \u2502 Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1\n   2 \u2502     2  missing \n   3 \u2502     4        4\n\njulia&gt; @chain dbdf @drop_missing(a, b) @collect\n2\u00d72 DataFrame\n Row \u2502 a      b     \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1\n   2 \u2502     4      4\n\njulia&gt; @chain dbdf @drop_missing(starts_with(\"a\")) @collect\n3\u00d72 DataFrame\n Row \u2502 a      b       \n     \u2502 Int64  Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1\n   2 \u2502     2  missing \n   3 \u2502     4        4\n</code></pre> <p>source</p> <p># <code>TidierDB.@filter</code> \u2014 Macro.</p> <pre><code>@filter(sql_query, conditions...)\n</code></pre> <p>Filter rows in a SQL table based on specified conditions.</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to filter rows from.</li> <li><code>conditions</code>: Expressions specifying the conditions that rows must satisfy to be included in the output.                   Rows for which the expression evaluates to <code>true</code> will be included in the result.                   Multiple conditions can be combined using logical operators (<code>&amp;&amp;</code>, <code>||</code>). <code>@filter</code> will automatically                   detect whether the conditions belong in WHERE vs HAVING.</li> </ul> <p>Temporarily, it is best to use begin and end when filtering multiple conditions. (ex 2 below)</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @filter(percent &gt; .5)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF      aa          1      0.6\n   2 \u2502 AG      bb          2      0.7\n   3 \u2502 AH      aa          3      0.8\n   4 \u2502 AI      bb          4      0.9\n   5 \u2502 AJ      aa          5      1.0\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @summarise(mean = mean(percent))\n         @filter begin \n           groups == \"bb\" || # logical operators can still be used like this\n           mean &gt; .5\n         end\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups  mean    \n     \u2502 String  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          0.6\n   2 \u2502 bb          0.5\n\njulia&gt; q = @chain dt(db, df, \"df_view\") @summarize(mean = mean(value));\n\njulia&gt; @eval @chain dt(db, df, \"df_view\") begin\n         @filter(value &lt; $q) \n         @collect\n       end\n4\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n   2 \u2502 AB      aa          2      0.2\n   3 \u2502 AF      aa          1      0.6\n   4 \u2502 AG      bb          2      0.7\n</code></pre> <p>source</p> <p># <code>TidierDB.@full_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, orignal_table_col == new_table_col)\n</code></pre> <p>Perform an full join between two SQL queries based on a specified condition.  Joins can be equi joins or inequality joins. For equi joins, the joining table  key column is dropped. Inequality joins can be made into AsOf or rolling joins  by wrapping the inequality in closest(key &gt;= key2). With inequality joins, the  columns from both tables are kept. Multiple joining criteria can be added, but  need to be separated by commas, ie <code>closest(key &gt;= key2), key3 == key3</code></p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table::{SQLQuery, String}</code>: The secondary SQL table to join with the primary query table. Table that exist on the database already should be written as a string of the name</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; dfj = dt(db, df2, \"df_join\");\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @full_join((@chain dt(db, \"df_join\") @filter(score &gt; 70)), id == id)\n         @collect\n       end\n11\u00d76 DataFrame\n Row \u2502 id      groups   value    percent    category  score   \n     \u2502 String  String?  Int64?   Float64?   String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb             1        0.1  X              88\n   2 \u2502 AC      bb             3        0.3  Y              92\n   3 \u2502 AE      bb             5        0.5  X              77\n   4 \u2502 AG      bb             2        0.7  Y              83\n   5 \u2502 AI      bb             4        0.9  X              95\n   6 \u2502 AB      aa             2        0.2  missing   missing \n   7 \u2502 AD      aa             4        0.4  missing   missing \n   8 \u2502 AF      aa             1        0.6  missing   missing \n   9 \u2502 AH      aa             3        0.8  missing   missing \n  10 \u2502 AJ      aa             5        1.0  missing   missing \n  11 \u2502 AM      missing  missing  missing    X              74\n</code></pre> <p>source</p> <p># <code>TidierDB.@group_by</code> \u2014 Macro.</p> <pre><code>@group_by(sql_query, columns...)\n</code></pre> <p>Group SQL table rows by specified column(s). If grouping is performed as a terminal operation without a  subsequent mutatation or summarization (as in the example below), then the resulting data frame will only  contains those groups. Collecting following a grouping will not return a grouped dataframe as TidierData does. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions specifying the columns to group by. Columns can be specified by name.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d71 DataFrame\n Row \u2502 groups \n     \u2502 String \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa\n   2 \u2502 bb\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(big_val = if_else(value &gt; 3, \"big\", \"small\"))\n         @summarise(n=n())\n         @arrange(big_val)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 big_val  n     \n     \u2502 String   Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 big          4\n   2 \u2502 small        6\n</code></pre> <p>source</p> <p># <code>TidierDB.@head</code> \u2014 Macro.</p> <pre><code>@head(sql_query, value)\n</code></pre> <p>Limit SQL table number of rows returned based on specified value.  <code>LIMIT</code> in SQL</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>value</code>: Number to limit how many rows are returned. If left empty, it will default to 6 rows</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n        @head(1) ## supports expressions ie `3-2` would return the same df below\n        @collect\n       end\n1\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n</code></pre> <p>source</p> <p># <code>TidierDB.@inner_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, orignal_table_col == new_table_col)\n</code></pre> <p>Perform an inner join between two SQL queries based on a specified condition.  Joins can be equi joins or inequality joins. For equi joins, the joining table  key column is dropped. Inequality joins can be made into AsOf or rolling joins  by wrapping the inequality in closest(key &gt;= key2). With inequality joins, the  columns from both tables are kept. Multiple joining criteria can be added, but  need to be separated by commas, ie <code>closest(key &gt;= key2), key3 == key3</code></p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table::{SQLQuery, String}</code>: The secondary SQL table to join with the primary query table. Table that exist on the database already should be written as a string of the name</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts columns as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; dfj = dt(db, df2, \"df_join\");\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @inner_join(t(dfj), id == id2)\n         @collect\n       end\n5\u00d76 DataFrame\n Row \u2502 id      groups  value  percent  category  score \n     \u2502 String  String  Int64  Float64  String    Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1  X            88\n   2 \u2502 AC      bb          3      0.3  Y            92\n   3 \u2502 AE      bb          5      0.5  X            77\n   4 \u2502 AG      bb          2      0.7  Y            83\n   5 \u2502 AI      bb          4      0.9  X            95\n</code></pre> <p>source</p> <p># <code>TidierDB.@intersect</code> \u2014 Macro.</p> <pre><code>@intersect(sql_query1, sql_query2, all = false)\n</code></pre> <p>Combine two SQL queries/tables using <code>INTERSECT</code></p> <p>Arguments</p> <ul> <li><code>sql_query1</code>: The first SQL query to combine.</li> <li><code>sql_query2</code>: The second SQL query to combine.</li> <li><code>all</code>: Defaults to false, when true it will return duplicates. <code>INTERSECT ALL</code></li> </ul> <p>Returns</p> <ul> <li>A lazy query of all rows in the second query bound to the first</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df1 = DataFrame(id = [1, 2, 2, 3, 4],\n        name = [\"Alice\", \"Bob\", \"Bob\", \"Charlie\", \"David\"]);\n\njulia&gt; df2 = DataFrame( id = [2, 2, 3, 5],\n       name = [\"Bob\", \"Bob\", \"Charlie\", \"Eve\"]);\n\njulia&gt; df1_table = dt(db, df1, \"df1\"); \n\njulia&gt; df2_table = dt(db, df2, \"df2\"); \n\njulia&gt; @chain df1_table @intersect(df2_table) @collect\n2\u00d72 DataFrame\n Row \u2502 id     name    \n     \u2502 Int64  String  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     2  Bob\n   2 \u2502     3  Charlie\n\njulia&gt; @chain df1_table @intersect(df2_table, all = true) @arrange(desc(id)) @collect\n3\u00d72 DataFrame\n Row \u2502 id     name    \n     \u2502 Int64  String  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     3  Charlie\n   2 \u2502     2  Bob\n   3 \u2502     2  Bob\n</code></pre> <p>source</p> <p># <code>TidierDB.@left_join</code> \u2014 Macro.</p> <pre><code>@left_join(sql_query, join_table, orignal_table_col == new_table_col)\n</code></pre> <p>Perform a left join between two SQL queries based on a specified condition.  Joins can be equi joins or inequality joins. For equi joins, the joining table  key column is dropped. Inequality joins can be made into AsOf or rolling joins  by wrapping the inequality in closest(key &gt;= key2). With inequality joins, the  columns from both tables are kept. Multiple joining criteria can be added, but  need to be separated by commas, ie <code>closest(key &gt;= key2), key3 == key3</code></p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The primary SQL query to operate on.</li> <li><code>join_table::{SQLQuery, String}</code>: The secondary SQL table to join with the primary query table. Table that exist on the database already should be written as a string of the name</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; dfm = dt(db, df, \"df_mem\"); dfj = dt(db, df2, \"df_join\");\n\njulia&gt; @chain dfm begin\n         @left_join(t(dfj), id == id2 )\n         @collect\n       end\n10\u00d76 DataFrame\n Row \u2502 id      groups  value  percent  category  score   \n     \u2502 String  String  Int64  Float64  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1  X              88\n   2 \u2502 AC      bb          3      0.3  Y              92\n   3 \u2502 AE      bb          5      0.5  X              77\n   4 \u2502 AG      bb          2      0.7  Y              83\n   5 \u2502 AI      bb          4      0.9  X              95\n   6 \u2502 AB      aa          2      0.2  missing   missing \n   7 \u2502 AD      aa          4      0.4  missing   missing \n   8 \u2502 AF      aa          1      0.6  missing   missing \n   9 \u2502 AH      aa          3      0.8  missing   missing \n  10 \u2502 AJ      aa          5      1.0  missing   missing \n\njulia&gt; query = @chain dt(db, \"df_join\") begin\n                  @filter(score &gt; 85) # only show scores above 85 in joining table\n                end;\n\njulia&gt; @chain dfm begin\n         @left_join(t(query), id == id2)\n         @collect\n       end\n10\u00d76 DataFrame\n Row \u2502 id      groups  value  percent  category  score   \n     \u2502 String  String  Int64  Float64  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1  X              88\n   2 \u2502 AC      bb          3      0.3  Y              92\n   3 \u2502 AI      bb          4      0.9  X              95\n   4 \u2502 AB      aa          2      0.2  missing   missing \n   5 \u2502 AD      aa          4      0.4  missing   missing \n   6 \u2502 AE      bb          5      0.5  missing   missing \n   7 \u2502 AF      aa          1      0.6  missing   missing \n   8 \u2502 AG      bb          2      0.7  missing   missing \n   9 \u2502 AH      aa          3      0.8  missing   missing \n  10 \u2502 AJ      aa          5      1.0  missing   missing \n\njulia&gt;  @chain dfm begin\n         @mutate(test = percent * 100)\n         @left_join(t(dfj), test &lt;= score, id = id2)\n         @collect\n       end;\n\n\njulia&gt;  @chain dfm begin\n         @mutate(test = percent * 200)\n         @left_join(t(dfj), closest(test &gt;= score)) # asof join\n         @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@mutate</code> \u2014 Macro.</p> <pre><code>@mutate(sql_query, exprs...; _by, _frame, _order)\n</code></pre> <p>Mutate SQL table by adding new columns or modifying existing ones.</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions for mutating the table. New columns can be added or existing columns modified using <code>column_name = expression syntax</code>, where expression can involve existing columns.</li> <li><code>_by</code>: optional argument that supports single column names, or vectors of columns to allow for grouping for the transformation in the macro call</li> <li><code>_frame</code>: optional argument that allows window frames to be determined within <code>@mutate</code>. supports single digits or tuples of numbers. supports <code>desc()</code> prefix</li> <li><code>_order</code>: optional argument that allows window orders to be determined within <code>@mutate</code>. supports single columns or vectors of names</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @mutate(value = value * 4, new_col = percent^2)\n         @collect\n       end\n10\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  new_col \n     \u2502 String  String  Int64  Float64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          4      0.1     0.01\n   2 \u2502 AB      aa          8      0.2     0.04\n   3 \u2502 AC      bb         12      0.3     0.09\n   4 \u2502 AD      aa         16      0.4     0.16\n   5 \u2502 AE      bb         20      0.5     0.25\n   6 \u2502 AF      aa          4      0.6     0.36\n   7 \u2502 AG      bb          8      0.7     0.49\n   8 \u2502 AH      aa         12      0.8     0.64\n   9 \u2502 AI      bb         16      0.9     0.81\n  10 \u2502 AJ      aa         20      1.0     1.0\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @mutate(max = maximum(percent), sum = sum(percent), _by = groups)\n         @collect\n       end\n10\u00d76 DataFrame\n Row \u2502 id      groups  value  percent  max      sum     \n     \u2502 String  String  Int64  Float64  Float64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa          2      0.2      1.0      3.0\n   2 \u2502 AD      aa          4      0.4      1.0      3.0\n   3 \u2502 AF      aa          1      0.6      1.0      3.0\n   4 \u2502 AH      aa          3      0.8      1.0      3.0\n   5 \u2502 AJ      aa          5      1.0      1.0      3.0\n   6 \u2502 AA      bb          1      0.1      0.9      2.5\n   7 \u2502 AC      bb          3      0.3      0.9      2.5\n   8 \u2502 AE      bb          5      0.5      0.9      2.5\n   9 \u2502 AG      bb          2      0.7      0.9      2.5\n  10 \u2502 AI      bb          4      0.9      0.9      2.5\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n          @mutate(value1 = sum(value), \n                      _order = percent, \n                      _frame = (-1, 1), \n                      _by = groups) \n          @mutate(value2 = sum(value), \n                      _order = desc(percent),\n                      _frame = 2)  \n          @arrange(groups)\n          @collect\n       end\n10\u00d76 DataFrame\n Row \u2502 id      groups  value  percent  value1  value2  \n     \u2502 String  String  Int64  Float64  Int128  Int128? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AJ      aa          5      1.0       8       21\n   2 \u2502 AH      aa          3      0.8       9       16\n   3 \u2502 AF      aa          1      0.6       8       10\n   4 \u2502 AD      aa          4      0.4       7        3\n   5 \u2502 AB      aa          2      0.2       6  missing \n   6 \u2502 AI      bb          4      0.9       6       18\n   7 \u2502 AG      bb          2      0.7      11       15\n   8 \u2502 AE      bb          5      0.5      10        6\n   9 \u2502 AC      bb          3      0.3       9        1\n  10 \u2502 AA      bb          1      0.1       4  missing \n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @mutate(across([:value, :percent], agg(kurtosis)))\n         @collect\n       end\n10\u00d76 DataFrame\n Row \u2502 id      groups  value  percent  value_kurtosis  percent_kurtosis \n     \u2502 String  String  Int64  Float64  Float64         Float64          \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1        -1.33393              -1.2\n   2 \u2502 AB      aa          2      0.2        -1.33393              -1.2\n   3 \u2502 AC      bb          3      0.3        -1.33393              -1.2\n   4 \u2502 AD      aa          4      0.4        -1.33393              -1.2\n   5 \u2502 AE      bb          5      0.5        -1.33393              -1.2\n   6 \u2502 AF      aa          1      0.6        -1.33393              -1.2\n   7 \u2502 AG      bb          2      0.7        -1.33393              -1.2\n   8 \u2502 AH      aa          3      0.8        -1.33393              -1.2\n   9 \u2502 AI      bb          4      0.9        -1.33393              -1.2\n  10 \u2502 AJ      aa          5      1.0        -1.33393              -1.2\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n          @mutate(value2 = sum(value), \n                      _order = desc([:value, :percent]),\n                      _frame = 2);  \n          @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@pivot_longer</code> \u2014 Macro.</p> <p>@pivotlonger(df, namesfrom, values_from)</p> <p>Reshapes the SQL_query to make it longer, increasing the number of rows and reducing the number of columns.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>cols</code>: Columns to pivot into longer format. Multiple columns can be selected</li> <li><code>names_from</code>: Optional, defaults to variable. The name of the newly created column whose values will contain the input DataFrame's column names.</li> <li><code>values_from</code>:  Optional, defaults to value. The name of the newly created column containing the input DataFrame's cell values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [1, 2], A = [1, 3], B = [2, 4]);\n\njulia&gt; db = connect(duckdb()); df_wide = dt(db, df, \"df\");\n\njulia&gt; @collect @pivot_longer(df_wide, A:B)\n4\u00d73 DataFrame\n Row \u2502 id     variable  value \n     \u2502 Int64  String    Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  A             1\n   2 \u2502     2  A             3\n   3 \u2502     1  B             2\n   4 \u2502     2  B             4\n\njulia&gt; @collect @pivot_longer(df_wide, A:B, names_to = \"letter\", values_to = \"number\")\n4\u00d73 DataFrame\n Row \u2502 id     letter  number \n     \u2502 Int64  String  Int64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  A            1\n   2 \u2502     2  A            3\n   3 \u2502     1  B            2\n   4 \u2502     2  B            4\n</code></pre> <p>source</p> <p># <code>TidierDB.@pivot_wider</code> \u2014 Macro.</p> <p>@pivotwider(df, namesfrom, values_from)</p> <p>Reshapes the SQL_query to make it wider, increasing the number of columns and reducing the number of rows.</p> <p><code>@pivot_wider</code> requires some eagerness to pull the disticnt values in the <code>names_from</code> columns. It will take the  query until the point of the <code>@pivot_wider</code>, and run a query to pull the disinct values in the <code>names_from</code> column</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>names_from</code>: The name of the column to get the name of the output columns from.</li> <li><code>values_from</code>: The name of the column to get the cell values from.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df_long = DataFrame(id = [1, 1, 2, 2],\n                           variable = [\"A\", \"B\", \"A\", \"B\"],\n                           value = [1, 2, 3, 4]);\n\njulia&gt; db = connect(duckdb()); dbdf = dt(db, df_long, \"df\");\n\njulia&gt; @collect @pivot_wider(dbdf, names_from = variable, values_from = value)\n2\u00d73 DataFrame\n Row \u2502 id     A      B     \n     \u2502 Int64  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1      2\n   2 \u2502     2      3      4\n\njulia&gt; future_col_names = (:variable, [:A, :B]); \n\njulia&gt; @eval @collect @pivot_wider(dbdf, names_from = $future_col_names, values_from = value)\n2\u00d73 DataFrame\n Row \u2502 id     A      B     \n     \u2502 Int64  Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      1      2\n   2 \u2502     2      3      4\n</code></pre> <p>source</p> <p># <code>TidierDB.@relocate</code> \u2014 Macro.</p> <pre><code>@relocate(sql_query, columns, before = nothing, after = nothing)\n</code></pre> <p>Rearranges the columns in the queried table. This function allows for moving specified columns to a new position within the table, either before or after a given target column. The <code>columns</code>, <code>before</code>, and <code>after</code> arguments all accept tidy selection functions. Only one of <code>before</code> or <code>after</code> should be specified. If neither are specified, the selected columns will be moved to the beginning of the table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>columns</code>: Column or columns to to be moved.</li> <li><code>before</code>: (Optional) Column or columns before which the specified columns will be moved. If not provided or <code>nothing</code>, this argument is ignored.</li> <li><code>after</code>: (Optional) Column or columns after which the specified columns will be moved. If not provided or <code>nothing</code>, this argument is ignored.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin \n        @relocate(groups, value, ends_with(\"d\"), after = percent) \n        @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 percent  groups  value  id     \n     \u2502 Float64  String  Int64  String \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     0.1  bb          1  AA\n   2 \u2502     0.2  aa          2  AB\n   3 \u2502     0.3  bb          3  AC\n   4 \u2502     0.4  aa          4  AD\n   5 \u2502     0.5  bb          5  AE\n   6 \u2502     0.6  aa          1  AF\n   7 \u2502     0.7  bb          2  AG\n   8 \u2502     0.8  aa          3  AH\n   9 \u2502     0.9  bb          4  AI\n  10 \u2502     1.0  aa          5  AJ\n\njulia&gt; @chain dt(db, df, \"df_view\") begin \n        @relocate([:percent, :groups], before = id) \n        @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 percent  groups  id      value \n     \u2502 Float64  String  String  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     0.1  bb      AA          1\n   2 \u2502     0.2  aa      AB          2\n   3 \u2502     0.3  bb      AC          3\n   4 \u2502     0.4  aa      AD          4\n   5 \u2502     0.5  bb      AE          5\n   6 \u2502     0.6  aa      AF          1\n   7 \u2502     0.7  bb      AG          2\n   8 \u2502     0.8  aa      AH          3\n   9 \u2502     0.9  bb      AI          4\n  10 \u2502     1.0  aa      AJ          5\n</code></pre> <p>source</p> <p># <code>TidierDB.@rename</code> \u2014 Macro.</p> <pre><code>@rename(sql_query, renamings...)\n</code></pre> <p>Rename one or more columns in a SQL query.</p> <p>Arguments</p> <p>-<code>sql_query</code>: The SQL query to operate on. -<code>renamings</code>: One or more pairs of old and new column names, specified as new name = old name </p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n       @rename(new_name = percent)\n       @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id      groups  value  new_name \n     \u2502 String  String  Int64  Float64  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1       0.1\n   2 \u2502 AB      aa          2       0.2\n   3 \u2502 AC      bb          3       0.3\n   4 \u2502 AD      aa          4       0.4\n   5 \u2502 AE      bb          5       0.5\n   6 \u2502 AF      aa          1       0.6\n   7 \u2502 AG      bb          2       0.7\n   8 \u2502 AH      aa          3       0.8\n   9 \u2502 AI      bb          4       0.9\n  10 \u2502 AJ      aa          5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@right_join</code> \u2014 Macro.</p> <pre><code>@right_join(sql_query, join_table, orignal_table_col == new_table_col)\n</code></pre> <p>Perform a right join between two SQL queries based on a specified condition.  Joins can be equi joins or inequality joins. For equi joins, the joining table  key column is dropped. Inequality joins can be made into AsOf or rolling joins  by wrapping the inequality in closest(key &gt;= key2). With inequality joins, the  columns from both tables are kept. Multiple joining criteria can be added, but  need to be separated by commas, ie <code>closest(key &gt;= key2), key3 == key3</code></p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table::{SQLQuery, String}</code>: The secondary SQL table to join with the primary query table. Table that exist on the database already should be written as a string of the name</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts columnss as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; dfj = dt(db, df2, \"df_join\");\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @right_join(t(dfj), id == id2)\n         @collect\n       end\n7\u00d76 DataFrame\n Row \u2502 id      groups   value    percent    category  score \n     \u2502 String  String?  Int64?   Float64?   String    Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb             1        0.1  X            88\n   2 \u2502 AC      bb             3        0.3  Y            92\n   3 \u2502 AE      bb             5        0.5  X            77\n   4 \u2502 AG      bb             2        0.7  Y            83\n   5 \u2502 AI      bb             4        0.9  X            95\n   6 \u2502 AK      missing  missing  missing    Y            68\n   7 \u2502 AM      missing  missing  missing    X            74\n\njulia&gt; query = @chain dfj begin\n                  @filter(score &gt;= 74) # only show scores above 85 in joining table\n                end;\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @right_join(t(query), id == id2)\n         @collect\n       end\n6\u00d76 DataFrame\n Row \u2502 id      groups   value    percent    category  score \n     \u2502 String  String?  Int64?   Float64?   String    Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb             1        0.1  X            88\n   2 \u2502 AC      bb             3        0.3  Y            92\n   3 \u2502 AE      bb             5        0.5  X            77\n   4 \u2502 AG      bb             2        0.7  Y            83\n   5 \u2502 AI      bb             4        0.9  X            95\n   6 \u2502 AM      missing  missing  missing    X            74\n</code></pre> <p>source</p> <p># <code>TidierDB.@select</code> \u2014 Macro.</p> <pre><code>@select(sql_query, columns)\n</code></pre> <p>Select specified columns from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: the SQL query to select columns from.</li> <li><code>columns</code>: Expressions specifying the columns to select. Columns can be specified by        - name, <code>table.name</code>       - selectors - <code>starts_with()</code>        - ranges - <code>col1:col5</code>       - excluded with <code>!</code> notation</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; df_mem = dt(db, df, \"df_view\");\n\njulia&gt; @chain df_mem begin\n         @select(groups:percent)\n         @collect\n       end\n10\u00d73 DataFrame\n Row \u2502 groups  value  percent \n     \u2502 String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 bb          1      0.1\n   2 \u2502 aa          2      0.2\n   3 \u2502 bb          3      0.3\n   4 \u2502 aa          4      0.4\n   5 \u2502 bb          5      0.5\n   6 \u2502 aa          1      0.6\n   7 \u2502 bb          2      0.7\n   8 \u2502 aa          3      0.8\n   9 \u2502 bb          4      0.9\n  10 \u2502 aa          5      1.0\n\njulia&gt; @chain df_mem begin\n         @select(contains(\"e\"))\n         @collect\n       end\n10\u00d72 DataFrame\n Row \u2502 value  percent \n     \u2502 Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1      0.1\n   2 \u2502     2      0.2\n   3 \u2502     3      0.3\n   4 \u2502     4      0.4\n   5 \u2502     5      0.5\n   6 \u2502     1      0.6\n   7 \u2502     2      0.7\n   8 \u2502     3      0.8\n   9 \u2502     4      0.9\n  10 \u2502     5      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@semi_join</code> \u2014 Macro.</p> <pre><code>@semi_join(sql_query, join_table, orignal_table_col == new_table_col)\n</code></pre> <p>Perform an semi join between two SQL queries based on a specified condition.  Joins can be equi joins or inequality joins. For equi joins, the joining table  key column is dropped. Inequality joins can be made into AsOf or rolling joins  by wrapping the inequality in closest(key &gt;= key2). With inequality joins, the  columns from both tables are kept. Multiple joining criteria can be added, but  need to be separated by commas, ie <code>closest(key &gt;= key2), key3 == key3</code></p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table::{SQLQuery, String}</code>: The secondary SQL table to join with the primary query table. Table that exist on the database already should be written as a string of the name</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.  Accepts cols as bare column names or strings</li> <li><code>new_table_col</code>: Column from the new table that matches for join.  Accepts cols as bare column names or strings</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; dfj = dt(db, df2, \"df_join\");\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @semi_join(t(dfj), id == id2)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id      groups  value  percent \n     \u2502 String  String  Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1\n   2 \u2502 AC      bb          3      0.3\n   3 \u2502 AE      bb          5      0.5\n   4 \u2502 AG      bb          2      0.7\n   5 \u2502 AI      bb          4      0.9\n</code></pre> <p>source</p> <p># <code>TidierDB.@separate</code> \u2014 Macro.</p> <pre><code>  @separate(sql_query, from_col, into_cols, sep)\n</code></pre> <p>Separate a string column into mulitiple new columns based on a specified delimter </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>from_col</code>: Column that will be split</li> <li><code>into_cols</code>: New column names, supports [] or ()</li> <li><code>sep</code>: the string or character on which to split</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame(a = [\"1-1\", \"2-2\", \"3-3-3\"]); \n\njulia&gt; @chain dt(db, df, \"df\") @separate(a, [b, c, d], \"-\") @collect\n3\u00d73 DataFrame\n Row \u2502 b       c       d       \n     \u2502 String  String  String? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 1       1       missing \n   2 \u2502 2       2       missing \n   3 \u2502 3       3       3\n\njulia&gt; @chain dt(db, df, \"df\") @separate( a, [c, d], \"-\") @collect\n3\u00d72 DataFrame\n Row \u2502 c       d      \n     \u2502 String  String \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 1       1\n   2 \u2502 2       2\n   3 \u2502 3       3-3\n</code></pre> <p>source</p> <p># <code>TidierDB.@setdiff</code> \u2014 Macro.</p> <pre><code>@setdiff(sql_query1, sql_query2, all = false)\n</code></pre> <p>Combine two SQL queries/tables using <code>EXECPT</code></p> <p>Arguments</p> <ul> <li><code>sql_query1</code>: The first SQL query to combine.</li> <li><code>sql_query2</code>: The second SQL query to combine.</li> <li><code>all</code>: Defaults to false, when true it will return duplicates. <code>EXCEPT ALL</code></li> </ul> <p>Returns</p> <ul> <li>A lazy query of all rows in the second query bound to the first</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df1 = DataFrame(id = [1, 1, 2, 2, 3, 4],\n        name = [\"Alice\", \"Alice\", \"Bob\", \"Bob\", \"Charlie\", \"David\"]);\n\njulia&gt; df2 = DataFrame(id = [2, 2, 3, 5],\n       name = [\"Bob\", \"Bob\", \"Charlie\", \"Eve\"]);\n\njulia&gt; df1_table = dt(db, df1, \"df1\"); \n\njulia&gt; df2_table = dt(db, df2, \"df2\");\n\njulia&gt; @chain df1_table @setdiff(df2_table) @collect\n2\u00d72 DataFrame\n Row \u2502 id     name   \n     \u2502 Int64  String \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  Alice\n   2 \u2502     4  David\n\njulia&gt; @chain df1_table @setdiff(df2_table, all = true) @collect\n3\u00d72 DataFrame\n Row \u2502 id     name   \n     \u2502 Int64  String \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1  Alice\n   2 \u2502     1  Alice\n   3 \u2502     4  David\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_max</code> \u2014 Macro.</p> <pre><code>@slice_max(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the largest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the largest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @slice_max(value, n = 2)\n         @arrange(groups)\n         @collect\n       end\n4\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AJ      aa          5      1.0         1\n   2 \u2502 AD      aa          4      0.4         2\n   3 \u2502 AE      bb          5      0.5         1\n   4 \u2502 AI      bb          4      0.9         2\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @slice_max(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AE      bb          5      0.5         1\n   2 \u2502 AJ      aa          5      1.0         1\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n        @filter(percent &lt; .9)\n        @slice_max(percent)\n        @collect\n       end\n1\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AH      aa          3      0.8         1\n\njulia&gt;  @chain dt(db, df, \"df_view\") begin\n         @group_by groups\n         @slice_max(percent)\n         @arrange groups\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AJ      aa          5      1.0         1\n   2 \u2502 AI      bb          4      0.9         1\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @summarize(percent_mean = mean(percent), _by = groups)\n         @slice_max(percent_mean)\n         @collect\n       end\n1\u00d73 DataFrame\n Row \u2502 groups  percent_mean  rank_col \n     \u2502 String  Float64       Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa               0.6         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_min</code> \u2014 Macro.</p> <pre><code>@slice_min(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the smallest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the smallest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @slice_min(value, n = 2)\n         @arrange(groups, percent) # arranged due to duckdb multi threading\n         @collect\n       end\n4\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa          2      0.2         2\n   2 \u2502 AF      aa          1      0.6         1\n   3 \u2502 AA      bb          1      0.1         1\n   4 \u2502 AG      bb          2      0.7         2\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @slice_min(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA      bb          1      0.1         1\n   2 \u2502 AF      aa          1      0.6         1\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @filter(percent &gt; .1)\n         @slice_min(percent)\n         @collect\n       end\n1\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa          2      0.2         1\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by groups\n         @slice_min(percent)\n         @arrange groups\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id      groups  value  percent  rank_col \n     \u2502 String  String  Int64  Float64  Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa          2      0.2         1\n   2 \u2502 AA      bb          1      0.1         1\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @summarize(percent_mean = mean(percent), _by = groups)\n         @slice_min(percent_mean)\n         @collect\n       end\n1\u00d73 DataFrame\n Row \u2502 groups  percent_mean  rank_col \n     \u2502 String  Float64       Int64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 bb               0.5         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_sample</code> \u2014 Macro.</p> <pre><code>@slice_sample(sql_query, n)\n</code></pre> <p>Randomly select a specified number of rows from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to sample</li> <li><code>n</code>: The number of rows to randomly select.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @slice_sample(n = 2)\n         @collect\n       end;\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n       @slice_sample()\n       @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarise</code> \u2014 Macro.</p> <pre><code>   @summarise(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: query to be summarized</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations.    These can specify simple aggregations like mean, sum, and count, ' or more complex expressions    involving existing column values. <code>@summarize</code>  supports all SQL database aggregate functions   as long as they are written with matching syntax</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @summarise(across((value:percent), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups  value_mean  percent_mean  value_sum  percent_sum \n     \u2502 String  Float64     Float64       Int128     Float64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa             3.0           0.6         15          3.0\n   2 \u2502 bb             3.0           0.5         15          2.5\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups  test     n     \n     \u2502 String  Float64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          3.0      5\n   2 \u2502 bb          2.5      5\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarize</code> \u2014 Macro.</p> <pre><code>   @summarize(sql_query, exprs...; _by)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to summarize</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> <li><code>_by</code>: optional argument that supports single column names, or vectors of columns to allow for grouping for the aggregatation in the macro call</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @summarise(across((ends_with(\"e\"), starts_with(\"p\")), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups  value_mean  percent_mean  value_sum  percent_sum \n     \u2502 String  Float64     Float64       Int128     Float64     \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa             3.0           0.6         15          3.0\n   2 \u2502 bb             3.0           0.5         15          2.5\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups  test     n     \n     \u2502 String  Float64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          3.0      5\n   2 \u2502 bb          2.5      5\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n                @summarise(test = sum(percent), n = n(), _by = groups)\n                @arrange(groups)\n                @collect\n              end\n2\u00d73 DataFrame\n Row \u2502 groups  test     n     \n     \u2502 String  Float64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          3.0      5\n   2 \u2502 bb          2.5      5\n</code></pre> <p>source</p> <p># <code>TidierDB.@summary</code> \u2014 Macro.</p> <pre><code>   @summary(sql_query)\n</code></pre> <p>Get summary stastics on a table or a file when using DuckDB (max, min, q1, q2, q3, avg, std, count, unique)</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL table or file to summarize</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n        @summary\n        @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@transmute</code> \u2014 Macro.</p> <pre><code>@transmute(sql_query, exprs...; _by, _frame, _order)\n</code></pre> <p>Transmute SQL table by adding new columns or modifying existing ones. Unlike <code>@mutate</code>, <code>@transmute</code> only keep columns on the left hand side of the <code>=</code>  in transmute or grouping.</p> <p>Arguments</p> <ul> <li><code>sql_query::SQLQuery</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions for mutating the table. New columns can be added or existing columns modified using <code>column_name = expression syntax</code>, where expression can involve existing columns.</li> <li><code>_by</code>: optional argument that supports single column names, or vectors of columns to allow for grouping for the transformation in the macro call</li> <li><code>_frame</code>: optional argument that allows window frames to be determined within <code>@mutate</code>. supports single digits or tuples of numbers. supports <code>desc()</code> prefix</li> <li><code>_order</code>: optional argument that allows window orders to be determined within <code>@mutate</code>. supports single columns or vectors of names</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @transmute(value = value * 4, new_col = percent^2)\n         @collect\n       end\n10\u00d72 DataFrame\n Row \u2502 value  new_col \n     \u2502 Int64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     4     0.01\n   2 \u2502     8     0.04\n   3 \u2502    12     0.09\n   4 \u2502    16     0.16\n   5 \u2502    20     0.25\n   6 \u2502     4     0.36\n   7 \u2502     8     0.49\n   8 \u2502    12     0.64\n   9 \u2502    16     0.81\n  10 \u2502    20     1.0\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n         @transmute(max = maximum(value), _by = groups)\n         @collect\n       end\n10\u00d72 DataFrame\n Row \u2502 groups  max   \n     \u2502 String  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa          5\n   2 \u2502 aa          5\n   3 \u2502 aa          5\n   4 \u2502 aa          5\n   5 \u2502 aa          5\n   6 \u2502 bb          5\n   7 \u2502 bb          5\n   8 \u2502 bb          5\n   9 \u2502 bb          5\n  10 \u2502 bb          5\n</code></pre> <p>source</p> <p># <code>TidierDB.@union</code> \u2014 Macro.</p> <pre><code>@union(sql_query1, sql_query2, all = false)\n</code></pre> <p>Combine two SQL queries using the <code>UNION</code> operator.</p> <p>Arguments</p> <ul> <li><code>sql_query1</code>: The first SQL query to combine.</li> <li><code>sql_query2</code>: The second SQL query to combine.</li> <li><code>all</code>: Defaults to false, when true it will will return duplicates. <code>UNION ALL</code></li> </ul> <p>Returns</p> <ul> <li>A lazy query of all distinct rows in the second query bound to the first</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df1 = DataFrame(id = [1, 2, 3], value = [10, 20, 30]);\n\njulia&gt; df2 = DataFrame(id = [4, 5, 6], value = [40, 50, 60]);\n\njulia&gt; df1_table = dt(db, df1, \"df1\");\n\njulia&gt; df2_table = dt(db, df2, \"df2\");\n\njulia&gt; @chain df1_table @union(df2_table) @collect\n6\u00d72 DataFrame\n Row \u2502 id     value \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10\n   2 \u2502     2     20\n   3 \u2502     3     30\n   4 \u2502     4     40\n   5 \u2502     5     50\n   6 \u2502     6     60\n\njulia&gt; @chain df1_table begin \n        @union(\"df1\", all = false)\n        @collect\n       end\n3\u00d72 DataFrame\n Row \u2502 id     value \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10\n   2 \u2502     2     20\n   3 \u2502     3     30\n\njulia&gt; @chain df1_table begin \n        @union(\"df1\", all = true) \n        @collect\n       end\n6\u00d72 DataFrame\n Row \u2502 id     value \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10\n   2 \u2502     2     20\n   3 \u2502     3     30\n   4 \u2502     1     10\n   5 \u2502     2     20\n   6 \u2502     3     30\n\njulia&gt; query = @chain df2_table @filter(value == 50);\n\njulia&gt; @chain df1_table begin \n        @mutate(id = id + 5)\n        @filter(id &gt; 6)\n        @union(t(query))\n        @collect\n       end\n3\u00d72 DataFrame\n Row \u2502 id     value \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     7     20\n   2 \u2502     8     30\n   3 \u2502     5     50\n</code></pre> <p>source</p> <p># <code>TidierDB.@union_all</code> \u2014 Macro.</p> <pre><code>@union(sql_query1, sql_query2)\n</code></pre> <p>Combine two SQL queries using the <code>UNION ALL</code> operator.</p> <p>Arguments</p> <ul> <li><code>sql_query1</code>: The first SQL query to combine.</li> <li><code>sql_query2</code>: The second SQL query to combine.</li> </ul> <p>Returns</p> <ul> <li>A lazy query of all rows in the second query bound to the first</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df1 = DataFrame(id = [1, 2, 3], value = [10, 20, 30]);\n\njulia&gt; df1_table = dt(db, df1, \"df1\");\n\njulia&gt; @chain df1_table @union_all(df1_table) @collect\n6\u00d72 DataFrame\n Row \u2502 id     value \n     \u2502 Int64  Int64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10\n   2 \u2502     2     20\n   3 \u2502     3     30\n   4 \u2502     1     10\n   5 \u2502     2     20\n   6 \u2502     3     30\n</code></pre> <p>source</p> <p># <code>TidierDB.@unite</code> \u2014 Macro.</p> <pre><code>  @unite(sql_query, new_cols, from_cols, sep, remove = true)\n</code></pre> <p>Separate a multiple columns into one new columns using a specific delimter</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>new_col</code>: New column that will recieve the combination</li> <li><code>from_cols</code>: Column names that it will combine, supports [] or ()</li> <li><code>sep</code>: the string or character that will separate the values in the new column</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; df = DataFrame( b = [\"1\", \"2\", \"3\"], c = [\"1\", \"2\", \"3\"], d = [missing, missing, \"3\"]);\n\njulia&gt; @chain dt(db, df, \"df\") @unite(new_col, (b, c, d), \"-\") @collect\n3\u00d71 DataFrame\n Row \u2502 new_col \n     \u2502 String  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 1-1\n   2 \u2502 2-2\n   3 \u2502 3-3-3\n</code></pre> <p>source</p> <p># <code>TidierDB.@unnest_longer</code> \u2014 Macro.</p> <pre><code>@unnest_longer(sql_query, columns...)\n</code></pre> <p>Unnests specified columns into longer format. This function takes multiple columns containing arrays or other nested structures and expands them into a longer format, where each element of the arrays becomes a separate row.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>columns...</code>: One or more columns containing arrays or other nested structures to be unnested.</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; DuckDB.query(db, \"\n            CREATE TABLE nt (\n                id INTEGER,\n                data ROW(a INTEGER[], b INTEGER[])\n                );\n            INSERT INTO nt VALUES\n                (1, (ARRAY[1,2], ARRAY[3,4])),\n                (2, (ARRAY[5,6], ARRAY[7,8,9])),\n                (3, (ARRAY[10,11], ARRAY[12,13]));\");\n\njulia&gt; @chain dt(db, :nt) begin \n        @unnest_wider data  \n        @unnest_longer a b \n        @collect\n       end\n7\u00d73 DataFrame\n Row \u2502 id     a        b     \n     \u2502 Int32  Int32?   Int32 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1      3\n   2 \u2502     1        2      4\n   3 \u2502     2        5      7\n   4 \u2502     2        6      8\n   5 \u2502     2  missing      9\n   6 \u2502     3       10     12\n   7 \u2502     3       11     13\n\njulia&gt; @chain dt(db, :nt) begin \n        @unnest_wider data  \n        @unnest_longer a:b \n        @collect\n       end\n7\u00d73 DataFrame\n Row \u2502 id     a        b     \n     \u2502 Int32  Int32?   Int32 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1        1      3\n   2 \u2502     1        2      4\n   3 \u2502     2        5      7\n   4 \u2502     2        6      8\n   5 \u2502     2  missing      9\n   6 \u2502     3       10     12\n   7 \u2502     3       11     13\n</code></pre> <p>source</p> <p># <code>TidierDB.@unnest_wider</code> \u2014 Macro.</p> <pre><code>@unnest_wider(sql_query, column)\n</code></pre> <p>Unnests a nested column into wider format. This function takes a column containing nested structures (e.g., rows or arrays) and expands it into separate columns.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query</li> <li><code>column</code>: The column containing nested structures to be unnested.</li> </ul> <p>Examples</p> <pre><code>julia&gt; db = connect(duckdb());\n\njulia&gt; DuckDB.query(db, \"\n        CREATE TABLE df3 (\n            id INTEGER,\n            pos ROW(lat DOUBLE, lon DOUBLE)\n        );\n        INSERT INTO df3 VALUES\n            (1, ROW(10.1, 30.3)),\n            (2, ROW(10.2, 30.2)),\n            (3, ROW(10.3, 30.1));\");\n\njulia&gt; @chain dt(db, :df3) begin\n            @unnest_wider(pos)\n            @collect\n       end\n3\u00d73 DataFrame\n Row \u2502 id     lat      lon     \n     \u2502 Int32  Float64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10.1     30.3\n   2 \u2502     2     10.2     30.2\n   3 \u2502     3     10.3     30.1 \njulia&gt; @chain dt(db, :df3) begin\n            @unnest_wider(pos, names_sep = \"_\")\n            @collect\n       end\n3\u00d73 DataFrame\n Row \u2502 id     pos_lat  pos_lon \n     \u2502 Int32  Float64  Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     1     10.1     30.3\n   2 \u2502     2     10.2     30.2\n   3 \u2502     3     10.3     30.1\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_frame</code> \u2014 Macro.</p> <pre><code>@window_frame(sql_query, args...)\n</code></pre> <p>Define the window frame for window functions in a SQL query, specifying the range of rows to include in the calculation relative to the current row.</p> <p>Arguments</p> <ul> <li><code>sqlquery::SQLQuery</code>: The SQLQuery instance to which the window frame will be applied.</li> <li> <p><code>args...</code>: A variable number of arguments specifying the frame boundaries. These can be:</p> <ul> <li><code>from</code>: The starting point of the frame. Can be a positive or negative integer, 0 or empty. When empty, it will use UNBOUNDED</li> <li><code>to</code>: The ending point of the frame. Can be a positive or negative integer,  0 or empty. When empty, it will use UNBOUNDED</li> <li>if only one integer is provided without specifying <code>to</code> or <code>from</code> it will default to from, and to will be UNBOUNDED.</li> <li>if no arguments are given, both will be UNBOUNDED</li> </ul> </li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; df_mem = dt(db, df, \"df_view\");\n\njulia&gt; @chain df_mem begin\n        @group_by groups\n        @window_frame(3)\n        @mutate(avg = mean(percent))\n        #@show_query\n       end;\n\njulia&gt; @chain df_mem begin\n        @group_by groups\n        @window_frame(-3, 3)\n        @mutate(avg = mean(percent))\n        #@show_query\n       end;\n\njulia&gt; @chain df_mem begin\n        @group_by groups\n        @window_frame(to = -3)\n        @mutate(avg = mean(percent))\n        #@show_query\n        @collect\n       end;\n\njulia&gt; @chain df_mem begin\n        @group_by groups\n        @window_frame(from = -3)\n        @mutate(avg = mean(percent))\n        #@show_query\n        @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_order</code> \u2014 Macro.</p> <pre><code>   @window_order(sql_query, columns...)\n</code></pre> <p>Specify the order of rows for window functions within a SQL query.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by for the window function. Can include multiple columns for nested sorting. Prepend a column name with - for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\n\njulia&gt; @chain dt(db, df, \"df_view\") begin\n        @group_by groups\n        @window_frame(3)\n        @window_order(desc(percent))\n        @mutate(avg = mean(value))\n       #@show_query \n       end;\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":"<p># <code>TidierDB.aggregate_and_window_functions</code> \u2014 Method.</p> <pre><code>   Aggregate and Window Functions\n</code></pre> <p>Nearly all aggregate functions from any database are supported both <code>@summarize</code> and <code>@mutate</code>. </p> <p>With <code>@summarize</code>, an aggregate functions available on a SQL backend can be used as they are in sql with the same syntax (<code>'</code> should be replaced with <code>\"</code>)</p> <p><code>@mutate</code> supports them as well, however, unless listed below, the function call must be wrapped with <code>agg()</code></p> <ul> <li>Aggregate Functions: <code>maximum</code>, <code>minimum</code>, <code>mean</code>, <code>std</code>, <code>sum</code>, <code>cumsum</code>, <code>count</code></li> <li>Window Functions: <code>lead</code>, <code>lag</code>, <code>dense_rank</code>, <code>nth_value</code>, <code>ntile</code>, <code>rank_dense</code>, <code>row_number</code>, <code>first_value</code>, <code>last_value</code>, <code>cume_dist</code></li> </ul> <p>If a function is needed regularly, instead of wrapping it in <code>agg</code>, it can also be added to <code>window_agg_fxns</code> with <code>push!</code> as demonstrated below</p> <p>The list of DuckDB aggregate functions and their syntax can be found here Please refer to your backend documentation for a complete list with syntac, but open an issue on TidierDB if your run into roadblocks.  </p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                value1 = [i - 4^1 for i in -4.5:4.5], \n                value2 = [i + 2^i for i in 1:10], \n                percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(duckdb());\n\njulia&gt; @chain dt(db, df, \"df_agg\") begin\n         @summarise(\n             r2 = regr_r2(value2, value1),\n             across(contains(\"value\"), median), \n             _by = groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d74 DataFrame\n Row \u2502 groups  r2        value1_median  value2_median \n     \u2502 String  Float64   Float64        Float64       \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa      0.700161           -3.5           70.0\n   2 \u2502 bb      0.703783           -4.5           37.0\n\njulia&gt; @chain dt(db, df, \"df_agg\") begin\n         @mutate(\n            slope = agg(regr_slope(value1, value2)),\n            var = agg(var_samp(value2)),\n            std = std(value2), # since this is in the list above, it does not get wrapped in `agg`\n            _by = groups\n         )\n         @mutate(var = round(var))\n         @select !percent\n         @arrange(groups)\n         @collect\n       end\n10\u00d77 DataFrame\n Row \u2502 id      groups  value1   value2  slope       var       std     \n     \u2502 String  String  Float64  Int64   Float64     Float64   Float64 \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa         -7.5       6  0.00608835  188885.0  434.609\n   2 \u2502 AD      aa         -5.5      20  0.00608835  188885.0  434.609\n   3 \u2502 AF      aa         -3.5      70  0.00608835  188885.0  434.609\n   4 \u2502 AH      aa         -1.5     264  0.00608835  188885.0  434.609\n   5 \u2502 AJ      aa          0.5    1034  0.00608835  188885.0  434.609\n   6 \u2502 AA      bb         -8.5       3  0.0121342    47799.0  218.629\n   7 \u2502 AC      bb         -6.5      11  0.0121342    47799.0  218.629\n   8 \u2502 AE      bb         -4.5      37  0.0121342    47799.0  218.629\n   9 \u2502 AG      bb         -2.5     135  0.0121342    47799.0  218.629\n  10 \u2502 AI      bb         -0.5     521  0.0121342    47799.0  218.629\n\njulia&gt; push!(TidierDB.window_agg_fxns, :regr_slope);\n\njulia&gt; @chain dt(db, df, \"df_agg\") begin\n         @mutate(\n            slope = regr_slope(value1, value2), # no longer wrapped in `agg` following the above\n            _by = groups\n         )\n         @select !percent\n         @arrange(groups)\n         @collect\n       end\n10\u00d75 DataFrame\n Row \u2502 id      groups  value1   value2  slope      \n     \u2502 String  String  Float64  Int64   Float64    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB      aa         -7.5       6  0.00608835\n   2 \u2502 AD      aa         -5.5      20  0.00608835\n   3 \u2502 AF      aa         -3.5      70  0.00608835\n   4 \u2502 AH      aa         -1.5     264  0.00608835\n   5 \u2502 AJ      aa          0.5    1034  0.00608835\n   6 \u2502 AA      bb         -8.5       3  0.0121342\n   7 \u2502 AC      bb         -6.5      11  0.0121342\n   8 \u2502 AE      bb         -4.5      37  0.0121342\n   9 \u2502 AG      bb         -2.5     135  0.0121342\n  10 \u2502 AI      bb         -0.5     521  0.0121342\n</code></pre> <p>source</p>"},{"location":"examples/generated/UserGuide/Snowflake/","title":"Using Snowflake","text":"<p>Establishing a connection with the Snowflake SQL Rest API requires a OAuth token specific to the Role the user will use to query tables with.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/Snowflake/#connecting","title":"Connecting","text":"<p>Connection is established with the <code>connect</code> function as shown below. Connection requires 5 items as strings</p> <ul> <li>Account Identifier</li> <li>OAuth token</li> <li>Database Name</li> <li>Schema Name</li> <li>Compute Warehouse name</li> </ul> <p>Two things to note:</p> <ul> <li>Your OAuth Token may frequently expire, which may require you to rerun your connection line.</li> <li> <p>Since each time <code>dt</code> runs, it runs a query to pull the metadata, you may choose to use run <code>dt</code> and save the results.</p> <ul> <li>This will reduce the number of queries to your database</li> <li>Allow you to build a a SQL query and <code>@show_query</code> even if the OAuth_token has expired. To <code>@collect</code> you will have to reconnect and rerun <code>dt</code> if your OAuth token has expired</li> </ul> </li> </ul> <pre><code>set_sql_mode(snowflake())\nac_id = \"string_id\"\ntoken = \"OAuth_token_string\"\ncon = connect(:snowflake, ac_id, token, \"DEMODB\", \"PUBLIC\", \"COMPUTE_WH\")\n# After connection is established, a you may begin querying.\ntable = dt(con, \"MTCARS\")\n@chain table begin\n   @select(WT)\n   @mutate(TEST = WT *2)\n   #@aside @show_query _\n   @collect\nend\n</code></pre> <pre><code>32\u00d72 DataFrame\n Row \u2502 WT       TEST\n     \u2502 Float64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502   2.62     5.24\n   2 \u2502   2.875    5.75\n   3 \u2502   2.32     4.64\n   4 \u2502   3.215    6.43\n  \u22ee  \u2502    \u22ee        \u22ee\n  29 \u2502   3.17     6.34\n  30 \u2502   2.77     5.54\n  31 \u2502   3.57     7.14\n  32 \u2502   2.78     5.56\n         24 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/agg_window/","title":"Aggregate and Window Functions","text":"<p>TidierDB supports all aggregate functions accross the supported databases, as well as window functions.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/agg_window/#aggregate-functions","title":"Aggregate Functions","text":"<p><code>@summarize</code>, by default, supports all aggregate functions built into a SQL database, with the exception that any <code>'</code> that would be used in SQL should be replaced wiht <code>\"</code>.</p> <pre><code>using TidierDB\ndb = connect(duckdb());\nmtcars_path = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\";\nmtcars = dt(db, mtcars_path);\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/agg_window/#aggregate-functions-in-summarize","title":"Aggregate Functions in <code>@summarize</code>","text":"<p>Lets use the DuckDB <code>kurtosis</code> aggregate function</p> <pre><code>@chain mtcars begin\n     @group_by cyl\n     @summarize(kurt = kurtosis(mpg))\n     @collect\nend\n</code></pre> 3\u00d72 DataFrame RowcylkurtInt64Float6416-1.8294424-1.43411380.330061 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/agg_window/#aggregate-functions-in-mutate","title":"Aggregate Functions in <code>@mutate</code>","text":"<p>By default, <code>@mutate</code>/<code>@transmute</code> supports (however, you can easily expand this list)</p> <ul> <li><code>maximum</code>, <code>minimum</code>, <code>mean</code>, <code>std</code>, <code>sum</code>, <code>cumsum</code></li> </ul> <p>To use aggregate sql functions that are built in to any database backend, but exist outside of the TidierDB parser list above, simply wrap the function call in <code>agg()</code></p> <pre><code>@chain mtcars begin\n     @group_by(cyl)\n     @mutate(kurt = agg(kurtosis(mpg)))\n     @select cyl mpg kurt\n     @head()\n     @collect\nend\n</code></pre> 6\u00d73 DataFrame RowcylmpgkurtInt64Float64Float641621.0-1.829442621.0-1.829443621.4-1.829444618.1-1.829445619.2-1.829446617.8-1.82944 <p>Alternatively , if you anticipate regularly using specific aggregate functions, you can update the underlying parser avoid using <code>agg</code> all together</p> <pre><code>push!(TidierDB.window_agg_fxns, :kurtosis);\n@chain mtcars begin\n     @group_by(cyl)\n     @mutate(kurt = kurtosis(mpg))\n     @select cyl mpg kurt\n     @head()\n     @collect\nend\n</code></pre> 6\u00d73 DataFrame RowcylmpgkurtInt64Float64Float641621.0-1.829442621.0-1.829443621.4-1.829444618.1-1.829445619.2-1.829446617.8-1.82944 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/agg_window/#window-functions","title":"Window Functions","text":"<p>TidierDB's <code>@mutate</code>/<code>@transmute</code> support all of the window functions below</p> <ul> <li><code>lead</code>, <code>lag</code>, <code>dense_rank</code>, <code>nth_value</code>, <code>ntile</code>, <code>rank_dense</code>, <code>row_number</code>, <code>first_value</code>, <code>last_value</code>, <code>cume_dist</code></li> </ul> <p>When ordering a window function, <code>@arrange</code> should not be used. Rather, use <code>@window_order</code> or, preferably, <code>_order</code> and <code>_frame</code> in <code>@mutate</code>.</p> <pre><code>@chain mtcars begin\n    @mutate(row_id = row_number(),\n        _by = cyl,\n        _order = mpg # _frame is not used in this example\n        )\n    @head()\n    @collect\nend\n</code></pre> 6\u00d713 DataFrame Rowmodelmpgcyldisphpdratwtqsecvsamgearcarbrow_idStringFloat64Int64Float64Int64Float64Float64Float64Int64Int64Int64Int64Int641Merc 280C17.86167.61233.923.4418.9104412Valiant18.16225.01052.763.4620.22103123Merc 28019.26167.61233.923.4418.3104434Ferrari Dino19.76145.01753.622.7715.5015645Mazda RX421.06160.01103.92.6216.46014456Mazda RX4 Wag21.06160.01103.92.87517.0201446 <p>The above query could have alternatively been written as</p> <pre><code>@chain mtcars begin\n    @group_by cyl\n    @window_order mpg\n    @mutate(row_id = row_number())\n    @head()\n    @collect\nend\n</code></pre> 6\u00d713 DataFrame Rowmodelmpgcyldisphpdratwtqsecvsamgearcarbrow_idStringFloat64Int64Float64Int64Float64Float64Float64Int64Int64Int64Int64Int641Merc 280C17.86167.61233.923.4418.9104412Valiant18.16225.01052.763.4620.22103123Merc 28019.26167.61233.923.4418.3104434Ferrari Dino19.76145.01753.622.7715.5015645Mazda RX421.06160.01103.92.6216.46014456Mazda RX4 Wag21.06160.01103.92.87517.0201446 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/athena/","title":"Using Athena","text":"<p>To use the Athena AWS backend with TidierDB, set up and a small syntax difference are covered here.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#connecting","title":"Connecting","text":"<p>Connection is established through AWS.jl as shwon below.</p> <pre><code>using TidierDB, AWS\nset_sql_mode(athena())\n# Replace your credentials as needed below\naws_access_key_id = get(ENV,\"AWS_ACCESS_KEY_ID\",\"key\")\naws_secret_access_key = get(ENV, \"AWS_SECRET_ACCESS_KEY\",\"secret_key\")\naws_region = get(ENV,\"AWS_DEFAULT_REGION\",\"region\")\n\nconst AWS_GLOBAL_CONFIG = Ref{AWS.AWSConfig}()\ncreds = AWSCredentials(aws_access_key_id, aws_secret_access_key)\n\nAWS_GLOBAL_CONFIG[] = AWS.global_aws_config(region=aws_region, creds=creds)\n\ncatalog = \"AwsDataCatalog\"\nworkgroup = \"primary\"\ndb = \"demodb\"\nall_results = true\nresults_per_increment = 10\nout_loc = \"s3://location/\"\n\nathena_params = Dict(\n    \"ResultConfiguration\" =&gt; Dict(\n        \"OutputLocation\" =&gt; out_loc\n    ),\n    \"QueryExecutionContext\" =&gt; Dict(\n        \"Database\" =&gt; db,\n        \"Catalog\" =&gt; catalog\n    ),\n    \"Workgroup\" =&gt; workgroup\n)\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#dt-differences","title":"<code>dt</code> differences","text":"<p>There are two differences for <code>dt</code> which are seen in the query below</p> <ol> <li>The table needs to be passed as a string in the format database.table, ie <code>\"demodb.table_name</code></li> <li><code>dt</code> requires a third argument: the athena_params from above.</li> </ol> <p>I would like to acknowledge the work of Manu Francis and this blog post, which helped guide this process</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/databricks/","title":"Using Databricks","text":"<p>Establishing a connection with the Databricks SQL Rest API requires a token.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/databricks/#connecting","title":"Connecting","text":"<p>Connection is established with the <code>connect</code> function as shown below. Connection requires 5 items as strings</p> <ul> <li>Account Instance : how to find your instance</li> <li>OAuth token : how to generate your token</li> <li>Database Name</li> <li>Schema Name</li> <li>warehouse_id</li> </ul> <p>One thing to note, Since each time <code>dt</code> runs, it runs a query to pull the metadata, you may choose to use run <code>dt</code> and save the results.</p> <pre><code>set_sql_mode(databricks())\ninstance_id = \"string_id\"\ntoken \"string_token\"\nwarehouse_id = \"e673cd4f387f964a\"\ncon = connect(:databricks, instance_id, token, \"DEMODB\", \"PUBLIC\", warehouse_id)\n# After connection is established, a you may begin querying.\nstable_table_metadata = dt(con, \"mtcars\")\n@chain stable_table_metadata begin\n   @select(wt)\n   @mutate(test = wt *2)\n   #@aside @show_query _\n   @collect\nend\n</code></pre> <pre><code>32\u00d72 DataFrame\n Row \u2502 wt       test\n     \u2502 Float64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502   2.62     5.24\n   2 \u2502   2.875    5.75\n   3 \u2502   2.32     4.64\n   4 \u2502   3.215    6.43\n  \u22ee  \u2502    \u22ee        \u22ee\n  29 \u2502   3.17     6.34\n  30 \u2502   2.77     5.54\n  31 \u2502   3.57     7.14\n  32 \u2502   2.78     5.56\n         24 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/dates/","title":"Dates","text":"<p>TidierDB supports working many of the functions in TidierDates, and identical syntax to parts of Dates.jl.</p> <pre><code>using TidierDB\ndates_df = DataFrame(date_strings = [\"2024-01-01\", \"2025-02-01\", \"2023-03-01\", \"2022-04-01\"]);\ndb = connect(duckdb());\ndates = dt(db, dates_df, \"dates_df\");\n</code></pre> <p>TidierDB supports <code>ymd</code>, <code>dmy</code> and and <code>mdy</code> to convert strings in that format to dates.</p> <ul> <li> <p>To extract a date part use the name of that date part with in lower case.</p> <ul> <li><code>year(date_col)</code></li> <li> <p>To add date intervals, similar to Dates.jl, use the date part but with a capital first letter.</p> </li> <li> <p><code>+ Year(4)</code></p> </li> </ul> </li> </ul> <pre><code>@chain dates begin\n    @mutate(dates2 = ymd(date_strings) + Month(4) + Year(1) - Day(10))\n    @mutate begin\n        months = month(dates2)\n        day = day(dates2)\n    end\n    @filter year(dates2) == 2024\n    @aside @show_query _\n    @collect\nend\n</code></pre> 1\u00d74 DataFrame Rowdate_stringsdates2monthsdayStringDateTimeInt64Int6412023-03-012024-06-21T00:00:00621 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/","title":"Reproduce a duckplyr example","text":"<p>In this example, we will reproduce a DuckDB and duckplyr blog post example to demonstrate TidierDB's v0.5.0 capability.</p> <p>The example by Hannes that is being reproduced is exploring Open Data from the New Zealand government that is ~ 1GB.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/#set-up","title":"Set up","text":"<p>First we will set up the local duckdb database and pull in the metadata for the files. Notice we are not reading this data into memory, only the paths and and column, and table names. To follow along, copy the set up code below after downloading the data, but add the directory to the local data.</p> <pre><code>import TidierDB as DB\ndb = DB.connect(DB.duckdb())\n\ndir = \"/Downloads/nzcensus/\"\ndata   = dir * \"Data8277.csv\"\nage    = dir * \"DimenLookupAge8277.csv\"\narea   = dir * \"DimenLookupArea8277.csv\"\nethnic = dir * \"DimenLookupEthnic8277.csv\"\nsex    = dir * \"DimenLookupSex8277.csv\"\nyear   = dir * \"DimenLookupYear8277.csv\"\n\ndata = DB.dt(db, data);\nage = DB.dt(db, age);\narea = DB.dt(db, area);\nethnic = DB.dt(db, ethnic);\nsex = DB.dt(db, sex);\nyear = DB.dt(db, year);\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/#exploration","title":"Exploration","text":"<p>While this long chain could be broken up into multiple smaller chains, lets reproduce the duckplyr code from example and demonstrate how TidierDB also supports multiple joins after filtering, mutating, etc the joining tables. 6 different tables are being joined together through sequential inner joins.</p> <pre><code>@chain data begin\n  DB.@filter(str_detect(count, r\"^\\d+$\"))\n  DB.@mutate(count_ = as_integer(count))\n  DB.@filter(count_ &gt; 0)\n  DB.@inner_join(\n    (@chain age begin\n    DB.@filter(str_detect(Description, r\"^\\d+ years$\"))\n    DB.@mutate(age_ = as_integer(str_remove(Code, \"years\"))) end),\n    Age == Code\n  )\n  DB.@inner_join((@chain year DB.@mutate(year_ = Description)), year == Code)\n  DB.@inner_join((@chain area begin\n    DB.@mutate(area_ = Description)\n    DB.@filter(!str_detect(area_, r\"^Total\"))\n  end)\n    , Area == Code)\n    DB.@inner_join((@chain ethnic begin\n      DB.@mutate(ethnic_ = Description)\n      DB.@filter(!str_detect( ethnic_, r\"^Total\",)) end), Ethnic == Code)\n  DB.@inner_join((@chain sex begin\n    DB.@mutate(sex_ = Description)\n    DB.@filter(!str_detect( sex_, r\"^Total\"))\n  end)\n   , Sex == Code)\n  DB.@inner_join((@chain year DB.@mutate(year_ = Description)), Year == Code)\n  @aside DB.@show_query _\n  DB.@create_view(joined_up)\nend\n\n@chain DB.dt(db, \"joined_up\") begin\n  DB.@filter begin\n    age_ &gt;= 20\n    age_ &lt;= 40\n    str_detect(area_, r\"^Auckland\")\n    year_ == \"2018\"\n    ethnic_ != \"European\"\n    end\n  DB.@group_by sex_\n  DB.@summarise(group_count = sum(count_))\n  DB.@collect\nend\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/duckplyr_reprex/#results","title":"Results","text":"<p>When we collect this to a local dataframe, we can see that the results match the duckplyr/DuckDB example.</p> <pre><code>2\u00d72 DataFrame\n Row \u2502 sex_    group_count\n     \u2502 String  Int128\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Female       398556\n   2 \u2502 Male         397326\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/ex_joining/","title":"Joining Tables","text":"<p>TidierDB supports mutliple join types including equi-joins, nonequi-joins, and as of or rolling joins.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#general-syntax","title":"General Syntax","text":"<p>All joins share the same argument format</p> <ul> <li><code>*_join(query, join_table, joining_keys...)</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#equi-joins","title":"Equi Joins","text":"<p>Equi joins can be written in any of the following ways, and the key column will be dropped from the right hand (new) table to avoid duplication.</p> <ul> <li><code>@left_join(t(table), \"table2\", key_col)</code></li> <li><code>@left_join(t(table), \"table2\", key_col = key_col2)</code></li> </ul> <p>To join mutliple columns, separate the different pairs with a <code>,</code></p> <ul> <li><code>@left_join(t(table), \"table2\", key_col == key_col2, key2 == key2)</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#inequality-joins","title":"Inequality Joins","text":"<p>Inequality joins or non-equi-joins use the same syntax, just with a inequality operators</p> <ul> <li><code>@left_join(t(table), \"table2\", key_col &gt;= key_col2, key2 &lt; key2)</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#asof","title":"AsOf","text":"<p>To use an AsOf or rolling join, simply wrap the inequality in `closest. Of note, at this time, only one inequality can be supported at a time with AsOf joins</p> <ul> <li><code>@left_join(t(table), \"table2\", closest(key_col &gt;= key_col2), key2 == key2)</code></li> </ul> <p>When the joining table is already availabe on the database, a string of the table name used as shown above. However, the joining table can also be a TidierDB query, in which case, the query is written as follows</p> <ul> <li><code>@left_join(t(table),query, key)</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#examples","title":"Examples","text":"<p>Examples below will cover how to join tables with different schemas in different databases, and how to write queries on tables and then join them together, and how to do this by levaraging views. Some examples</p> <pre><code>using TidierDB\ndb = connect(duckdb())\nmtcars = dt(db, \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\")\n</code></pre> <pre><code>SQLQuery(\"\", \"'https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv' AS mtcars \", \"\", \"\", \"\", \"\", \"\", \"\", false, false, false, 12\u00d74 DataFrame\n Row \u2502 name    type     current_selxn  table_name\n     \u2502 String  String   Int64          SubString\u2026\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 model   VARCHAR              1  mtcars\n   2 \u2502 mpg     DOUBLE               1  mtcars\n   3 \u2502 cyl     BIGINT               1  mtcars\n   4 \u2502 disp    DOUBLE               1  mtcars\n   5 \u2502 hp      BIGINT               1  mtcars\n   6 \u2502 drat    DOUBLE               1  mtcars\n   7 \u2502 wt      DOUBLE               1  mtcars\n   8 \u2502 qsec    DOUBLE               1  mtcars\n   9 \u2502 vs      BIGINT               1  mtcars\n  10 \u2502 am      BIGINT               1  mtcars\n  11 \u2502 gear    BIGINT               1  mtcars\n  12 \u2502 carb    BIGINT               1  mtcars, false, DuckDB.DB(\":memory:\"), TidierDB.CTE[], 0, nothing, \"\", \"\", 0, false, false, false, false)\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#wrangle-tables-and-self-join","title":"Wrangle tables and self join","text":"<pre><code>query = @chain mtcars begin\n    @group_by cyl\n    @summarize begin\n        across(mpg, (mean, minimum, maximum))\n        num_cars = n()\n        end\n    @mutate begin\n        efficiency = case_when(\n            mpg_mean &gt;= 25, \"High\",\n            mpg_mean &gt;= 15, \"Moderate\",\n            \"Low\" )\n      end\nend;\n\nquery2 = @chain mtcars @filter(mpg&gt;20) @mutate(mpg = mpg *4);\n\n@chain query begin\n    @left_join(t(query2), cyl == cyl)\n    @summarize(avg_mean = mean(mpg), _by = efficiency)\n    @mutate(mean = avg_mean / 4 )\n    @collect\nend\n</code></pre> 2\u00d73 DataFrame Rowefficiencyavg_meanmeanStringFloat64Float641Moderate84.533321.13332High106.65526.6636"},{"location":"examples/generated/UserGuide/ex_joining/#different-schemas","title":"Different schemas","text":"<p>To connect to a table in a different schema, prefix it with a dot. For example, \"schemaname.tablename\". In this query, we are also filtering out cars that contain \"M\" in the name from the <code>mt2</code> table before joining.</p> <pre><code>mt2 = dt(db, \"ducks_db.mt2\")\nother_db = @chain dt(db, \"ducks_db.mt2\") @filter(!str_detect(car, \"M\"))\n@chain mtcars begin\n    @left_join(t(other_db), model == car)\n    @select(model, fuel_efficiency)\n    @head(5)\n    @collect\nend\n</code></pre> <pre><code>5\u00d72 DataFrame\n Row \u2502 model              fuel_efficiency\n     \u2502 String             Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Datsun 710                      24\n   2 \u2502 Hornet 4 Drive                  18\n   3 \u2502 Hornet Sportabout               16\n   4 \u2502 Valiant                         15\n   5 \u2502 Duster 360                      14\n</code></pre> <p>To join directly to the table, you can use the <code>@left_join</code> macro with the table name as a string.</p> <pre><code>@chain mtcars begin\n    @left_join(\"ducks_db.mt2\", model == car)\n    @select(model, fuel_efficiency)\n    @head(5)\n    @collect\nend\n</code></pre> <pre><code>5\u00d72 DataFrame\n Row \u2502 model              fuel_efficiency\n     \u2502 String             Int64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Datsun 710                      24\n   2 \u2502 Hornet 4 Drive                  18\n   3 \u2502 Hornet Sportabout               16\n   4 \u2502 Valiant                         15\n   5 \u2502 Duster 360                      14\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#using-a-view","title":"Using a View","text":"<p>You can also use <code>@create_view</code> to create views and then join them. This is an alternate reuse complex queries.</p> <pre><code>@chain mtcars begin\n    @group_by cyl\n    @summarize begin\n        across(mpg, (mean, minimum, maximum))\n        num_cars = n()\n        end\n    @mutate begin\n        efficiency = case_when(\n            mpg_mean &gt;= 25, \"High\",\n            mpg_mean &gt;= 15, \"Moderate\",\n            \"Low\" )\n      end\n    @create_view(viewer)\nend;\n\n@chain dt(db, \"viewer\") begin # access the view like any other table\n    @left_join(t(query2), cyl == cyl)\n    @summarize(avg_mean = mean(mpg), _by = efficiency)\n    @mutate(mean = avg_mean / 4 )\n    @collect\nend\n</code></pre> 2\u00d73 DataFrame Rowefficiencyavg_meanmeanStringFloat64Float641Moderate84.533321.13332High106.65526.6636 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ex_joining/#asofrolling-join","title":"AsOf/Rolling join","text":"<p>This example reproduces an example in the DuckDB Docs</p> <pre><code>prices = dt(db, \"https://duckdb.org/data/prices.csv\", \"prices\");\nholdings = dt(db, \"https://duckdb.org/data/holdings.csv\", \"holdings\");\n@chain holdings begin\n    @inner_join(t(prices), ticker = ticker, closest(when &gt;= when))\n    @select(holdings.ticker, holdings.when)\n    @mutate(value = price * shares)\n    @collect\n end\n</code></pre> 4\u00d73 DataFrame RowtickerwhenvalueStringDateTimeFloat641APPL2001-01-01T00:00:302.942APPL2001-01-01T00:01:3048.263GOOG2001-01-01T00:00:3023.454GOOG2001-01-01T00:01:3021.16 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/file_reading/","title":"File Reading/Writing","text":"<p>Leveraging DuckDB, TidierDB works with multiple file types. In most cases, <code>dt</code> (or <code>db_table</code>) will automatically detect the file type to read in the table metadata.</p> <p>[!NOTE] <code>dt</code> does not copy anything into memory beyond the table metadata.</p> <p>A non exhaustive list of file types include:</p> <ul> <li>csv, tsv, txt:  <code>dt(db, \"https://file/path/to.csv\")</code></li> <li>parquet: <code>dt(db, \"or/a/local/file/path/to.parquet\")</code></li> <li>json: <code>dt(db, \"any/file/path/to.json\")</code></li> <li>S3 buckets</li> <li>iceberg and delta - require additional args <code>delta</code> or <code>iceberg</code> to be set to <code>true</code></li> <li>Google Sheets (first run <code>connect(db, :gsheets)</code>)</li> <li>.sas7bdat, .xpt, .sav, .zsav, .por, .dta : <code>dt(db, \"any/file/path/to.sav\")</code></li> </ul> <p><code>dt</code> also supports directly using DuckDB file reading function. This enables easily reading in compressed files</p> <p>When reading in a compresssed path, adding an <code>alias</code> is recommended.</p> <ul> <li><code>dt(db, \"read_csv('/Volumes/Untitled/phd_*_genlab.txt', ignore_errors=true)\", alias = \"genlab\")</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/file_reading/#file-writing","title":"File Writing","text":"<p>TidierDB also supports writing querys to local files via the DuckDB backend with <code>write_file</code>, which simply accepts a path with the file type ending</p> <ul> <li><code>write_file(sql_query, \"path/to/lcal/file.parquet\")</code></li> </ul> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/from_queryex/","title":"Reusing a Query and Views","text":"<p>While using TidierDB, you may need to generate part of a query and reuse it multiple times. There are two ways to do this</p> <ol> <li>saving the query</li> <li><code>@create_view(name)</code></li> </ol> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/from_queryex/#setup","title":"Setup","text":"<pre><code>using TidierDB\ncon = connect(duckdb());\nmtcars_path = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\";\nmtcars = dt(con, mtcars_path);\n</code></pre> <p>Start a query to analyze fuel efficiency by number of cylinders. However, to further build on this query later, end the chain without using <code>@show_query</code> or <code>@collect</code></p> <pre><code>query = @chain mtcars begin\n    @group_by cyl\n    @summarize begin\n        across(mpg, (mean, minimum, maximum))\n        num_cars = n()\n        end\n    @mutate begin\n        efficiency = case_when(\n            mpg_mean &gt;= 25, \"High\",\n            mpg_mean &gt;= 15, \"Moderate\",\n            \"Low\" )\n    end\nend;\n\n@chain query begin\n   @left_join(mtcars, cyl)\n   @group_by(efficiency)\n   @summarize(avg_hp = mean(hp))\n   @collect\nend\n\n@chain query begin\n    @summarize(avg_hp = mean(hp))\nend\n</code></pre> <pre><code>SQLQuery(\"SELECT AVG(hp) AS avg_hp\", \"cte_2\", \"\", \"\", \"\", \"\", \"\", \"\", true, true, false, 18\u00d74 DataFrame\n Row \u2502 name         type     current_selxn  table_name\n     \u2502 String       String   Int64          SubString\u2026\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 model        VARCHAR              0  mtcars\n   2 \u2502 mpg          DOUBLE               0  mtcars\n   3 \u2502 cyl          BIGINT               0  mtcars\n   4 \u2502 disp         DOUBLE               0  mtcars\n   5 \u2502 hp           BIGINT               0  mtcars\n   6 \u2502 drat         DOUBLE               0  mtcars\n   7 \u2502 wt           DOUBLE               0  mtcars\n   8 \u2502 qsec         DOUBLE               0  mtcars\n  \u22ee  \u2502      \u22ee          \u22ee           \u22ee                        \u22ee\n  12 \u2502 carb         BIGINT               0  mtcars\n  13 \u2502 mpg_mean     UNKNOWN              0  'https://gist.githubusercontent.\u2026\n  14 \u2502 mpg_minimum  UNKNOWN              0  'https://gist.githubusercontent.\u2026\n  15 \u2502 mpg_maximum  UNKNOWN              0  'https://gist.githubusercontent.\u2026\n  16 \u2502 num_cars     UNKNOWN              0  'https://gist.githubusercontent.\u2026\n  17 \u2502 efficiency   UNKNOWN              0  cte_2\n  18 \u2502 avg_hp       UNKNOWN              1  cte_2\n                                                                3 rows omitted, false, DuckDB.DB(\":memory:\"), TidierDB.CTE[TidierDB.CTE(\"cte_1\", \" SELECT cyl, AVG(mpg) AS mpg_mean, MIN(mpg) AS mpg_minimum, MAX(mpg) AS mpg_maximum, ***COUNT(*)*** AS num_cars FROM 'https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv' AS mtcars  GROUP BY cyl\", \"\", \"\", \"\", \"\"), TidierDB.CTE(\"cte_2\", \" cyl, mpg_mean, mpg_minimum, mpg_maximum, num_cars, CASE WHEN mpg_mean &gt;= 25 THEN 'High' WHEN mpg_mean &gt;= 15 THEN 'Moderate' ELSE 'Low' END AS efficiency FROM cte_1 \", \"\", \"\", \"\", \"\")], 2, nothing, \"\", \"\", 0, false, true, false, false)\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/from_queryex/#create_view","title":"@create_view","text":"<p>Queries can also be reused as views. This can be especially helpful when joining complex queries together, however, it is not necessary.</p> <pre><code>query2 = @chain mtcars @filter(mpg&gt;20) @mutate(mpg = mpg *4);\n@chain mtcars begin\n    @group_by cyl\n    @summarize begin\n        across(mpg, (mean, minimum, maximum))\n        num_cars = n()\n        end\n    @mutate begin\n        efficiency = case_when(\n            mpg_mean &gt;= 25, \"High\",\n            mpg_mean &gt;= 15, \"Moderate\",\n            \"Low\" )\n        end\n    @create_view(viewer)\nend;\n\n@chain dt(con, \"viewer\") begin\n    @left_join(query2, cyl == cyl)\n    @summarize(avg_mean = mean(mpg), _by = efficiency)\n    @mutate(mean = avg_mean / 4 )\n    @collect\nend\n</code></pre> 2\u00d73 DataFrame Rowefficiencyavg_meanmeanStringFloat64Float641Moderate84.533321.13332High106.65526.6636 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/from_queryex/#preview-or-save-an-intermediate-table","title":"Preview or save an intermediate table","text":"<p>While querying a dataset, you may wish to see an intermediate table, or even save it. You can use <code>@aside</code> and <code>_</code>, illustrated below, to do just that. While we opted to print the results in this simple example below, we could have saved them by using <code>name = @chain...</code></p> <pre><code>import ClickHouse;\nconn = conn = connect(clickhouse(); host=\"localhost\", port=19000, database=\"default\", user=\"default\", password=\"\")\npath = \"https://huggingface.co/datasets/maharshipandya/spotify-tracks-dataset/resolve/refs%2Fconvert%2Fparquet/default/train/0000.parquet\"\n@chain dt(conn, path) begin\n   @count(artists)\n   @aside println(@chain _ @head(5) @collect)\n   @arrange(desc(count))\n   @collect\nend\n</code></pre> <pre><code>5\u00d72 DataFrame\n Row \u2502 artists  count\n     \u2502 String?  UInt64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 missing       1\n   2 \u2502 Wizo          3\n   3 \u2502 MAGIC!        3\n   4 \u2502 Macaco        1\n   5 \u2502 SOYOU         1\n31438\u00d72 DataFrame\n   Row \u2502 artists          count\n       \u2502 String?          UInt64\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     1 \u2502 The Beatles         279\n     2 \u2502 George Jones        271\n     3 \u2502 Stevie Wonder       236\n     4 \u2502 Linkin Park         224\n     5 \u2502 Ella Fitzgerald     222\n     6 \u2502 Prateek Kuhad       217\n     7 \u2502 Feid                202\n   \u22ee   \u2502        \u22ee           \u22ee\n 31432 \u2502 Leonard               1\n 31433 \u2502 marcos g              1\n 31434 \u2502 BLVKSHP               1\n 31435 \u2502 Memtrix               1\n 31436 \u2502 SOYOU                 1\n 31437 \u2502 Macaco                1\n 31438 \u2502 missing               1\n               31424 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/","title":"Writing Functions with TidierDB Chains","text":"<p>On this page, we'll briefly explore how to use TidierDB macros and <code>$</code> witth <code>@eval</code> to bulid a function</p> <p>For a more indepth explanation, please check out the TidierData page on interpolation</p> <pre><code>using TidierDB, DataFrames;\n\ndb = connect(duckdb());\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\ndfv = dt(db,  df, \"dfm\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#interpolation","title":"Interpolation","text":"<p>Variables are interpoated using <code>@eval</code> and <code>$</code>. Place <code>@eval</code> before you begin the chain or call a TidierDb macro Why Use @eval? In Julia, macros like @filter are expanded at parse time, before runtime variables like vals are available. By using @eval, we force the expression to be evaluated at runtime, allowing us to interpolate the variable into the macro.</p> <pre><code>num = [3];\ncolumn = :id;\n@eval @chain dfv begin\n        @filter(value in $num)\n        @select($column)\n        @collect\n    end\n</code></pre> 2\u00d71 DataFrame RowidString1AC2AH <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#function-set-up","title":"Function set up","text":"<p>Begin by defining your function as your normally would, but before <code>@chain</code> you need to use <code>@eval</code>. For the variables to be interpolated in need to be started with <code>$</code></p> <pre><code>function test(vals, cols)\n    @eval @chain dfv begin\n        @filter(value in $vals)\n        @select($cols)\n        @collect\n    end\nend;\n\nvals = [1,  2,  3, 3];\ntest(vals, [:groups, :value, :percent])\n</code></pre> 6\u00d73 DataFrame RowgroupsvaluepercentStringInt64Float641bb10.12aa10.63aa20.24bb20.75bb30.36aa30.8 <p>Now with a new variable</p> <pre><code>other_vals = [1];\ncols = [:value, :percent];\ntest(other_vals, cols)\n</code></pre> 2\u00d72 DataFrame RowvaluepercentInt64Float64110.1210.6 <p>Defineing a new function</p> <pre><code>function gs(groups, aggs, new_name, threshold)\n    @eval @chain dfv begin\n        @group_by($groups)\n        @summarize($new_name = mean($aggs))\n        @filter($new_name &gt; $threshold)\n        @collect\n    end\nend;\n\ngs(:groups, :percent, :mean_percent, .5)\n</code></pre> 1\u00d72 DataFrame Rowgroupsmean_percentStringFloat641aa0.6 <p>Change the column and threshold</p> <pre><code>gs(:groups, :value, :mean_value, 2)\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_valueStringFloat641bb3.02aa3.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#write-pipeline-function-to-use-inside-of-chains","title":"Write pipeline function to use inside of chains","text":"<p>Lets say there is a particular sequence of macros that you want repeatedly use. Wrap this series into a function that accepts a <code>t(query</code> as its first argument and returns a <code>SQLquery</code> and you can easily resuse it.</p> <pre><code>function moving_aggs(table, start, stop, group, order, col)\n    qry = @eval @chain $table begin\n        @group_by $group\n        @window_frame $start $stop\n        @window_order $order\n        @mutate(across($col, (minimum, maximum, mean)))\n    end\n    return qry\nend;\n\n@chain dfv begin\n    moving_aggs(-2, 1, :groups, :percent, :value)\n    @filter value_mean &gt; 2.75\n    @aside @show_query _\n    @collect\nend\n</code></pre> 6\u00d77 DataFrame Rowidgroupsvaluepercentvalue_minimumvalue_maximumvalue_meanStringStringInt64Float64Int64Int64Float641ABaa20.2243.02AHaa30.8153.253AJaa51.0153.04ACbb30.3153.05AGbb20.7253.56AIbb40.9253.66667 <p>Filtering before the window functions</p> <pre><code>@chain dfv begin\n    @filter(value &gt;=2 )\n    moving_aggs(-1, 1, :groups, :percent, :value)\n    @aside @show_query _\n    @collect\nend\n</code></pre> 8\u00d77 DataFrame Rowidgroupsvaluepercentvalue_minimumvalue_maximumvalue_meanStringStringInt64Float64Int64Int64Float641ABaa20.2243.02ADaa40.4243.03AHaa30.8354.04AJaa51.0354.05ACbb30.3354.06AEbb50.5253.333337AGbb20.7253.666678AIbb40.9243.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#interpolating-queries","title":"Interpolating Queries","text":"<p>To use a prior, uncollected TidierDB query in other TidierDB macros, interpolate the needed query without showing or collecting it</p> <pre><code>ok = @chain dfv @summarize(mean = mean(value));\n</code></pre> <p>The mean value represented in SQL from the above is 3</p> <p>With <code>@filter</code></p> <pre><code>@eval @chain dfv begin\n    @filter( value &gt; $ok)\n    @collect\nend\n</code></pre> 4\u00d74 DataFrame RowidgroupsvaluepercentStringStringInt64Float641ADaa40.42AEbb50.53AIbb40.94AJaa51.0 <p>With <code>@mutate</code></p> <pre><code>@eval @chain dfv begin\n    @mutate(value2 =  value + $ok)\n    @collect\nend\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentvalue2StringStringInt64Float64Float641AAbb10.14.02ABaa20.25.03ACbb30.36.04ADaa40.47.05AEbb50.58.06AFaa10.64.07AGbb20.75.08AHaa30.86.09AIbb40.97.010AJaa51.08.0 <p>With <code>@summarize</code></p> <pre><code>@eval @chain dfv begin\n    @summarize(value =  mean(value) * $ok)\n    @collect\nend\n</code></pre> 1\u00d71 DataFrame RowvalueFloat6419.0 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/getting_started/","title":"Getting Started","text":"<p>If you plan to use TidierDB.jl with TidierData.jl or Tidier.jl, it is most convenenient to load the packages as follows:</p> <pre><code>using TidierData\nimport TidierDB as DB\n</code></pre> <p>Alternatively, <code>using Tidier</code> will import TidierDB in the above manner for you, where TidierDB functions and macros will be available as <code>DB.@mutate()</code> and so on, and the TidierData equivalent would be <code>@mutate()</code>.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#connecting","title":"Connecting","text":"<p>To use TidierDB, a connection must first be established. To connect to a database, you can uset the <code>connect</code> function  as shown below, or establish your own connection through the respecitve libraries.</p> <p>For example Connecting to DuckDB</p> <pre><code>conn = DB.connect(DB.duckdb())\n</code></pre> <p>versus connecting to MySQL</p> <pre><code>conn = DB.connect(DB.mysql(); host=\"localhost\", user=\"root\", password=\"password\", db=\"mydb\")\n</code></pre> <p>The <code>connect</code> docstring has many examples for how to use the connect function to connect to various backends or to MotherDuck.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#connect-to-a-local-database-file-with-duckdb","title":"Connect to a local database file with DuckDB","text":"<p>You can also connect to an existing database by passing the database file path as a string.</p> <pre><code>db = DB.connect(DB.duckdb(), \"path/to/mydb.duckdb\")\n</code></pre> <p>You can also establish any DuckDB connection through an alternate method that you prefer, and use that as your connection as well.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#package-extensions","title":"Package Extensions","text":"<p>The following backends utilize package extensions. To use one of backends listed below, you will need to write <code>using Library</code></p> <ul> <li>ClickHouse: <code>import ClickHouse</code></li> <li>MySQL and MariaDB: <code>using MySQL</code></li> <li>MSSQL: <code>using ODBC</code></li> <li>Postgres: <code>using LibPQ</code></li> <li>SQLite: <code>using SQLite</code></li> <li>Athena: <code>using AWS</code></li> <li>Oracle: <code>using ODBC</code></li> <li>Google BigQuery: <code>using GoogleCloud</code></li> <li>Google Sheets via DuckDB: run the following with your db <code>ghseet_connect(db)</code>, copy key and paste back in terminal. Then paste the entire google sheets link as your table name in <code>db_table</code></li> </ul> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#db_table-and-dt","title":"<code>db_table</code> and <code>dt</code>","text":"<p>What does <code>dt</code> do? (<code>dt</code> is an alias for <code>db_table</code>)</p> <p><code>dt</code> starts the underlying SQL query struct, in addition to pulling the table metadata and storing it there. Storing metadata is what enables a lazy interface that also supports tidy selection.</p> <ul> <li><code>dt</code> has two required arguments: <code>connection</code> and <code>table</code></li> <li> <p><code>table</code> can be a table name on a database or a path/url to file to read.  When passing <code>db_table</code> a path or url, the table is not copied into memory.</p> <ul> <li>Of note, <code>dt</code> only support direct file paths to a table. It does not support database file paths such as <code>dbname.duckdb</code> or <code>dbname.sqlite</code>. Such files must be used with <code>connect</code> first.</li> <li>With DuckDB and ClickHouse, if you have a folder of multiple files to read, you can use <code>*</code> read in all files matching the pattern, with an optional <code>alias</code> argument for what the data should be referred to.</li> <li>For example, the below would read all files that end in <code>.csv</code> in the given folder.</li> </ul> </li> </ul> <pre><code>dt(db, \"folder/path/*.csv\")\n</code></pre> <p><code>databricks</code> also supports iceberg, delta, and S3 file paths via DuckDB.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/getting_started/#minimizing-compute-costs-and-keystrokes","title":"Minimizing Compute Costs and Keystrokes","text":"<p>If you are working with a backend where compute cost is important, it will be important to minimize using <code>dt</code> as this will requery for metadata each time. Compute costs are relevant to backends such as AWS, databricks and Snowflake. It is best practice to save the results of <code>dt</code> or <code>db_table</code> and work w that object</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/ibis_comp/","title":"TidierDB.jl vs Ibis","text":""},{"location":"examples/generated/UserGuide/ibis_comp/#comparing-tidierdb-vs-ibis","title":"Comparing TidierDB vs Ibis","text":"<p>TidierDB is a reimplementation of dbplyr from R, so the syntax is remarkably similar. But how does TidierDB compare to Python's Ibis? This page will perform a similar comparison to the Ibis Documentation comparing Ibis and dplyr</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#set-up","title":"Set up","text":"<p>Ibis</p> <pre><code>import ibis\nimport ibis.selectors as s # allows for different styles of column selection\nfrom ibis import _ # eliminates need to type table name before each column vs typing cols as strings\nibis.options.interactive = True # automatically collects first 10 rows of table\n\ncon = ibis.connect(\"duckdb://\")\n</code></pre> <p>TidierDB</p> <pre><code>using TidierDB\ndb = connect(duckdb())\n</code></pre> <p>Of note, TidierDB does not yet have an \"interactive mode\" so each example result will be collected.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#loading-data","title":"Loading Data","text":"<p>With Ibis, there are specific functions to read in different file types</p> <pre><code>mtcars = con.read_csv(\"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\")\n</code></pre> <p>In TidierDB, there is only <code>dt</code>, which determines the file type and generates the syntax appropriate for the backend in use.</p> <pre><code>mtcars = dt(db, \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#previewing-the-data","title":"Previewing the data","text":"<p>TidierDB and Ibis use <code>head</code>/<code>@head</code> to preview the first rows of a dataset.</p> <p>Ibis</p> <pre><code>mtcars.head(6)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model             \u2503 mpg     \u2503 cyl   \u2503 disp    \u2503 hp    \u2503 drat    \u2503 wt      \u2503 qsec    \u2503 vs    \u2503 am    \u2503 gear  \u2503 carb  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 float64 \u2502 int64 \u2502 float64 \u2502 int64 \u2502 float64 \u2502 float64 \u2502 float64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502    21.0 \u2502     6 \u2502   160.0 \u2502   110 \u2502    3.90 \u2502   2.620 \u2502   16.46 \u2502     0 \u2502     1 \u2502     4 \u2502     4 \u2502\n\u2502 Mazda RX4 Wag     \u2502    21.0 \u2502     6 \u2502   160.0 \u2502   110 \u2502    3.90 \u2502   2.875 \u2502   17.02 \u2502     0 \u2502     1 \u2502     4 \u2502     4 \u2502\n\u2502 Datsun 710        \u2502    22.8 \u2502     4 \u2502   108.0 \u2502    93 \u2502    3.85 \u2502   2.320 \u2502   18.61 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Hornet 4 Drive    \u2502    21.4 \u2502     6 \u2502   258.0 \u2502   110 \u2502    3.08 \u2502   3.215 \u2502   19.44 \u2502     1 \u2502     0 \u2502     3 \u2502     1 \u2502\n\u2502 Hornet Sportabout \u2502    18.7 \u2502     8 \u2502   360.0 \u2502   175 \u2502    3.15 \u2502   3.440 \u2502   17.02 \u2502     0 \u2502     0 \u2502     3 \u2502     2 \u2502\n\u2502 Valiant           \u2502    18.1 \u2502     6 \u2502   225.0 \u2502   105 \u2502    2.76 \u2502   3.460 \u2502   20.22 \u2502     1 \u2502     0 \u2502     3 \u2502     1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain mtcars @head(6) @collect\n</code></pre> <pre><code>6\u00d712 DataFrame\n Row \u2502 model              mpg       cyl     disp      hp      drat      wt        qsec      vs      am      gear    carb\n     \u2502 String?            Float64?  Int64?  Float64?  Int64?  Float64?  Float64?  Float64?  Int64?  Int64?  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4              21.0       6     160.0     110      3.9      2.62      16.46       0       1       4       4\n   2 \u2502 Mazda RX4 Wag          21.0       6     160.0     110      3.9      2.875     17.02       0       1       4       4\n   3 \u2502 Datsun 710             22.8       4     108.0      93      3.85     2.32      18.61       1       1       4       1\n   4 \u2502 Hornet 4 Drive         21.4       6     258.0     110      3.08     3.215     19.44       1       0       3       1\n   5 \u2502 Hornet Sportabout      18.7       8     360.0     175      3.15     3.44      17.02       0       0       3       2\n   6 \u2502 Valiant                18.1       6     225.0     105      2.76     3.46      20.22       1       0       3       1\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#filtering","title":"Filtering","text":"<p>The example below demonstrates how to filter using multiple criteria in both Ibis and TidierData Ibis</p> <pre><code>mtcars.filter(((_.mpg &gt; 22) &amp; (_.drat &gt; 4) | (_.hp == 113)))\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model          \u2503 mpg     \u2503 cyl   \u2503 disp    \u2503 hp    \u2503 drat    \u2503 wt      \u2503 qsec    \u2503 vs    \u2503 am    \u2503 gear  \u2503 carb  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string         \u2502 float64 \u2502 int64 \u2502 float64 \u2502 int64 \u2502 float64 \u2502 float64 \u2502 float64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Lotus Europa   \u2502    30.4 \u2502     4 \u2502    95.1 \u2502   113 \u2502    3.77 \u2502   1.513 \u2502   16.90 \u2502     1 \u2502     1 \u2502     5 \u2502     2 \u2502\n\u2502 Fiat 128       \u2502    32.4 \u2502     4 \u2502    78.7 \u2502    66 \u2502    4.08 \u2502   2.200 \u2502   19.47 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Honda Civic    \u2502    30.4 \u2502     4 \u2502    75.7 \u2502    52 \u2502    4.93 \u2502   1.615 \u2502   18.52 \u2502     1 \u2502     1 \u2502     4 \u2502     2 \u2502\n\u2502 Toyota Corolla \u2502    33.9 \u2502     4 \u2502    71.1 \u2502    65 \u2502    4.22 \u2502   1.835 \u2502   19.90 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Fiat X1-9      \u2502    27.3 \u2502     4 \u2502    79.0 \u2502    66 \u2502    4.08 \u2502   1.935 \u2502   18.90 \u2502     1 \u2502     1 \u2502     4 \u2502     1 \u2502\n\u2502 Porsche 914-2  \u2502    26.0 \u2502     4 \u2502   120.3 \u2502    91 \u2502    4.43 \u2502   2.140 \u2502   16.70 \u2502     0 \u2502     1 \u2502     5 \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain mtcars begin\n       @filter((mpg &gt; 22 &amp;&amp; drat &gt; 4) || hp == 113)\n       @collect\nend\n</code></pre> <pre><code>6\u00d712 DataFrame\n Row \u2502 model           mpg       cyl     disp      hp      drat      wt        qsec      vs      am      gear    carb\n     \u2502 String?         Float64?  Int64?  Float64?  Int64?  Float64?  Float64?  Float64?  Int64?  Int64?  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Lotus Europa        30.4       4      95.1     113      3.77     1.513     16.9        1       1       5       2\n   2 \u2502 Fiat 128            32.4       4      78.7      66      4.08     2.2       19.47       1       1       4       1\n   3 \u2502 Honda Civic         30.4       4      75.7      52      4.93     1.615     18.52       1       1       4       2\n   4 \u2502 Toyota Corolla      33.9       4      71.1      65      4.22     1.835     19.9        1       1       4       1\n   5 \u2502 Fiat X1-9           27.3       4      79.0      66      4.08     1.935     18.9        1       1       4       1\n   6 \u2502 Porsche 914-2       26.0       4     120.3      91      4.43     2.14      16.7        0       1       5       2\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#creating-new-columns","title":"Creating new columns","text":"<p>Both TidierDB and Ibis use <code>mutate</code>/<code>@mutate</code> to add new columns</p> <p>Ibis</p> <pre><code>(\n   mtcars\n        .mutate(kpg = _.mpg * 1.61)\n        .select(\"model\", \"kpg\")\n)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model             \u2503 kpg     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502  33.810 \u2502\n\u2502 Mazda RX4 Wag     \u2502  33.810 \u2502\n\u2502 Datsun 710        \u2502  36.708 \u2502\n\u2502 Hornet 4 Drive    \u2502  34.454 \u2502\n\u2502 Hornet Sportabout \u2502  30.107 \u2502\n\u2502 Valiant           \u2502  29.141 \u2502\n\u2502 Duster 360        \u2502  23.023 \u2502\n\u2502 Merc 240D         \u2502  39.284 \u2502\n\u2502 Merc 230          \u2502  36.708 \u2502\n\u2502 Merc 280          \u2502  30.912 \u2502\n\u2502 \u2026                 \u2502       \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain mtcars begin\n       @mutate(kpg = mpg * 1.61)\n       @select(model, kpg)\n       @collect\nend\n</code></pre> <pre><code>32\u00d72 DataFrame\n Row \u2502 model              kpg\n     \u2502 String?            Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4            33.81\n   2 \u2502 Mazda RX4 Wag        33.81\n   3 \u2502 Datsun 710           36.708\n   4 \u2502 Hornet 4 Drive       34.454\n   5 \u2502 Hornet Sportabout    30.107\n   6 \u2502 Valiant              29.141\n  \u22ee  \u2502         \u22ee             \u22ee\n  27 \u2502 Porsche 914-2        41.86\n  28 \u2502 Lotus Europa         48.944\n  29 \u2502 Ford Pantera L       25.438\n  30 \u2502 Ferrari Dino         31.717\n  31 \u2502 Maserati Bora        24.15\n  32 \u2502 Volvo 142E           34.454\n                    20 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#sorting-columns","title":"Sorting columns","text":"<p>Ibis uses <code>order_by</code> similar to SQLs <code>ORDER BY</code></p> <p>Ibis</p> <pre><code>mtcars.order_by(_.mpg)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model               \u2503 mpg     \u2503 cyl   \u2503 disp    \u2503 hp    \u2503 drat    \u2503 wt      \u2503 qsec    \u2503 vs    \u2503 am    \u2503 gear  \u2503 carb  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string              \u2502 float64 \u2502 int64 \u2502 float64 \u2502 int64 \u2502 float64 \u2502 float64 \u2502 float64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Cadillac Fleetwood  \u2502    10.4 \u2502     8 \u2502   472.0 \u2502   205 \u2502    2.93 \u2502   5.250 \u2502   17.98 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Lincoln Continental \u2502    10.4 \u2502     8 \u2502   460.0 \u2502   215 \u2502    3.00 \u2502   5.424 \u2502   17.82 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Camaro Z28          \u2502    13.3 \u2502     8 \u2502   350.0 \u2502   245 \u2502    3.73 \u2502   3.840 \u2502   15.41 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Duster 360          \u2502    14.3 \u2502     8 \u2502   360.0 \u2502   245 \u2502    3.21 \u2502   3.570 \u2502   15.84 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Chrysler Imperial   \u2502    14.7 \u2502     8 \u2502   440.0 \u2502   230 \u2502    3.23 \u2502   5.345 \u2502   17.42 \u2502     0 \u2502     0 \u2502     3 \u2502     4 \u2502\n\u2502 Maserati Bora       \u2502    15.0 \u2502     8 \u2502   301.0 \u2502   335 \u2502    3.54 \u2502   3.570 \u2502   14.60 \u2502     0 \u2502     1 \u2502     5 \u2502     8 \u2502\n\u2502 Merc 450SLC         \u2502    15.2 \u2502     8 \u2502   275.8 \u2502   180 \u2502    3.07 \u2502   3.780 \u2502   18.00 \u2502     0 \u2502     0 \u2502     3 \u2502     3 \u2502\n\u2502 AMC Javelin         \u2502    15.2 \u2502     8 \u2502   304.0 \u2502   150 \u2502    3.15 \u2502   3.435 \u2502   17.30 \u2502     0 \u2502     0 \u2502     3 \u2502     2 \u2502\n\u2502 Dodge Challenger    \u2502    15.5 \u2502     8 \u2502   318.0 \u2502   150 \u2502    2.76 \u2502   3.520 \u2502   16.87 \u2502     0 \u2502     0 \u2502     3 \u2502     2 \u2502\n\u2502 Ford Pantera L      \u2502    15.8 \u2502     8 \u2502   351.0 \u2502   264 \u2502    4.22 \u2502   3.170 \u2502   14.50 \u2502     0 \u2502     1 \u2502     5 \u2502     4 \u2502\n\u2502 \u2026                   \u2502       \u2026 \u2502     \u2026 \u2502       \u2026 \u2502     \u2026 \u2502       \u2026 \u2502       \u2026 \u2502       \u2026 \u2502     \u2026 \u2502     \u2026 \u2502     \u2026 \u2502     \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>While TidierDB uses <code>@arrange</code> like TidierData.jl</p> <p>TidierDB</p> <pre><code>@chain mtcars @arrange(mpg) @collect\n</code></pre> <pre><code>32\u00d712 DataFrame\n Row \u2502 model                mpg       cyl     disp      hp      drat      wt        qsec      vs      am      gear    carb\n     \u2502 String?              Float64?  Int64?  Float64?  Int64?  Float64?  Float64?  Float64?  Int64?  Int64?  Int64?  Int64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Cadillac Fleetwood       10.4       8     472.0     205      2.93     5.25      17.98       0       0       3       4\n   2 \u2502 Lincoln Continental      10.4       8     460.0     215      3.0      5.424     17.82       0       0       3       4\n   3 \u2502 Camaro Z28               13.3       8     350.0     245      3.73     3.84      15.41       0       0       3       4\n   4 \u2502 Duster 360               14.3       8     360.0     245      3.21     3.57      15.84       0       0       3       4\n   5 \u2502 Chrysler Imperial        14.7       8     440.0     230      3.23     5.345     17.42       0       0       3       4\n   6 \u2502 Maserati Bora            15.0       8     301.0     335      3.54     3.57      14.6        0       1       5       8\n  \u22ee  \u2502          \u22ee              \u22ee        \u22ee        \u22ee        \u22ee        \u22ee         \u22ee         \u22ee        \u22ee       \u22ee       \u22ee       \u22ee\n  27 \u2502 Porsche 914-2            26.0       4     120.3      91      4.43     2.14      16.7        0       1       5       2\n  28 \u2502 Fiat X1-9                27.3       4      79.0      66      4.08     1.935     18.9        1       1       4       1\n  29 \u2502 Honda Civic              30.4       4      75.7      52      4.93     1.615     18.52       1       1       4       2\n  30 \u2502 Lotus Europa             30.4       4      95.1     113      3.77     1.513     16.9        1       1       5       2\n  31 \u2502 Fiat 128                 32.4       4      78.7      66      4.08     2.2       19.47       1       1       4       1\n  32 \u2502 Toyota Corolla           33.9       4      71.1      65      4.22     1.835     19.9        1       1       4       1\n                                                                                                              20 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#selecting-columns","title":"Selecting columns","text":"<p>In Ibis, columns must be prefixed with the table name, or in this case <code>_</code>, or they can be given as a string. Finally to using helper functions like <code>startswith</code> requires importing selectors as above.</p> <p>Ibis</p> <pre><code>mtcars.select(s.startswith(\"m\"), \"drat\", _.wt)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 model             \u2503 mpg     \u2503 drat    \u2503 wt      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502 float64 \u2502 float64 \u2502 float64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502    21.0 \u2502    3.90 \u2502   2.620 \u2502\n\u2502 Mazda RX4 Wag     \u2502    21.0 \u2502    3.90 \u2502   2.875 \u2502\n\u2502 Datsun 710        \u2502    22.8 \u2502    3.85 \u2502   2.320 \u2502\n\u2502 Hornet 4 Drive    \u2502    21.4 \u2502    3.08 \u2502   3.215 \u2502\n\u2502 Hornet Sportabout \u2502    18.7 \u2502    3.15 \u2502   3.440 \u2502\n\u2502 Valiant           \u2502    18.1 \u2502    2.76 \u2502   3.460 \u2502\n\u2502 Duster 360        \u2502    14.3 \u2502    3.21 \u2502   3.570 \u2502\n\u2502 Merc 240D         \u2502    24.4 \u2502    3.69 \u2502   3.190 \u2502\n\u2502 Merc 230          \u2502    22.8 \u2502    3.92 \u2502   3.150 \u2502\n\u2502 Merc 280          \u2502    19.2 \u2502    3.92 \u2502   3.440 \u2502\n\u2502 \u2026                 \u2502       \u2026 \u2502       \u2026 \u2502       \u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB does not require names to be prefixed and, like TidierData, tidy column selection with <code>starts_with</code>, <code>ends_with</code>, and <code>contains</code> is supported at base. TidierDB also supports providing column names as strings, although this would only be needed in the setting of renaming a column with a space in it.</p> <p>TidierDB</p> <pre><code>@chain mtcars @select(starts_with(\"m\"), \"drat\", wt) @collect\n</code></pre> <pre><code>32\u00d74 DataFrame\n Row \u2502 model              mpg       drat      wt\n     \u2502 String?            Float64?  Float64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4              21.0      3.9      2.62\n   2 \u2502 Mazda RX4 Wag          21.0      3.9      2.875\n   3 \u2502 Datsun 710             22.8      3.85     2.32\n   4 \u2502 Hornet 4 Drive         21.4      3.08     3.215\n   5 \u2502 Hornet Sportabout      18.7      3.15     3.44\n   6 \u2502 Valiant                18.1      2.76     3.46\n  \u22ee  \u2502         \u22ee             \u22ee         \u22ee         \u22ee\n  27 \u2502 Porsche 914-2          26.0      4.43     2.14\n  28 \u2502 Lotus Europa           30.4      3.77     1.513\n  29 \u2502 Ford Pantera L         15.8      4.22     3.17\n  30 \u2502 Ferrari Dino           19.7      3.62     2.77\n  31 \u2502 Maserati Bora          15.0      3.54     3.57\n  32 \u2502 Volvo 142E             21.4      4.11     2.78\n                                        20 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#multi-step-queries-and-summarizing","title":"Multi step queries and summarizing","text":"<p>Aggregating data is done with <code>aggregate</code> in Ibis and <code>@summarize</code> in TidierDB. To group data, both utilze <code>group_by</code>/<code>@group_by</code> Ibis</p> <pre><code>mtcars.group_by(._cyl).aggregate(\n    total_hp=_.hp.sum(),\n    avg_hp=_.hp.mean()\n).filter(_.total_hp &lt; 1000)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 cyl   \u2503 total_hp \u2503 avg_hp     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64 \u2502 int64    \u2502 float64    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     6 \u2502      856 \u2502 122.285714 \u2502\n\u2502     4 \u2502      909 \u2502  82.636364 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In TidierDB, <code>@filter</code> will automatically determine whether the criteria belong in a <code>WHERE</code> or <code>HAVING</code> SQL clause.</p> <p>TidierDB</p> <pre><code>@chain mtcars begin\n    @group_by(cyl)\n    @summarize(total_hp = sum(hp),\n               avg_hp = avg(hp))\n    @filter(total_hp &lt; 1000)\n    @collect\nend\n</code></pre> <pre><code>2\u00d73 DataFrame\n Row \u2502 cyl     total_hp  avg_hp\n     \u2502 Int64?  Int128?   Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      6       856  122.286\n   2 \u2502      4       909   82.6364\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/ibis_comp/#renaming-columns","title":"Renaming columns","text":"<p>Both tools use <code>rename</code>/@rename to rename columns</p> <p>Ibis</p> <pre><code>mtcars.rename(make_model = \"model\").select(_.make_model)\n</code></pre> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 make_model        \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mazda RX4         \u2502\n\u2502 Mazda RX4 Wag     \u2502\n\u2502 Datsun 710        \u2502\n\u2502 Hornet 4 Drive    \u2502\n\u2502 Hornet Sportabout \u2502\n\u2502 Valiant           \u2502\n\u2502 Duster 360        \u2502\n\u2502 Merc 240D         \u2502\n\u2502 Merc 230          \u2502\n\u2502 Merc 280          \u2502\n\u2502 \u2026                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>TidierDB</p> <pre><code>@chain mtcars @rename(model_make = model) @select(model_make) @collect\n</code></pre> <pre><code>32\u00d71 DataFrame\n Row \u2502 model_make\n     \u2502 String?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4\n   2 \u2502 Mazda RX4 Wag\n   3 \u2502 Datsun 710\n   4 \u2502 Hornet 4 Drive\n   5 \u2502 Hornet Sportabout\n   6 \u2502 Valiant\n  \u22ee  \u2502         \u22ee\n  27 \u2502 Porsche 914-2\n  28 \u2502 Lotus Europa\n  29 \u2502 Ford Pantera L\n  30 \u2502 Ferrari Dino\n  31 \u2502 Maserati Bora\n  32 \u2502 Volvo 142E\n          20 rows omitted\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/key_differences/","title":"Key Differences from TidierData.jl","text":"<p>There are a few important syntax and behavior differences between TidierDB.jl and TidierData.jl outlined below.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#creating-a-database","title":"Creating a database","text":"<p>For these examples we will use DuckDB, the default backend. If you have an existing DuckDB connection, then this step is not required. For these examples, we will create a data frame and copy it to an in-memory DuckDB database.</p> <pre><code>using DataFrames, TidierDB\n\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\ndb = connect(duckdb());\n\ndfv = dt(db, df, \"dfv\"); # create a view (not a copy) of the dataframe on a in-memory database\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#row-ordering","title":"Row ordering","text":"<p>DuckDB benefits from aggressive parallelization of pipelines. This means that if you have multiple threads enabled in Julia, which you can check or set using <code>Threads.nthreads()</code>, DuckDB will use multiple threads. However, because many operations are multi-threaded, the resulting row order is inconsistent. If row order needs to be deterministic for your use case, make sure to apply an <code>@arrange(column_name_1, column_name_2, etc...)</code> prior to collecting the results.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#starting-a-chain","title":"Starting a chain","text":"<p>When using TidierDB, <code>dt(connection, \"table_name\")</code> is used to start a chain.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#grouped-mutation","title":"Grouped mutation","text":"<p>In TidierDB, when performing <code>@group_by</code> then <code>@mutate</code>, the table will be ungrouped after applying all of the mutations in the clause to the grouped data. To perform subsequent grouped operations, the user would have to regroup the data. This is demonstrated below.</p> <pre><code>@chain dfv begin\n    @group_by(groups)\n    @mutate(mean_percent = mean(percent))\n    @collect\n end\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentmean_percentStringStringInt64Float64Float641ABaa20.20.62ADaa40.40.63AFaa10.60.64AHaa30.80.65AJaa51.00.66AAbb10.10.57ACbb30.30.58AEbb50.50.59AGbb20.70.510AIbb40.90.5 <p>Regrouping following <code>@mutate</code></p> <pre><code>@chain dfv begin\n    @group_by(groups)\n    @mutate(max = maximum(percent), min = minimum(percent))\n    @group_by(groups)\n    @summarise(mean_percent = mean(percent))\n    @collect\nend\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentStringFloat641aa0.62bb0.5 <p>TidierDB also supports <code>_by</code> for grouping directly within a mutate clause (a feature coming to TidierData in the the future)</p> <pre><code>@chain dfv begin\n    @mutate(mean_percent = mean(percent),\n        _by = groups)\n    @collect\n end\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentmean_percentStringStringInt64Float64Float641ABaa20.20.62ADaa40.40.63AFaa10.60.64AHaa30.80.65AJaa51.00.66AAbb10.10.57ACbb30.30.58AEbb50.50.59AGbb20.70.510AIbb40.90.5 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#differences-in-case_when","title":"Differences in <code>case_when()</code>","text":"<p>In TidierDB, after the clause is completed, the result for the new column should is separated by a comma <code>,</code> in contrast to TidierData.jl, where the result for the new column is separated by a <code>=&gt;</code> .</p> <pre><code>@chain dfv begin\n    @mutate(new_col = case_when(percent &gt; .5, \"Pass\",  # in TidierData, percent &gt; .5 =&gt; \"Pass\",\n                                percent &lt;= .5, \"Try Again\", # percent &lt;= .5 =&gt; \"Try Again\"\n                                true, \"middle\"))\n    @collect\n end\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentnew_colStringStringInt64Float64String1AAbb10.1Try Again2ABaa20.2Try Again3ACbb30.3Try Again4ADaa40.4Try Again5AEbb50.5Try Again6AFaa10.6Pass7AGbb20.7Pass8AHaa30.8Pass9AIbb40.9Pass10AJaa51.0Pass <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/misc_tips/","title":"Misc Tips/Tricks","text":"<p>There are a few miscellaneous feautures of TidierDB that are documented on this page</p> <pre><code>using DataFrames, TidierDB\n\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\ndb = connect(duckdb());\n\ndfv = dt(db, df, \"dfv\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/misc_tips/#duckdbs-summarize","title":"DuckDB's SUMMARIZE","text":"<p>DuckDB has a feature tosummarize tables that gives information about the table, such as mean, std, q25, q75 etc. To use this feature with TidierDB, simply call an <code>@summary</code> on any table or file before querying it.</p> <pre><code>@chain dfv @summary() @collect\n</code></pre> 4\u00d712 DataFrame Rowcolumn_namecolumn_typeminmaxapprox_uniqueavgstdq25q50q75countnull_percentageStringStringStringStringInt64String?String?String?String?String?Int64FixedDec\u20261idVARCHARAAAJ11missingmissingmissingmissingmissing100.02groupsVARCHARaabb2missingmissingmissingmissingmissing100.03valueBIGINT1553.01.4907119849998598234100.04percentDOUBLE0.11.0100.550.30276503540974920.30.550.8100.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/misc_tips/#show_querycollect","title":"show_query/collect","text":"<p>If you find yourself frequently showing a query while collecting, you can define the following function</p> <pre><code>sqc(qry) = @chain qry begin\n                @aside @show_query _\n                @collect()\n            end;\n</code></pre> <p>Call this function at the end of a chain similar the <code>@show_query</code> or<code>@collect</code> macros printed query is not seen here as it prints to the REPL</p> <pre><code>@chain dfv @summary() sqc()\n</code></pre> 4\u00d712 DataFrame Rowcolumn_namecolumn_typeminmaxapprox_uniqueavgstdq25q50q75countnull_percentageStringStringStringStringInt64String?String?String?String?String?Int64FixedDec\u20261idVARCHARAAAJ11missingmissingmissingmissingmissing100.02groupsVARCHARaabb2missingmissingmissingmissingmissing100.03valueBIGINT1553.01.4907119849998598234100.04percentDOUBLE0.11.0100.550.30276503540974920.30.550.8100.0 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/misc_tips/#color-printing","title":"Color Printing","text":"<p>Queries print with some code words in color to the REPL. To turn off this feature, run one of the following.</p> <ul> <li><code>TidierDB.color[] = false</code></li> <li><code>DB.color[] = false</code></li> </ul> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/outofmemex/","title":"Working With Larger than RAM Datasets","text":"<p>While using the DuckDB backend, TidierDB's lazy intferace enables querying datasets larger than your available RAM.</p> <p>To illustrate this, we will recreate the Hugging Face x Polars example. The final table results are shown below and in this Hugging Face x DuckDB example</p> <p>First we will load TidierDB, set up a local database and then set the URLs for the 2 training datasets from huggingface.co</p> <pre><code>using TidierDB\ndb = connect(duckdb())\n\nurls = [\"https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0000.parquet\",\n \"https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0001.parquet\"];\n</code></pre> <p>Here, we pass the vector of URLs to <code>dt</code>, which will not copy them into memory. Since these datasets are so large, we will also set <code>stream = true</code> in <code>@collect</code> to stream the results. If we wanted to read all the files in the folder we could have replace the <code>0000</code> with <code>*</code> (wildcard) <code>dt(db, \"Path/to/folder/*.parquet\")</code> Of note, reading these files from URLs is not as rapid as reading them from local files.</p> <pre><code>astro = dt(db, urls)\n@chain astro begin\n    @group_by(horoscope)\n    @summarise(count = n(), avg_blog_length = mean(length(text)))\n    @arrange(desc(count))\n    @aside @show_query _\n    @collect(stream = true)\nend\n</code></pre> <p>Placing <code>@aside @show_query _</code> before <code>@collect</code> above lets us see the SQL query and collect it to a local DataFrame at the same time.</p> <pre><code>SELECT horoscope, COUNT(*) AS count, AVG(length(text)) AS avg_blog_length\n        FROM read_parquet(['https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0000.parquet', 'https://huggingface.co/datasets/blog_authorship_corpus/resolve/refs%2Fconvert%2Fparquet/blog_authorship_corpus/train/0001.parquet'])\n        GROUP BY horoscope\n        ORDER BY avg_blog_length DESC\n12\u00d73 DataFrame\n Row \u2502 horoscope    count   avg_blog_length\n     \u2502 String?      Int64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Aquarius      49568         1125.83\n   2 \u2502 Cancer        63512         1097.96\n   3 \u2502 Libra         60304         1060.61\n   4 \u2502 Capricorn     49402         1059.56\n   5 \u2502 Sagittarius   50431         1057.46\n   6 \u2502 Leo           58010         1049.6\n   7 \u2502 Taurus        61571         1022.69\n   8 \u2502 Gemini        52925         1020.26\n   9 \u2502 Scorpio       56495         1014.03\n  10 \u2502 Pisces        53812         1011.75\n  11 \u2502 Virgo         64629          996.684\n  12 \u2502 Aries         69134          918.081\n</code></pre> <p>To learn more about memory efficient queries on larger than RAM files, this blog from DuckDB will help maximize your local <code>db</code></p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/pivoting/","title":"Pivoting","text":"<p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/s3viaduckdb/","title":"S3 + DuckDB + TidierDB","text":"<p>TidierDB allows you leverage DuckDB's seamless database integration.</p> <p>Using DuckDB, you can connect to an AWS or GoogleCloud Database to query directly without making any local copies.</p> <p>You can also use <code>DBInterface.execute</code> to set up any DuckDB database connection you need and then use that db to query with TidierDB</p> <pre><code>using TidierDB\n\n#Connect to Google Cloud via DuckDB\n#google_db = connect(duckdb(), :gbq, access_key=\"string\", secret_key=\"string\")\n\n#Connect to AWS via DuckDB\naws_db = connect(duckdb(), :aws, aws_access_key_id= \"string\",\n                                aws_secret_access_key= \"string\",\n                                aws_region=\"us-east-1\")\ns3_csv_path = \"s3://path/to_data.csv\"\n\n@chain dt(aws_db, s3_csv_path) begin\n    @filter(!starts_with(column1, \"M\"))\n    @group_by(cyl)\n    @summarize(mpg = mean(mpg))\n    @mutate(mpg_squared = mpg^2,\n               mpg_rounded = round(mpg),\n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))\n    @filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    @arrange(desc(mpg_rounded))\n    @collect\nend\n</code></pre> <pre><code>2\u00d75 DataFrame\n Row \u2502 cyl     mpg       mpg_squared  mpg_rounded  mpg_efficiency\n     \u2502 Int64?  Float64?  Float64?     Float64?     String?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4   27.3444      747.719         27.0  efficient\n   2 \u2502      6   19.7333      389.404         20.0  moderate\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/udfs_ex/","title":"Flexible Syntax and UDFs","text":"<p>TidierDB is unique in its statement parsing flexiblility.  This means that in addition to using any built in SQL database functions, user defined functions (or UDFS) are readily avaialable in TidierDB.</p> <pre><code>using TidierDB # DuckDB is reexported by TidierDB\ndb = connect(duckdb());\ndf = DataFrame(a = [1, 2, 3], b = [1, 2, 3]);\ndfv = dt(db, df, \"df_view\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#udfs-in-duckdb","title":"UDFs in DuckDB","text":"<p>Once created, UDFs can immediately be used in with <code>@mutate</code> or <code>@transmute</code> A more in depth disccusion of UDFs in DuckDB.jl can be found here. There are 3 steps 1) Define a function in julia, 2) create the scalar function in DuckDB, and 3) register it</p> <pre><code>bino = (a, b) -&gt; (a + b) * (a + b)\nfun = DuckDB.@create_scalar_function bino(a::Int, b::Int)::Int\nDuckDB.register_scalar_function(db, fun)\n@chain dfv @mutate(c = bino(a, b)) @collect\n</code></pre> 3\u00d73 DataFrame RowabcInt64Int64Int6411142221633336 <p>Notably, when the function is redefined (with the same arguments) in julia, the DuckDB UDF representation will change as well.</p> <pre><code>bino = (a, b) -&gt; (a + b) * (a - b)\n@chain dfv @mutate(c = bino(a, b)) @collect\n</code></pre> 3\u00d73 DataFrame RowabcInt64Int64Int64111022203330 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#duckdb-function-chaining","title":"DuckDB function chaining","text":"<p>In DuckDB, functions can be chained together with <code>.</code>. TidierDB lets you leverage this.</p> <pre><code>mtcars_path = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\";\nmtcars = dt(db, mtcars_path);\n@chain mtcars begin\n    @mutate(model2 = model.upper().string_split(\" \").list_aggr(\"string_agg\",\".\").concat(\".\"))\n    @select model model2\n    @head()\n    @collect\nend\n</code></pre> 6\u00d72 DataFrame Rowmodelmodel2StringString1Mazda RX4MAZDA.RX4.2Mazda RX4 WagMAZDA.RX4.WAG.3Datsun 710DATSUN.710.4Hornet 4 DriveHORNET.4.DRIVE.5Hornet SportaboutHORNET.SPORTABOUT.6ValiantVALIANT. <p></p> <p></p>"},{"location":"examples/generated/UserGuide/udfs_ex/#rowid-and-pseudocolumns","title":"<code>rowid</code> and pseudocolumns","text":"<p>When a table is not being read directly from a file, <code>rowid</code> is avaialable for use. In general, TidierDB should support all pseudocolumns.</p> <pre><code>copy_to(db, mtcars_path, \"mtcars\"); # copying table in for demostration purposes\n@chain dt(db, \"mtcars\") begin\n      @filter(rowid == 4)\n      @select(model:hp)\n      @collect\n end\n</code></pre> 1\u00d75 DataFrame RowmodelmpgcyldisphpStringFloat64Int64Float64Int641Hornet Sportabout18.78360.0175 <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/unnesting/","title":"Unnesting Columns","text":"<p>[Note] unnesting is an experimental feature for TidierDB</p> <p>TidierDB now supports unnesting both arrays and structs</p> <pre><code>using TidierDB\ndb = connect(duckdb())\n\nDuckDB.query(db, \"\n        CREATE OR REPLACE TABLE nested_table (\n            id INTEGER,\n            coord ROW(lat DOUBLE, lon DOUBLE),\n            loc ROW(city STRING, country STRING),\n            info ROW(continent STRING, climate STRING)\n        );\n        INSERT INTO nested_table VALUES\n            (1, ROW(40.7128, -74.0060), ROW('New York', 'USA'), ROW('North America', 'Temperate')),\n            (2, ROW(48.8566, 2.3522), ROW('Paris', 'France'), ROW('Europe', 'Temperate')),\n            (3, ROW(35.6895, 139.6917), ROW('Tokyo', 'Japan'), ROW('Asia', 'Humid Subtropical'));\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/unnesting/#unnest_wider","title":"<code>@unnest_wider</code>","text":"<p><code>@unnest_wider</code> at this time only supports unnesting columns of type STRUCT</p> <pre><code>@chain dt(db, \"nested_table\") begin\n    @unnest_wider(coord:info)\n    @collect\nend\n</code></pre> 3\u00d77 DataFrame RowidlatloncitycountrycontinentclimateInt32Float64Float64StringStringStringString1140.7128-74.006New YorkUSANorth AmericaTemperate2248.85662.3522ParisFranceEuropeTemperate3335.6895139.692TokyoJapanAsiaHumid Subtropical <p>Single elements can be extracted a new column like so, or with any of existing LIST backend function as well.</p> <pre><code>@chain dt(db, \"nested_table\") begin\n    @mutate(city = loc.city)\n    @collect\nend\n</code></pre> 3\u00d75 DataFrame RowidcoordlocinfocityInt32NamedTup\u2026?NamedTup\u2026?NamedTup\u2026?String11(lat = 40.7128, lon = -74.006)(city = \"New York\", country = \"USA\")(continent = \"North America\", climate = \"Temperate\")New York22(lat = 48.8566, lon = 2.3522)(city = \"Paris\", country = \"France\")(continent = \"Europe\", climate = \"Temperate\")Paris33(lat = 35.6895, lon = 139.692)(city = \"Tokyo\", country = \"Japan\")(continent = \"Asia\", climate = \"Humid Subtropical\")Tokyo <p>Create a new table for with columns of arrays for the following example with <code>@unnest_longer</code></p> <pre><code>DuckDB.query(db, \"\n    CREATE TABLE nt (\n        id INTEGER,\n        data ROW(a INTEGER[], b INTEGER[])\n        );\n    INSERT INTO nt VALUES\n        (1, (ARRAY[1,2], ARRAY[3,4])),\n        (2, (ARRAY[5,6], ARRAY[7,8,9])),\n        (3, (ARRAY[10,11], ARRAY[12,13]));\");\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/unnesting/#unnest_longer","title":"<code>@unnest_longer</code>","text":"<p>In this example, we will first <code>@unnest_wider</code> data column into 2 columns <code>a</code> and <code>b</code>, before flattening the arrays within them with <code>@unnest_longer</code></p> <pre><code>@chain dt(db, \"nt\") begin\n    @unnest_wider(data)\n    @unnest_longer(a, b)\n    @collect\nend\n</code></pre> 7\u00d73 DataFrame RowidabInt32Int32?Int32111321243257426852missing9631012731113 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/unnesting/#exploded-json","title":"Exploded JSON","text":"<p>Users may come across table columns that do not unnest with <code>@unnest_wider</code> and <code>@unnest_longer</code>. TidierDB now has an experimental method to enable using DuckDB's <code>UNNEST</code> function with transmute to explode such a column and drop all other columns.</p> <pre><code>@chain dt(db, \"read_json('https://environment.data.gov.uk/flood-monitoring/id/measures')\", alias = \"meas\") begin\n    @transmute(unnest(items))\n    @head 3\n    @collect\nend\n</code></pre> 3\u00d714 DataFrame Row@iddatumTypelabellatestReadingnotationparameterparameterNameperiodqualifierstationstationReferenceunitunitNamevalueTypeStringStringStringNamedTup\u2026?StringStringStringInt64StringStringStringStringStringString1http://environment.data.gov.uk/flood-monitoring/id/measures/1029TH-level-downstage-i-15_min-mASDhttp://environment.data.gov.uk/flood-monitoring/def/core/datumASDRIVER DIKLER AT BOURTON ON THE WATER - level-downstage-i-15_min-mASD(var\"@id\" = \"http://environment.data.gov.uk/flood-monitoring/data/readings/1029TH-level-downstage-i-15_min-mASD/2025-07-06T17-45-00Z\", date = Date(\"2025-07-06\"), dateTime = DateTime(\"2025-07-06T17:45:00\"), measure = \"http://environment.data.gov.uk/flood-monitoring/id/measures/1029TH-level-downstage-i-15_min-mASD\", value = -0.407)1029TH-level-downstage-i-15_min-mASDlevelWater Level900Downstream Stagehttp://environment.data.gov.uk/flood-monitoring/id/stations/1029TH1029THhttp://qudt.org/1.1/vocab/unit#MetermASDinstantaneous2http://environment.data.gov.uk/flood-monitoring/id/measures/1029TH-level-stage-i-15_min-mASDhttp://environment.data.gov.uk/flood-monitoring/def/core/datumASDRIVER DIKLER AT BOURTON ON THE WATER - level-stage-i-15_min-mASD(var\"@id\" = \"http://environment.data.gov.uk/flood-monitoring/data/readings/1029TH-level-stage-i-15_min-mASD/2025-07-06T17-45-00Z\", date = Date(\"2025-07-06\"), dateTime = DateTime(\"2025-07-06T17:45:00\"), measure = \"http://environment.data.gov.uk/flood-monitoring/id/measures/1029TH-level-stage-i-15_min-mASD\", value = 0.081)1029TH-level-stage-i-15_min-mASDlevelWater Level900Stagehttp://environment.data.gov.uk/flood-monitoring/id/stations/1029TH1029THhttp://qudt.org/1.1/vocab/unit#MetermASDinstantaneous3http://environment.data.gov.uk/flood-monitoring/id/measures/E2043-level-stage-i-15_min-mASDhttp://environment.data.gov.uk/flood-monitoring/def/core/datumASDSURFLEET SLUICE WITS - level-stage-i-15_min-mASD(var\"@id\" = \"http://environment.data.gov.uk/flood-monitoring/data/readings/E2043-level-stage-i-15_min-mASD/2025-07-06T17-45-00Z\", date = Date(\"2025-07-06\"), dateTime = DateTime(\"2025-07-06T17:45:00\"), measure = \"http://environment.data.gov.uk/flood-monitoring/id/measures/E2043-level-stage-i-15_min-mASD\", value = 0.652)E2043-level-stage-i-15_min-mASDlevelWater Level900Stagehttp://environment.data.gov.uk/flood-monitoring/id/stations/E2043E2043http://qudt.org/1.1/vocab/unit#MetermASDinstantaneous <p>This page was generated using Literate.jl.</p>"}]}