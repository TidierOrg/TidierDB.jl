{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-tidierdbjl","title":"What is TidierDB.jl?","text":"<p>TiderDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package.</p> <p>The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.</p> <p></p> <p></p>"},{"location":"#currently-supported-backends-include","title":"Currently supported backends include:","text":"<ul> <li>DuckDB (the default) <code>set_sql_mode(:duckdb)</code></li> <li>ClickHouse <code>set_sql_mode(:clickhouse)</code></li> <li>SQLite <code>set_sql_mode(:lite)</code></li> <li>MySQL and MariaDB <code>set_sql_mode(:mysql)</code></li> <li>MSSQL <code>set_sql_mode(:mssql)</code></li> <li>Postgres <code>set_sql_mode(:postgres)</code></li> <li>Athena <code>set_sql_mode(:athena)</code></li> </ul> <p>The style of SQL that is generated can be modified using <code>set_sql_mode()</code>.</p> <p></p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>For the stable version:</p> <pre><code>] add TidierDB\n</code></pre> <p>TidierDB.jl currently supports the following top-level macros:</p> <ul> <li><code>@arrange</code></li> <li><code>@group_by</code></li> <li><code>@filter</code></li> <li><code>@select</code></li> <li><code>@mutate</code>, which supports <code>across()</code></li> <li><code>@summarize</code> and <code>@summarise</code>, which supports <code>across()</code></li> <li><code>@distinct</code></li> <li><code>@left_join</code>, <code>@right_join</code>, <code>@inner_join</code> (slight syntax differences from TidierData.jl)</li> <li><code>@count</code></li> <li><code>@slice_min</code>, <code>@slice_max</code>, <code>@slice_sample</code></li> <li><code>@window_order</code> and <code>window_frame</code></li> <li><code>@show_query</code></li> <li><code>@collect</code></li> </ul> <p>Supported helper functions for most backends include:</p> <ul> <li><code>across()</code></li> <li><code>desc()</code></li> <li><code>if_else()</code> and <code>case_when()</code></li> <li><code>n()</code></li> <li><code>starts_with()</code>, <code>ends_with()</code>, and <code>contains()</code></li> <li><code>as_float()</code>, <code>as_integer()</code>, and <code>as_string()</code></li> <li><code>is_missing()</code></li> <li><code>missing_if()</code> and <code>replace_missing()</code></li> </ul> <p>From TidierStrings.jl:</p> <ul> <li><code>str_detect</code>, <code>str_replace</code>, <code>str_replace_all</code>, <code>str_remove_all</code>, <code>str_remove</code></li> </ul> <p>From TidierDates.jl:</p> <ul> <li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>min</code>, <code>second</code>, <code>floor_date</code>, <code>difftime</code></li> </ul> <p>Supported aggregate functions (as supported by the backend) with more to come</p> <ul> <li><code>mean</code>, <code>minimium</code>, <code>maximum</code>, <code>std</code>, <code>sum</code>, <code>cumsum</code>, <code>cor</code>, <code>cov</code>, <code>var</code></li> <li><code>copy_to</code> (for DuckDB, MySQL, SQLite)</li> </ul> <p>DuckDB specifically enables copy_to to directly reading in <code>.parquet</code>, <code>.json</code>, <code>.csv</code>, and <code>.arrow</code> file, including https file paths.</p> <pre><code>path = \"file_path.parquet\"\ncopy_to(conn, file_path, \"table_name\")\n</code></pre> <p></p> <p></p>"},{"location":"#what-is-the-recommended-way-to-use-tidierdb","title":"What is the recommended way to use TidierDB?","text":"<p>Typically, you will want to use TidierDB alongside TidierData because there are certain functionality (such as pivoting) which are only supported in TidierData and can only be performed on data frames.</p> <p>Our recommended path for using TidierDB is to import the package so that there are no namespace conflicts with TidierData. Once TidierDB is integrated with Tidier, then Tidier will automatically load the packages in this fashion.</p> <p>First, let's develop and execute a query using TidierDB. Notice that all top-level macros and functions originating from TidierDB start with a <code>DB</code> prefix. Any functions defined within macros do not need to be prefixed within <code>DB</code> because they are actually pseudofunctions that are in actuality converted into SQL code.</p> <p>Even though the code reads similarly to TidierData, note that no computational work actually occurs until you run <code>DB.@collect()</code>, which runs the SQL query and instantiates the result as a DataFrame.</p> <pre><code>using TidierData\nimport TidierDB as DB\n\nmem = DB.duckdb_open(\":memory:\");\ndb = DB.duckdb_connect(mem);\npath = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\nDB.copy_to(db, path, \"mtcars\");\n\n@chain DB.db_table(db, :mtcars) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\nend\n</code></pre> <pre><code>2\u00d75 DataFrame\n Row \u2502 cyl     mpg       mpg_squared  mpg_rounded  mpg_efficiency \n     \u2502 Int64?  Float64?  Float64?     Float64?     String?        \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4   27.3444      747.719         27.0  efficient\n   2 \u2502      6   19.7333      389.404         20.0  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-if-we-wanted-to-pivot-the-result","title":"What if we wanted to pivot the result?","text":"<p>We cannot do this using TidierDB. However, we can call <code>@pivot_longer()</code> from TidierData after the result of the query has been instantiated as a DataFrame, like this: </p> <pre><code>@chain DB.db_table(db, :mtcars) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\n    @pivot_longer(everything(), names_to = \"variable\", values_to = \"value\")\nend\n</code></pre> <pre><code>10\u00d72 DataFrame\n Row \u2502 variable        value     \n     \u2502 String          Any       \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 cyl             4\n   2 \u2502 cyl             6\n   3 \u2502 mpg             27.3444\n   4 \u2502 mpg             19.7333\n   5 \u2502 mpg_squared     747.719\n   6 \u2502 mpg_squared     389.404\n   7 \u2502 mpg_rounded     27.0\n   8 \u2502 mpg_rounded     20.0\n   9 \u2502 mpg_efficiency  efficient\n  10 \u2502 mpg_efficiency  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-sql-query-does-tidierdb-generate-for-a-given-piece-of-julia-code","title":"What SQL query does TidierDB generate for a given piece of Julia code?","text":"<p>We can replace <code>DB.collect()</code> with <code>DB.@show_query</code> to reveal the underlying SQL query being generated by TidierDB. To handle complex queries, TidierDB makes heavy use of Common Table Expressions (CTE), which are a useful tool to organize long queries.</p> <pre><code>@chain DB.db_table(db, :mtcars) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@show_query\nend\n</code></pre> <pre><code>WITH cte_1 AS (\nSELECT *\n        FROM mtcars\n        WHERE NOT (starts_with(model, 'M'))),\ncte_2 AS (\nSELECT cyl, AVG(mpg) AS mpg\n        FROM cte_1\n        GROUP BY cyl),\ncte_3 AS (\nSELECT  cyl, mpg, POWER(mpg, 2) AS mpg_squared, ROUND(mpg) AS mpg_rounded, CASE WHEN mpg &gt;= POWER(cyl, 2) THEN 'efficient' WHEN mpg &lt; 15.2 THEN 'inefficient' ELSE 'moderate' END AS mpg_efficiency\n        FROM cte_2 ),\ncte_4 AS (\nSELECT *\n        FROM cte_3\n        WHERE mpg_efficiency in ('moderate', 'efficient'))  \nSELECT *\n        FROM cte_4  \n        ORDER BY mpg_rounded DESC\n</code></pre> <p></p> <p></p>"},{"location":"#tidierdb-is-already-quite-fully-featured-supporting-advanced-tidierdata-functions-like-across-for-multi-column-selection","title":"TidierDB is already quite fully-featured, supporting advanced TidierData functions like <code>across()</code> for multi-column selection.","text":"<pre><code>@chain DB.db_table(db, :mtcars) begin\n    DB.@group_by(cyl)\n    DB.@summarize(across((starts_with(\"a\"), ends_with(\"s\")), (mean, sum)))\n    DB.@collect\nend\n</code></pre> <pre><code>3\u00d75 DataFrame\n Row \u2502 cyl     mean_am   mean_vs   sum_am   sum_vs  \n     \u2502 Int64?  Float64?  Float64?  Int128?  Int128? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4  0.727273  0.909091        8       10\n   2 \u2502      6  0.428571  0.571429        3        4\n   3 \u2502      8  0.142857  0.0             2        0\n</code></pre> <p>Bang bang <code>!!</code> interpolation for columns and values is also supported.</p> <p>There are a few subtle but important differences from Tidier.jl outlined here.</p> <p></p> <p></p>"},{"location":"#missing-a-function-or-backend","title":"Missing a function or backend?","text":"<p>You can use any existing SQL function within <code>@mutate</code> with the correct SQL syntax and it should just work.</p> <p>But if you run into problems please open an issue, and we will be happy to take a look!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>TidierDB.copy_to</code></li> <li><code>TidierDB.@arrange</code></li> <li><code>TidierDB.@count</code></li> <li><code>TidierDB.@distinct</code></li> <li><code>TidierDB.@filter</code></li> <li><code>TidierDB.@group_by</code></li> <li><code>TidierDB.@inner_join</code></li> <li><code>TidierDB.@left_join</code></li> <li><code>TidierDB.@mutate</code></li> <li><code>TidierDB.@rename</code></li> <li><code>TidierDB.@right_join</code></li> <li><code>TidierDB.@select</code></li> <li><code>TidierDB.@slice_max</code></li> <li><code>TidierDB.@slice_min</code></li> <li><code>TidierDB.@slice_sample</code></li> <li><code>TidierDB.@summarise</code></li> <li><code>TidierDB.@summarize</code></li> <li><code>TidierDB.@window_frame</code></li> <li><code>TidierDB.@window_order</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>TidierDB.copy_to</code> \u2014 Method.</p> <pre><code>   copy_to(conn, df_or_path, \"name\")\n</code></pre> <p>Allows user to copy a df to the database connection. Currently supports DuckDB, SQLite, MySql</p> <p>Arguments</p> <p>-<code>conn</code>: the database connection -<code>df</code>: dataframe to be copied or path to serve as source. With DuckDB, path supports .csv, .json, .parquet to be used without copying intermediary df. -<code>name</code>: name as string for the database to be used</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"test\");\n</code></pre> <p>source</p> <p># <code>TidierDB.@arrange</code> \u2014 Macro.</p> <pre><code>@arrange(sql_query, columns...)\n</code></pre> <p>Order SQL table rows based on specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by. Can include multiple columns for nested sorting. Wrap column name with <code>desc()</code> for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @arrange(value, desc(percent))\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF       aa            1       0.6\n   2 \u2502 AA       bb            1       0.1\n   3 \u2502 AG       bb            2       0.7\n   4 \u2502 AB       aa            2       0.2\n   5 \u2502 AH       aa            3       0.8\n   6 \u2502 AC       bb            3       0.3\n   7 \u2502 AI       bb            4       0.9\n   8 \u2502 AD       aa            4       0.4\n   9 \u2502 AJ       aa            5       1.0\n  10 \u2502 AE       bb            5       0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@count</code> \u2014 Macro.</p> <pre><code>@count(sql_query, columns...)\n</code></pre> <p>Count the number of rows grouped by specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to group by before counting. If no columns are specified, counts all rows in the query.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @count(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups   count  \n     \u2502 String?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            5\n   2 \u2502 bb            5\n</code></pre> <p>source</p> <p># <code>TidierDB.@distinct</code> \u2014 Macro.</p> <pre><code>@distinct(sql_query, columns...)\n</code></pre> <p>Select distinct rows based on specified column(s). Distinct works differently in TidierData vs SQL and therefore TidierDB. Distinct will also select only the only columns it is given (or all if given none)</p> <p>Arguments</p> <p><code>sql_query</code>: The SQL query to operate on. <code>columns</code>: Columns to determine uniqueness. If no columns are specified, all columns are used to identify distinct rows.</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct(value)\n         @arrange(value)\n         @collect\n       end\n5\u00d71 DataFrame\n Row \u2502 value  \n     \u2502 Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      1\n   2 \u2502      2\n   3 \u2502      3\n   4 \u2502      4\n   5 \u2502      5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct\n         @arrange(id)\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1\n   2 \u2502 AB       aa            2       0.2\n   3 \u2502 AC       bb            3       0.3\n   4 \u2502 AD       aa            4       0.4\n   5 \u2502 AE       bb            5       0.5\n   6 \u2502 AF       aa            1       0.6\n   7 \u2502 AG       bb            2       0.7\n   8 \u2502 AH       aa            3       0.8\n   9 \u2502 AI       bb            4       0.9\n  10 \u2502 AJ       aa            5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@filter</code> \u2014 Macro.</p> <pre><code>@filter(sql_query, conditions...)\n</code></pre> <p>Filter rows in a SQL table based on specified conditions.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to filter rows from.</li> <li> <p><code>conditions</code>: Expressions specifying the conditions that rows must satisfy to be included in the output.                   Rows for which the expression evaluates to <code>true</code> will be included in the result.                   Multiple conditions can be combined using logical operators (<code>&amp;&amp;</code>, <code>||</code>). It will automatically                   detect whether the conditions belong in WHERE vs HAVING. </p> <pre><code>             Temporarily, it is best to use begin and end when filtering multiple conditions. (ex 2 below)\n</code></pre> </li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @filter(percent &gt; .5)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF       aa            1       0.6\n   2 \u2502 AG       bb            2       0.7\n   3 \u2502 AH       aa            3       0.8\n   4 \u2502 AI       bb            4       0.9\n   5 \u2502 AJ       aa            5       1.0\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(mean = mean(percent))\n         @filter begin \n           groups == \"bb\" || # logical operators can still be used like this\n           mean &gt; .5\n         end\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups   mean     \n     \u2502 String?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            0.6\n   2 \u2502 bb            0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@group_by</code> \u2014 Macro.</p> <pre><code>@group_by(sql_query, columns...)\n</code></pre> <p>Group SQL table rows by specified column(s). If grouping is performed as a terminal operation without a subsequent mutatation or summarization (as in the example below), then the resulting data frame will be ungrouped when <code>@collect</code> is applied.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions specifying the columns to group by. Columns can be specified by name.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d71 DataFrame\n Row \u2502 groups  \n     \u2502 String? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa\n   2 \u2502 bb\n</code></pre> <p>source</p> <p># <code>TidierDB.@inner_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform an inner join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @inner_join(:df_join, id2, id)\n         @collect\n       end\n5\u00d77 DataFrame\n Row \u2502 id       groups   value   percent   id2      category  score  \n     \u2502 String?  String?  Int64?  Float64?  String?  String?   Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1  AA       X             88\n   2 \u2502 AC       bb            3       0.3  AC       Y             92\n   3 \u2502 AE       bb            5       0.5  AE       X             77\n   4 \u2502 AG       bb            2       0.7  AG       Y             83\n   5 \u2502 AI       bb            4       0.9  AI       X             95\n</code></pre> <p>source</p> <p># <code>TidierDB.@left_join</code> \u2014 Macro.</p> <pre><code>@left_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform a left join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @left_join(:df_join, id2, id)\n         @collect\n       end\n10\u00d77 DataFrame\n Row \u2502 id       groups   value   percent   id2      category  score   \n     \u2502 String?  String?  Int64?  Float64?  String?  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1  AA       X              88\n   2 \u2502 AC       bb            3       0.3  AC       Y              92\n   3 \u2502 AE       bb            5       0.5  AE       X              77\n   4 \u2502 AG       bb            2       0.7  AG       Y              83\n   5 \u2502 AI       bb            4       0.9  AI       X              95\n   6 \u2502 AB       aa            2       0.2  missing  missing   missing \n   7 \u2502 AD       aa            4       0.4  missing  missing   missing \n   8 \u2502 AF       aa            1       0.6  missing  missing   missing \n   9 \u2502 AH       aa            3       0.8  missing  missing   missing \n  10 \u2502 AJ       aa            5       1.0  missing  missing   missing \n</code></pre> <p>source</p> <p># <code>TidierDB.@mutate</code> \u2014 Macro.</p> <pre><code>@mutate(sql_query, exprs...)\n</code></pre> <p>Mutate SQL table rows by adding new columns or modifying existing ones.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions for mutating the table. New columns can be added or existing columns modified using column_name = expression syntax, where expression can involve existing columns.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @mutate(value = value * 4, new_col = percent^2)\n         @collect\n       end\n10\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   new_col  \n     \u2502 String?  String?  Int64?  Float64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            4       0.1      0.01\n   2 \u2502 AB       aa            8       0.2      0.04\n   3 \u2502 AC       bb           12       0.3      0.09\n   4 \u2502 AD       aa           16       0.4      0.16\n   5 \u2502 AE       bb           20       0.5      0.25\n   6 \u2502 AF       aa            4       0.6      0.36\n   7 \u2502 AG       bb            8       0.7      0.49\n   8 \u2502 AH       aa           12       0.8      0.64\n   9 \u2502 AI       bb           16       0.9      0.81\n  10 \u2502 AJ       aa           20       1.0      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@rename</code> \u2014 Macro.</p> <pre><code>@rename(sql_query, renamings...)\n</code></pre> <p>Rename one or more columns in a SQL query.</p> <p>Arguments</p> <p>-<code>sql_query</code>: The SQL query to operate on. -<code>renamings</code>: One or more pairs of old and new column names, specified as new name = old name </p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @rename(new_name = percent)\n       @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   new_name \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1\n   2 \u2502 AB       aa            2       0.2\n   3 \u2502 AC       bb            3       0.3\n   4 \u2502 AD       aa            4       0.4\n   5 \u2502 AE       bb            5       0.5\n   6 \u2502 AF       aa            1       0.6\n   7 \u2502 AG       bb            2       0.7\n   8 \u2502 AH       aa            3       0.8\n   9 \u2502 AI       bb            4       0.9\n  10 \u2502 AJ       aa            5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@right_join</code> \u2014 Macro.</p> <pre><code>@right_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform a right join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @right_join(:df_join, id2, id)\n         @collect\n       end\n7\u00d77 DataFrame\n Row \u2502 id       groups   value    percent    id2      category  score  \n     \u2502 String?  String?  Int64?   Float64?   String?  String?   Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb             1        0.1  AA       X             88\n   2 \u2502 AC       bb             3        0.3  AC       Y             92\n   3 \u2502 AE       bb             5        0.5  AE       X             77\n   4 \u2502 AG       bb             2        0.7  AG       Y             83\n   5 \u2502 AI       bb             4        0.9  AI       X             95\n   6 \u2502 missing  missing  missing  missing    AK       Y             68\n   7 \u2502 missing  missing  missing  missing    AM       X             74\n</code></pre> <p>source</p> <p># <code>TidierDB.@select</code> \u2014 Macro.</p> <pre><code>@select(sql_query, columns)\n</code></pre> <p>Select specified columns from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to select columns from.</li> <li><code>columns</code>: Expressions specifying the columns to select. Columns can be specified by name,                and new columns can be created with expressions using existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @select(groups:percent)\n         @collect\n       end\n10\u00d73 DataFrame\n Row \u2502 groups   value   percent  \n     \u2502 String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 bb            1       0.1\n   2 \u2502 aa            2       0.2\n   3 \u2502 bb            3       0.3\n   4 \u2502 aa            4       0.4\n   5 \u2502 bb            5       0.5\n   6 \u2502 aa            1       0.6\n   7 \u2502 bb            2       0.7\n   8 \u2502 aa            3       0.8\n   9 \u2502 bb            4       0.9\n  10 \u2502 aa            5       1.0\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @select(contains(\"e\"))\n         @collect\n       end\n10\u00d72 DataFrame\n Row \u2502 value   percent  \n     \u2502 Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      1       0.1\n   2 \u2502      2       0.2\n   3 \u2502      3       0.3\n   4 \u2502      4       0.4\n   5 \u2502      5       0.5\n   6 \u2502      1       0.6\n   7 \u2502      2       0.7\n   8 \u2502      3       0.8\n   9 \u2502      4       0.9\n  10 \u2502      5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_max</code> \u2014 Macro.</p> <pre><code>@slice_max(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the largest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the largest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_max(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_max(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   rank_col \n     \u2502 String?  String?  Int64?  Float64?  Int64?   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AE       bb            5       0.5         1\n   2 \u2502 AJ       aa            5       1.0         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_min</code> \u2014 Macro.</p> <pre><code>@slice_min(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the smallest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the smallest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_min(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_min(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   rank_col \n     \u2502 String?  String?  Int64?  Float64?  Int64?   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1         1\n   2 \u2502 AF       aa            1       0.6         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_sample</code> \u2014 Macro.</p> <pre><code>@slice_sample(sql_query, n)\n</code></pre> <p>Randomly select a specified number of rows from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>n</code>: The number of rows to randomly select.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_sample(n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @slice_sample()\n       @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarise</code> \u2014 Macro.</p> <pre><code>   @summarise(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((value:percent), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups   mean_value  mean_percent  sum_value  sum_percent \n     \u2502 String?  Float64?    Float64?      Int128?    Float64?    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa              3.0           0.6         15          3.0\n   2 \u2502 bb              3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups   test      n      \n     \u2502 String?  Float64?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            3.0       5\n   2 \u2502 bb            2.5       5\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarize</code> \u2014 Macro.</p> <pre><code>   @summarize(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((ends_with(\"e\"), starts_with(\"p\")), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups   mean_value  mean_percent  sum_value  sum_percent \n     \u2502 String?  Float64?    Float64?      Int128?    Float64?    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa              3.0           0.6         15          3.0\n   2 \u2502 bb              3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups   test      n      \n     \u2502 String?  Float64?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            3.0       5\n   2 \u2502 bb            2.5       5\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_frame</code> \u2014 Macro.</p> <pre><code>@window_frame(sql_query, frame_start::Int, frame_end::Int)\n</code></pre> <p>Define the window frame for window functions in a SQL query, specifying the range of rows to include in the calculation relative to the current row.</p> <p>Arguments</p> <p>sql_query: The SQL query to operate on, expected to be an instance of SQLQuery.</p> <ul> <li><code>frame_start</code>: The starting point of the window frame. A positive value indicates the start after the current row (FOLLOWING), a negative value indicates before the current row (PRECEDING), and 0 indicates the current row.</li> <li><code>frame_end</code>: The ending point of the window frame. A positive value indicates the end after the current row (FOLLOWING), a negative value indicates before the current row (PRECEDING), and 0 indicates the current row.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_order</code> \u2014 Macro.</p> <pre><code>   @window_order(sql_query, columns...)\n</code></pre> <p>Specify the order of rows for window functions within a SQL query.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by for the window function. Can include multiple columns for nested sorting. Prepend a column name with - for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; mem = duckdb_open(\":memory:\");\n\njulia&gt; db = duckdb_connect(mem);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":""},{"location":"examples/generated/UserGuide/athena/","title":"Using Athena","text":"<p>To use the Athena AWS backend with TidierDB, there are a few minimal but key changes covered here.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#connecting","title":"Connecting","text":"<p>Connection is established through AWS.jl as shwon below.</p> <pre><code>using TidierDB, AWS\nset_sql_mode(:athena)\n# Replace your credentials as needed below\naws_access_key_id = get(ENV,\"AWS_ACCESS_KEY_ID\",\"key\")\naws_secret_access_key = get(ENV, \"AWS_SECRET_ACCESS_KEY\",\"secret_key\")\naws_region = get(ENV,\"AWS_DEFAULT_REGION\",\"region\")\n\nconst AWS_GLOBAL_CONFIG = Ref{AWS.AWSConfig}()\ncreds = AWSCredentials(aws_access_key_id, aws_secret_access_key)\n\nAWS_GLOBAL_CONFIG[] = AWS.global_aws_config(region=aws_region, creds=creds)\n\ncatalog = \"AwsDataCatalog\"\nworkgroup = \"primary\"\ndb = \"demodb\"\nall_results = true\nresults_per_increment = 10\nout_loc = \"s3://location/\"\n\nathena_params = Dict(\n    \"ResultConfiguration\" =&gt; Dict(\n        \"OutputLocation\" =&gt; out_loc\n    ),\n    \"QueryExecutionContext\" =&gt; Dict(\n        \"Database\" =&gt; db,\n        \"Catalog\" =&gt; catalog\n    ),\n    \"Workgroup\" =&gt; workgroup\n)\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#db_table-differences","title":"<code>db_table</code> differences","text":"<p>There are two differences for <code>db_table</code> which are seen in the query below</p> <ol> <li>The table needs to be passed as a string in the format database.table, ie <code>\"demodb.table_name</code></li> <li><code>db_table</code> requires a third argument: the athena_params from above.</li> </ol> <pre><code>@chain db_table(AWS_GLOBAL_CONFIG[], \"demodb.table_name\", athena_params) begin\n    @filter(cyl &gt; 4)\n    @group_by(cyl)\n    @summarize(mpg = mean(mpg))\n   #@show_query\n    @collect\nend\n</code></pre> <pre><code>2\u00d72 DataFrame\n Row \u2502 cyl    mpg\n     \u2502 Int64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     6  19.7429\n   2 \u2502     8  15.1\n</code></pre> <p>I would like to acknowledge the work of Manu Francis and this blog post, which helped guide this process</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/getting_started/","title":"Getting Started","text":"<p>To use TidierDB.jl, you will have to set up a connection. TidierDB.jl gives you access to duckdb via <code>duckdb_open</code> and <code>duckdb_connect</code>. However, to use MySql, ClickHouse, MSSQL, Postgres, or SQLite, you will have to load those packages in first.</p> <p>If you plan to use TidierDB.jl with TidierData.jl or Tidier.jl, it is most convenenient to load the packages as follows:</p> <pre><code>using TidierData\nimport TidierDB as DB\n</code></pre> <p>Alternatively, <code>using Tidier</code> will import TidierDB in the above manner for you, where TidierDB functions and macros will be available as <code>DB.@mutate()</code> and so on, and the TidierData equivalent would be <code>@mutate()</code>.</p> <p>The associated databased packages used to set up connections are currently as follows</p> <ul> <li>ClickHouse: ClickHouse.jl</li> <li>MySQL and MariaDB: MySQL.jl</li> <li>MSSQL:  ODBC.jl</li> <li>Postgres: LibPQ.jl</li> <li>SQLite: SQLite.jl</li> <li>Athena: AWS.jl</li> </ul> <p>For DuckDB, SQLite, and MySQL, <code>copy_to()</code> lets you copy data to the database and query there. ClickHouse, MSSQL, and Postgres support for <code>copy_to()</code> has not been added yet.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/key_differences/","title":"Key Differences from TidierData.jl","text":"<p>There are a few important syntax and behavior differences between TidierDB.jl and TidierData.jl outlined below.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#creating-a-database","title":"Creating a database","text":"<p>For these examples we will use DuckDB, the default backend, although SQLite, Postgres, MySQL, MSSQL, and ClickHouse are possible. If you have an existing DuckDB connection, then this step is not required. For these examples, we will create a data frame and copy it to an in-memory DuckDB database.</p> <pre><code>using DataFrames, TidierDB\n\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\n mem = duckdb_open(\":memory:\");\n db = duckdb_connect(mem);\n\ncopy_to(db, df, \"df_mem\"); # copying over the data frame to an in-memory database\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#row-ordering","title":"Row ordering","text":"<p>DuckDB benefits from aggressive parallelization of pipelines. This means that if you have multiple threads enabled in Julia, which you can check or set using <code>Threads.nthreads()</code>, DuckDB will use multiple threads. However, because many operations are multi-threaded, the resulting row order is inconsistent. If row order needs to be deterministic for your use case, make sure to apply an <code>@arrange(column_name_1, column_name_2, etc...)</code> prior to collecting the results.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#starting-a-chain","title":"Starting a chain","text":"<p>When using TidierDB, <code>db_table(connection, :table_name)</code> is used to start a chain.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#grouped-mutation","title":"Grouped mutation","text":"<p>In TidierDB, when performing <code>@group_by</code> then <code>@mutate</code>, the table will be ungrouped after applying all of the mutations in the clause to the grouped data. To perform subsequent grouped operations, the user would have to regroup the data. This is demonstrated below.</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @summarize(mean_percent = mean(percent))\n    @collect\n end\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentString?Float64?1bb0.52aa0.6 <p>Regrouping following <code>@mutate</code></p> <pre><code>@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @mutate(max = maximum(percent), min = minimum(percent))\n    @group_by(groups)\n    @summarise(mean_percent = mean(percent))\n    @collect\nend\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentString?Float64?1bb0.52aa0.6 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#joining","title":"Joining","text":"<p>There are 2 key differences for joining:</p> <ol> <li>When joining 2 tables, the new table you are choosing to join must be prefixed with a colon.</li> <li>The column on both the new and old table must be specified. They do not need to be the same, and given SQL behavior where both columns are kept when joining two tables, it is preferable if they have different names. This avoids \"ambiguous reference\" errors that would otherwise come up and complicate the use of tidy selection for columns.</li> </ol> <pre><code>df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\n copy_to(db, df2, \"df_join\");\n\n@chain db_table(db, :df_mem) begin\n    @left_join(:df_join, id2, id)\n    @collect\nend\n</code></pre> 10\u00d77 DataFrame Rowidgroupsvaluepercentid2categoryscoreString?String?Int64?Float64?String?String?Int64?1AAbb10.1AAX882ACbb30.3ACY923AEbb50.5AEX774AGbb20.7AGY835AIbb40.9AIX956ABaa20.2missingmissingmissing7ADaa40.4missingmissingmissing8AFaa10.6missingmissingmissing9AHaa30.8missingmissingmissing10AJaa51.0missingmissingmissing <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#differences-in-case_when","title":"Differences in <code>case_when()</code>","text":"<p>In TidierDB, after the clause is completed, the result for the new column should is separated by a comma <code>,</code> in contrast to TidierData.jl, where the result for the new column is separated by a <code>=&gt;</code> .</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @mutate(new_col = case_when(percent &gt; .5, \"Pass\",  # in TidierData, percent &gt; .5 =&gt; \"Pass\",\n                                percent &lt;= .5, \"Try Again\", # percent &lt;= .5 =&gt; \"Try Again\"\n                                true, \"middle\"))\n    @collect\n end\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentnew_colString?String?Int64?Float64?String?1AAbb10.1Try Again2ABaa20.2Try Again3ACbb30.3Try Again4ADaa40.4Try Again5AEbb50.5Try Again6AFaa10.6Pass7AGbb20.7Pass8AHaa30.8Pass9AIbb40.9Pass10AJaa51.0Pass <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#interpolation","title":"Interpolation","text":"<p>To use !! Interpolation, instead of being able to define the alternate names/value in the global context, the user has to <code>add_interp_parameter!</code>. This will hopefully be fixed in future versions. Otherwise, the behavior is the same.</p> <p>Also, when using interpolation with exponenents, the interpolated value must go inside of parenthesis.</p> <pre><code>add_interp_parameter!(:test, :percent) # this still supports strings, vectors of names, and values\n\n@chain db_table(db, :df_mem) begin\n    @mutate(new_col = case_when((!!test)^2 &gt; .5, \"Pass\",\n                                (!!test)^2 &lt; .5, \"Try Again\",\n                                \"middle\"))\n    @collect\nend\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentnew_colString?String?Int64?Float64?String?1AAbb10.1Try Again2ABaa20.2Try Again3ACbb30.3Try Again4ADaa40.4Try Again5AEbb50.5Try Again6AFaa10.6Try Again7AGbb20.7Try Again8AHaa30.8Pass9AIbb40.9Pass10AJaa51.0Pass <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#slicing-ties","title":"Slicing ties","text":"<p><code>slice_min()</code> and <code>@slice_max()</code> will always return ties due to SQL behavior.</p> <p>This page was generated using Literate.jl.</p>"}]}