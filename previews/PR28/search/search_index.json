{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-tidierdbjl","title":"What is TidierDB.jl?","text":"<p>TiderDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package.</p> <p>The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.</p> <p></p> <p></p>"},{"location":"#currently-supported-backends-include","title":"Currently supported backends include:","text":"<ul> <li>DuckDB (the default) <code>set_sql_mode(:duckdb)</code></li> <li>ClickHouse <code>set_sql_mode(:clickhouse)</code></li> <li>SQLite <code>set_sql_mode(:lite)</code></li> <li>MySQL and MariaDB <code>set_sql_mode(:mysql)</code></li> <li>MSSQL <code>set_sql_mode(:mssql)</code></li> <li>Postgres <code>set_sql_mode(:postgres)</code></li> <li>Athena <code>set_sql_mode(:athena)</code></li> <li>Google Big Query <code>set_sql_mode(:gbq)</code></li> <li>Oracle <code>set_sql_mode(:oracle)</code></li> </ul> <p>The style of SQL that is generated can be modified using <code>set_sql_mode()</code>.</p> <p></p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>For the stable version:</p> <pre><code>] add TidierDB\n</code></pre> <p>TidierDB.jl currently supports the following top-level macros:</p> <ul> <li><code>@arrange</code></li> <li><code>@group_by</code></li> <li><code>@filter</code></li> <li><code>@select</code></li> <li><code>@mutate</code>, which supports <code>across()</code></li> <li><code>@summarize</code> and <code>@summarise</code>, which supports <code>across()</code></li> <li><code>@distinct</code></li> <li><code>@left_join</code>, <code>@right_join</code>, <code>@inner_join</code>, <code>@anti_join</code>, <code>@full_join</code>, and <code>@semi_join</code> (slight syntax differences from TidierData.jl)</li> <li><code>@count</code></li> <li><code>@slice_min</code>, <code>@slice_max</code>, <code>@slice_sample</code></li> <li><code>@window_order</code> and <code>window_frame</code></li> <li><code>@show_query</code></li> <li><code>@collect</code></li> </ul> <p>Supported helper functions for most backends include:</p> <ul> <li><code>across()</code></li> <li><code>desc()</code></li> <li><code>if_else()</code> and <code>case_when()</code></li> <li><code>n()</code></li> <li><code>starts_with()</code>, <code>ends_with()</code>, and <code>contains()</code></li> <li><code>as_float()</code>, <code>as_integer()</code>, and <code>as_string()</code></li> <li><code>is_missing()</code></li> <li><code>missing_if()</code> and <code>replace_missing()</code></li> </ul> <p>From TidierStrings.jl:</p> <ul> <li><code>str_detect</code>, <code>str_replace</code>, <code>str_replace_all</code>, <code>str_remove_all</code>, <code>str_remove</code></li> </ul> <p>From TidierDates.jl:</p> <ul> <li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>min</code>, <code>second</code>, <code>floor_date</code>, <code>difftime</code></li> </ul> <p>Supported aggregate functions (as supported by the backend) with more to come</p> <ul> <li><code>mean</code>, <code>minimium</code>, <code>maximum</code>, <code>std</code>, <code>sum</code>, <code>cumsum</code>, <code>cor</code>, <code>cov</code>, <code>var</code></li> <li><code>@summarize</code> supports any SQL aggregate function in addition to the list above. Simply write the function as written in SQL syntax and it will work</li> <li><code>copy_to</code> (for DuckDB, MySQL, SQLite)</li> </ul> <p>DuckDB specifically enables copy_to to directly reading in <code>.parquet</code>, <code>.json</code>, <code>.csv</code>, and <code>.arrow</code> file, including https file paths.</p> <pre><code>path = \"file_path.parquet\"\ncopy_to(conn, file_path, \"table_name\")\n</code></pre> <p></p> <p></p>"},{"location":"#what-is-the-recommended-way-to-use-tidierdb","title":"What is the recommended way to use TidierDB?","text":"<p>Typically, you will want to use TidierDB alongside TidierData because there are certain functionality (such as pivoting) which are only supported in TidierData and can only be performed on data frames.</p> <p>Our recommended path for using TidierDB is to import the package so that there are no namespace conflicts with TidierData. Once TidierDB is integrated with Tidier, then Tidier will automatically load the packages in this fashion.</p> <p>First, let's develop and execute a query using TidierDB. Notice that all top-level macros and functions originating from TidierDB start with a <code>DB</code> prefix. Any functions defined within macros do not need to be prefixed within <code>DB</code> because they are actually pseudofunctions that are in actuality converted into SQL code.</p> <p>Even though the code reads similarly to TidierData, note that no computational work actually occurs until you run <code>DB.@collect()</code>, which runs the SQL query and instantiates the result as a DataFrame.</p> <pre><code>using TidierData\nimport TidierDB as DB\n\ndb = DB.connect(:duckdb);\npath = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\nDB.copy_to(db, path, \"mtcars\");\n\n@chain DB.db_table(db, :mtcars) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\nend\n</code></pre> <pre><code>2\u00d75 DataFrame\n Row \u2502 cyl     mpg       mpg_squared  mpg_rounded  mpg_efficiency \n     \u2502 Int64?  Float64?  Float64?     Float64?     String?        \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4   27.3444      747.719         27.0  efficient\n   2 \u2502      6   19.7333      389.404         20.0  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-if-we-wanted-to-pivot-the-result","title":"What if we wanted to pivot the result?","text":"<p>We cannot do this using TidierDB. However, we can call <code>@pivot_longer()</code> from TidierData after the result of the query has been instantiated as a DataFrame, like this: </p> <pre><code>@chain DB.db_table(db, :mtcars) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@collect\n    @pivot_longer(everything(), names_to = \"variable\", values_to = \"value\")\nend\n</code></pre> <pre><code>10\u00d72 DataFrame\n Row \u2502 variable        value     \n     \u2502 String          Any       \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 cyl             4\n   2 \u2502 cyl             6\n   3 \u2502 mpg             27.3444\n   4 \u2502 mpg             19.7333\n   5 \u2502 mpg_squared     747.719\n   6 \u2502 mpg_squared     389.404\n   7 \u2502 mpg_rounded     27.0\n   8 \u2502 mpg_rounded     20.0\n   9 \u2502 mpg_efficiency  efficient\n  10 \u2502 mpg_efficiency  moderate\n</code></pre> <p></p> <p></p>"},{"location":"#what-sql-query-does-tidierdb-generate-for-a-given-piece-of-julia-code","title":"What SQL query does TidierDB generate for a given piece of Julia code?","text":"<p>We can replace <code>DB.collect()</code> with <code>DB.@show_query</code> to reveal the underlying SQL query being generated by TidierDB. To handle complex queries, TidierDB makes heavy use of Common Table Expressions (CTE), which are a useful tool to organize long queries.</p> <pre><code>@chain DB.db_table(db, :mtcars) begin\n    DB.@filter(!starts_with(model, \"M\"))\n    DB.@group_by(cyl)\n    DB.@summarize(mpg = mean(mpg))\n    DB.@mutate(mpg_squared = mpg^2, \n               mpg_rounded = round(mpg), \n               mpg_efficiency = case_when(\n                                 mpg &gt;= cyl^2 , \"efficient\",\n                                 mpg &lt; 15.2 , \"inefficient\",\n                                 \"moderate\"))            \n    DB.@filter(mpg_efficiency in (\"moderate\", \"efficient\"))\n    DB.@arrange(desc(mpg_rounded))\n    DB.@show_query\nend\n</code></pre> <pre><code>WITH cte_1 AS (\nSELECT *\n        FROM mtcars\n        WHERE NOT (starts_with(model, 'M'))),\ncte_2 AS (\nSELECT cyl, AVG(mpg) AS mpg\n        FROM cte_1\n        GROUP BY cyl),\ncte_3 AS (\nSELECT  cyl, mpg, POWER(mpg, 2) AS mpg_squared, ROUND(mpg) AS mpg_rounded, CASE WHEN mpg &gt;= POWER(cyl, 2) THEN 'efficient' WHEN mpg &lt; 15.2 THEN 'inefficient' ELSE 'moderate' END AS mpg_efficiency\n        FROM cte_2 ),\ncte_4 AS (\nSELECT *\n        FROM cte_3\n        WHERE mpg_efficiency in ('moderate', 'efficient'))  \nSELECT *\n        FROM cte_4  \n        ORDER BY mpg_rounded DESC\n</code></pre> <p></p> <p></p>"},{"location":"#tidierdb-is-already-quite-fully-featured-supporting-advanced-tidierdata-functions-like-across-for-multi-column-selection","title":"TidierDB is already quite fully-featured, supporting advanced TidierData functions like <code>across()</code> for multi-column selection.","text":"<pre><code>@chain DB.db_table(db, :mtcars) begin\n    DB.@group_by(cyl)\n    DB.@summarize(across((starts_with(\"a\"), ends_with(\"s\")), (mean, sum)))\n    DB.@collect\nend\n</code></pre> <pre><code>3\u00d75 DataFrame\n Row \u2502 cyl     mean_am   mean_vs   sum_am   sum_vs  \n     \u2502 Int64?  Float64?  Float64?  Int128?  Int128? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      4  0.727273  0.909091        8       10\n   2 \u2502      6  0.428571  0.571429        3        4\n   3 \u2502      8  0.142857  0.0             2        0\n</code></pre> <p>Bang bang <code>!!</code> interpolation for columns and values is also supported.</p> <p>There are a few subtle but important differences from Tidier.jl outlined here.</p> <p></p> <p></p>"},{"location":"#missing-a-function-or-backend","title":"Missing a function or backend?","text":"<p>You can use any existing SQL function within <code>@mutate</code> with the correct SQL syntax and it should just work.</p> <p>But if you run into problems please open an issue, and we will be happy to take a look!</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>TidierDB.connect</code></li> <li><code>TidierDB.copy_to</code></li> <li><code>TidierDB.@anti_join</code></li> <li><code>TidierDB.@arrange</code></li> <li><code>TidierDB.@count</code></li> <li><code>TidierDB.@distinct</code></li> <li><code>TidierDB.@filter</code></li> <li><code>TidierDB.@full_join</code></li> <li><code>TidierDB.@group_by</code></li> <li><code>TidierDB.@inner_join</code></li> <li><code>TidierDB.@interpolate</code></li> <li><code>TidierDB.@left_join</code></li> <li><code>TidierDB.@mutate</code></li> <li><code>TidierDB.@rename</code></li> <li><code>TidierDB.@right_join</code></li> <li><code>TidierDB.@select</code></li> <li><code>TidierDB.@semi_join</code></li> <li><code>TidierDB.@slice_max</code></li> <li><code>TidierDB.@slice_min</code></li> <li><code>TidierDB.@slice_sample</code></li> <li><code>TidierDB.@summarise</code></li> <li><code>TidierDB.@summarize</code></li> <li><code>TidierDB.@window_frame</code></li> <li><code>TidierDB.@window_order</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>TidierDB.connect</code> \u2014 Method.</p> <pre><code>connect(backend::Symbol; kwargs...)\n</code></pre> <p>This function establishes a database connection based on the specified backend and connection parameters and sets the SQL mode</p> <p>Arguments</p> <ul> <li> <p><code>backend</code>: A symbol specifying the database backend to connect to. Supported backends are:</p> <ul> <li><code>:duckdb</code>, <code>:lite</code>(SQLite), <code>:mssql</code>, <code>mysql</code>(for MariaDB and MySQL), <code>:clickhouse</code>, <code>:postgres</code></li> <li> <p><code>kwargs</code>: Keyword arguments specifying the connection parameters for the selected backend. The required parameters vary depending on the backend:</p> </li> <li> <p>MySQL:</p> <ul> <li><code>host</code>: The host name or IP address of the MySQL server. Default is \"localhost\".</li> <li><code>user</code>: The username for authentication. Default is an empty string.</li> <li><code>password</code>: The password for authentication.</li> <li><code>db</code>: The name of the database to connect to (optional).</li> <li><code>port</code>: The port number of the MySQL server (optional).</li> </ul> </li> </ul> </li> </ul> <p>Returns</p> <ul> <li>A database connection object based on the selected backend.</li> </ul> <p>Examples</p> <pre><code>**Connect to MySQL**\n\n**conn = connect(:mysql; host=\"localhost\", user=\"root\", password=\"password\", db=\"mydb\")**\n\n**Connect to PostgreSQL using LibPQ**\n\n**conn = connect(:postgres; host=\"localhost\", dbname=\"mydb\", user=\"postgres\", password=\"password\")**\n\n**Connect to ClickHouse**\n\n**conn = connect(:clickhouse; host=\"localhost\", port=9000, database=\"mydb\", user=\"default\", password=\"\")**\n\n**Connect to SQLite**\n\n**conn = connect(:lite)**\n\n**Connect to Google Big Query**\n\n**conn = connect(:gbq, \"json*user*key*path\", \"project*id\")**\n\n**Connect to DuckDB**\n\njulia&gt; db = connect(:duckdb) DuckDB.Connection(\":memory:\")\n\n\n&lt;a target='_blank' href='https://github.com/TidierOrg/TidierDB.jl/blob/45ca09f6588636d43f5402c321caeda843b78232/src/TidierDB.jl#L324-L358' class='documenter-source'&gt;source&lt;/a&gt;&lt;br&gt;\n\n&lt;a id='TidierDB.copy_to-Tuple{Any, Union{AbstractString, DataFrame}, String}' href='#TidierDB.copy_to-Tuple{Any, Union{AbstractString, DataFrame}, String}'&gt;#&lt;/a&gt;\n**`TidierDB.copy_to`** &amp;mdash; *Method*.\n\n\n\n```julia\n   copy_to(conn, df_or_path, \"name\")\n</code></pre> <p>Allows user to copy a df to the database connection. Currently supports DuckDB, SQLite, MySql</p> <p>Arguments</p> <p>-<code>conn</code>: the database connection -<code>df</code>: dataframe to be copied or path to serve as source. With DuckDB, path supports .csv, .json, .parquet to be used without copying intermediary df. -<code>name</code>: name as string for the database to be used</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"test\");\n</code></pre> <p>source</p> <p># <code>TidierDB.@anti_join</code> \u2014 Macro.</p> <pre><code>@anti_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform an anti join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n        @anti_join(df_join, id2, id)\n        @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AB       aa            2       0.2\n   2 \u2502 AD       aa            4       0.4\n   3 \u2502 AF       aa            1       0.6\n   4 \u2502 AH       aa            3       0.8\n   5 \u2502 AJ       aa            5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@arrange</code> \u2014 Macro.</p> <pre><code>@arrange(sql_query, columns...)\n</code></pre> <p>Order SQL table rows based on specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by. Can include multiple columns for nested sorting. Wrap column name with <code>desc()</code> for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @arrange(value, desc(percent))\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF       aa            1       0.6\n   2 \u2502 AA       bb            1       0.1\n   3 \u2502 AG       bb            2       0.7\n   4 \u2502 AB       aa            2       0.2\n   5 \u2502 AH       aa            3       0.8\n   6 \u2502 AC       bb            3       0.3\n   7 \u2502 AI       bb            4       0.9\n   8 \u2502 AD       aa            4       0.4\n   9 \u2502 AJ       aa            5       1.0\n  10 \u2502 AE       bb            5       0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@count</code> \u2014 Macro.</p> <pre><code>@count(sql_query, columns...)\n</code></pre> <p>Count the number of rows grouped by specified column(s).</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to group by before counting. If no columns are specified, counts all rows in the query.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @count(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups   count  \n     \u2502 String?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            5\n   2 \u2502 bb            5\n</code></pre> <p>source</p> <p># <code>TidierDB.@distinct</code> \u2014 Macro.</p> <pre><code>@distinct(sql_query, columns...)\n</code></pre> <p>Select distinct rows based on specified column(s). Distinct works differently in TidierData vs SQL and therefore TidierDB. Distinct will also select only the only columns it is given (or all if given none)</p> <p>Arguments</p> <p><code>sql_query</code>: The SQL query to operate on. <code>columns</code>: Columns to determine uniqueness. If no columns are specified, all columns are used to identify distinct rows.</p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct(value)\n         @arrange(value)\n         @collect\n       end\n5\u00d71 DataFrame\n Row \u2502 value  \n     \u2502 Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      1\n   2 \u2502      2\n   3 \u2502      3\n   4 \u2502      4\n   5 \u2502      5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @distinct\n         @arrange(id)\n         @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1\n   2 \u2502 AB       aa            2       0.2\n   3 \u2502 AC       bb            3       0.3\n   4 \u2502 AD       aa            4       0.4\n   5 \u2502 AE       bb            5       0.5\n   6 \u2502 AF       aa            1       0.6\n   7 \u2502 AG       bb            2       0.7\n   8 \u2502 AH       aa            3       0.8\n   9 \u2502 AI       bb            4       0.9\n  10 \u2502 AJ       aa            5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@filter</code> \u2014 Macro.</p> <pre><code>@filter(sql_query, conditions...)\n</code></pre> <p>Filter rows in a SQL table based on specified conditions.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to filter rows from.</li> <li> <p><code>conditions</code>: Expressions specifying the conditions that rows must satisfy to be included in the output.                   Rows for which the expression evaluates to <code>true</code> will be included in the result.                   Multiple conditions can be combined using logical operators (<code>&amp;&amp;</code>, <code>||</code>). It will automatically                   detect whether the conditions belong in WHERE vs HAVING. </p> <pre><code>             Temporarily, it is best to use begin and end when filtering multiple conditions. (ex 2 below)\n</code></pre> </li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @filter(percent &gt; .5)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AF       aa            1       0.6\n   2 \u2502 AG       bb            2       0.7\n   3 \u2502 AH       aa            3       0.8\n   4 \u2502 AI       bb            4       0.9\n   5 \u2502 AJ       aa            5       1.0\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(mean = mean(percent))\n         @filter begin \n           groups == \"bb\" || # logical operators can still be used like this\n           mean &gt; .5\n         end\n         @arrange(groups)\n         @collect\n       end\n2\u00d72 DataFrame\n Row \u2502 groups   mean     \n     \u2502 String?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            0.6\n   2 \u2502 bb            0.5\n</code></pre> <p>source</p> <p># <code>TidierDB.@full_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform an full join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @full_join(df_join, id2, id)\n         @collect\n       end\n12\u00d77 DataFrame\n Row \u2502 id       groups   value    percent    id2      category  score   \n     \u2502 String?  String?  Int64?   Float64?   String?  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb             1        0.1  AA       X              88\n   2 \u2502 AC       bb             3        0.3  AC       Y              92\n   3 \u2502 AE       bb             5        0.5  AE       X              77\n   4 \u2502 AG       bb             2        0.7  AG       Y              83\n   5 \u2502 AI       bb             4        0.9  AI       X              95\n   6 \u2502 AB       aa             2        0.2  missing  missing   missing \n   7 \u2502 AD       aa             4        0.4  missing  missing   missing \n   8 \u2502 AF       aa             1        0.6  missing  missing   missing \n   9 \u2502 AH       aa             3        0.8  missing  missing   missing \n  10 \u2502 AJ       aa             5        1.0  missing  missing   missing \n  11 \u2502 missing  missing  missing  missing    AK       Y              68\n  12 \u2502 missing  missing  missing  missing    AM       X              74\n</code></pre> <p>source</p> <p># <code>TidierDB.@group_by</code> \u2014 Macro.</p> <pre><code>@group_by(sql_query, columns...)\n</code></pre> <p>Group SQL table rows by specified column(s). If grouping is performed as a terminal operation without a subsequent mutatation or summarization (as in the example below), then the resulting data frame will be ungrouped when <code>@collect</code> is applied.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions specifying the columns to group by. Columns can be specified by name.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @arrange(groups)\n         @collect\n       end\n2\u00d71 DataFrame\n Row \u2502 groups  \n     \u2502 String? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa\n   2 \u2502 bb\n</code></pre> <p>source</p> <p># <code>TidierDB.@inner_join</code> \u2014 Macro.</p> <pre><code>@inner_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform an inner join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @inner_join(df_join, id2, id)\n         @collect\n       end\n5\u00d77 DataFrame\n Row \u2502 id       groups   value   percent   id2      category  score  \n     \u2502 String?  String?  Int64?  Float64?  String?  String?   Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1  AA       X             88\n   2 \u2502 AC       bb            3       0.3  AC       Y             92\n   3 \u2502 AE       bb            5       0.5  AE       X             77\n   4 \u2502 AG       bb            2       0.7  AG       Y             83\n   5 \u2502 AI       bb            4       0.9  AI       X             95\n</code></pre> <p>source</p> <p># <code>TidierDB.@interpolate</code> \u2014 Macro.</p> <pre><code>@interpolate(args...)\n</code></pre> <p>Interpolate parameters into expressions for database queries.</p> <p>Arguments</p> <ul> <li> <p><code>args...</code>: A variable number of tuples. Each tuple should contain:</p> <ul> <li><code>name</code>: The name of the parameter to interpolate.</li> <li><code>value</code>: (Any): The value/vector to interpolate for the corresponding parameter name.</li> </ul> </li> </ul> <p>Example</p> <pre><code>julia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; col_names = [:id, :value, :percent];\n\njulia&gt; cond1 = .2;\n\njulia&gt; cond2 = 5;\n\njulia&gt; @interpolate((condition1, cond1), (columns, col_names), (condition2, cond2));\n\njulia&gt; @chain db_table(db, \"df_mem\") begin \n          @select(!!columns)\n          @filter begin \n              percent &lt; !!condition1\n              value &lt; !!condition2\n          end\n          @collect\n          end\n1\u00d73 DataFrame\n Row \u2502 id       value   percent  \n     \u2502 String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA            1       0.1\n</code></pre> <p>source</p> <p># <code>TidierDB.@left_join</code> \u2014 Macro.</p> <pre><code>@left_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform a left join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @left_join(df_join, id2, id)\n         @collect\n       end\n10\u00d77 DataFrame\n Row \u2502 id       groups   value   percent   id2      category  score   \n     \u2502 String?  String?  Int64?  Float64?  String?  String?   Int64?  \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1  AA       X              88\n   2 \u2502 AC       bb            3       0.3  AC       Y              92\n   3 \u2502 AE       bb            5       0.5  AE       X              77\n   4 \u2502 AG       bb            2       0.7  AG       Y              83\n   5 \u2502 AI       bb            4       0.9  AI       X              95\n   6 \u2502 AB       aa            2       0.2  missing  missing   missing \n   7 \u2502 AD       aa            4       0.4  missing  missing   missing \n   8 \u2502 AF       aa            1       0.6  missing  missing   missing \n   9 \u2502 AH       aa            3       0.8  missing  missing   missing \n  10 \u2502 AJ       aa            5       1.0  missing  missing   missing \n</code></pre> <p>source</p> <p># <code>TidierDB.@mutate</code> \u2014 Macro.</p> <pre><code>@mutate(sql_query, exprs...)\n</code></pre> <p>Mutate SQL table rows by adding new columns or modifying existing ones.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions for mutating the table. New columns can be added or existing columns modified using column_name = expression syntax, where expression can involve existing columns.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @mutate(value = value * 4, new_col = percent^2)\n         @collect\n       end\n10\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   new_col  \n     \u2502 String?  String?  Int64?  Float64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            4       0.1      0.01\n   2 \u2502 AB       aa            8       0.2      0.04\n   3 \u2502 AC       bb           12       0.3      0.09\n   4 \u2502 AD       aa           16       0.4      0.16\n   5 \u2502 AE       bb           20       0.5      0.25\n   6 \u2502 AF       aa            4       0.6      0.36\n   7 \u2502 AG       bb            8       0.7      0.49\n   8 \u2502 AH       aa           12       0.8      0.64\n   9 \u2502 AI       bb           16       0.9      0.81\n  10 \u2502 AJ       aa           20       1.0      1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@rename</code> \u2014 Macro.</p> <pre><code>@rename(sql_query, renamings...)\n</code></pre> <p>Rename one or more columns in a SQL query.</p> <p>Arguments</p> <p>-<code>sql_query</code>: The SQL query to operate on. -<code>renamings</code>: One or more pairs of old and new column names, specified as new name = old name </p> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @rename(new_name = percent)\n       @collect\n       end\n10\u00d74 DataFrame\n Row \u2502 id       groups   value   new_name \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1\n   2 \u2502 AB       aa            2       0.2\n   3 \u2502 AC       bb            3       0.3\n   4 \u2502 AD       aa            4       0.4\n   5 \u2502 AE       bb            5       0.5\n   6 \u2502 AF       aa            1       0.6\n   7 \u2502 AG       bb            2       0.7\n   8 \u2502 AH       aa            3       0.8\n   9 \u2502 AI       bb            4       0.9\n  10 \u2502 AJ       aa            5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@right_join</code> \u2014 Macro.</p> <pre><code>@right_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform a right join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @right_join(df_join, id2, id)\n         @collect\n       end\n7\u00d77 DataFrame\n Row \u2502 id       groups   value    percent    id2      category  score  \n     \u2502 String?  String?  Int64?   Float64?   String?  String?   Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb             1        0.1  AA       X             88\n   2 \u2502 AC       bb             3        0.3  AC       Y             92\n   3 \u2502 AE       bb             5        0.5  AE       X             77\n   4 \u2502 AG       bb             2        0.7  AG       Y             83\n   5 \u2502 AI       bb             4        0.9  AI       X             95\n   6 \u2502 missing  missing  missing  missing    AK       Y             68\n   7 \u2502 missing  missing  missing  missing    AM       X             74\n</code></pre> <p>source</p> <p># <code>TidierDB.@select</code> \u2014 Macro.</p> <pre><code>@select(sql_query, columns)\n</code></pre> <p>Select specified columns from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to select columns from.</li> <li><code>columns</code>: Expressions specifying the columns to select. Columns can be specified by name,                and new columns can be created with expressions using existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @select(groups:percent)\n         @collect\n       end\n10\u00d73 DataFrame\n Row \u2502 groups   value   percent  \n     \u2502 String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 bb            1       0.1\n   2 \u2502 aa            2       0.2\n   3 \u2502 bb            3       0.3\n   4 \u2502 aa            4       0.4\n   5 \u2502 bb            5       0.5\n   6 \u2502 aa            1       0.6\n   7 \u2502 bb            2       0.7\n   8 \u2502 aa            3       0.8\n   9 \u2502 bb            4       0.9\n  10 \u2502 aa            5       1.0\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @select(contains(\"e\"))\n         @collect\n       end\n10\u00d72 DataFrame\n Row \u2502 value   percent  \n     \u2502 Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502      1       0.1\n   2 \u2502      2       0.2\n   3 \u2502      3       0.3\n   4 \u2502      4       0.4\n   5 \u2502      5       0.5\n   6 \u2502      1       0.6\n   7 \u2502      2       0.7\n   8 \u2502      3       0.8\n   9 \u2502      4       0.9\n  10 \u2502      5       1.0\n</code></pre> <p>source</p> <p># <code>TidierDB.@semi_join</code> \u2014 Macro.</p> <pre><code>@semi_join(sql_query, join_table, new_table_col, orignal_table_col)\n</code></pre> <p>Perform an semi join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The primary SQL query to operate on.</li> <li><code>join_table</code>: The secondary SQL table to join with the primary query table.</li> <li><code>new_table_col</code>: Column from the new table that matches for join.</li> <li><code>orignal_table_col</code>: Column from the original table that matches for join.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; copy_to(db, df2, \"df_join\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @semi_join(df_join, id2, id)\n         @collect\n       end\n5\u00d74 DataFrame\n Row \u2502 id       groups   value   percent  \n     \u2502 String?  String?  Int64?  Float64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1\n   2 \u2502 AC       bb            3       0.3\n   3 \u2502 AE       bb            5       0.5\n   4 \u2502 AG       bb            2       0.7\n   5 \u2502 AI       bb            4       0.9\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_max</code> \u2014 Macro.</p> <pre><code>@slice_max(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the largest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the largest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_max(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_max(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   rank_col \n     \u2502 String?  String?  Int64?  Float64?  Int64?   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AE       bb            5       0.5         1\n   2 \u2502 AJ       aa            5       1.0         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_min</code> \u2014 Macro.</p> <pre><code>@slice_min(sql_query, column, n = 1)\n</code></pre> <p>Select rows with the smallest values in specified column. This will always return ties. </p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>column</code>: Column to identify the smallest values.</li> <li><code>n</code>: The number of rows to select with the smallest values for each specified column. Default is 1, which selects the row with the smallest value.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_min(value, n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @slice_min(value)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   rank_col \n     \u2502 String?  String?  Int64?  Float64?  Int64?   \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1         1\n   2 \u2502 AF       aa            1       0.6         1\n</code></pre> <p>source</p> <p># <code>TidierDB.@slice_sample</code> \u2014 Macro.</p> <pre><code>@slice_sample(sql_query, n)\n</code></pre> <p>Randomly select a specified number of rows from a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>n</code>: The number of rows to randomly select.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @slice_sample(n = 2)\n         @collect\n       end;\n\njulia&gt; @chain db_table(db, :df_mem) begin\n       @slice_sample()\n       @collect\n       end;\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarise</code> \u2014 Macro.</p> <pre><code>   @summarise(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((value:percent), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups   mean_value  mean_percent  sum_value  sum_percent \n     \u2502 String?  Float64?    Float64?      Int128?    Float64?    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa              3.0           0.6         15          3.0\n   2 \u2502 bb              3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups   test      n      \n     \u2502 String?  Float64?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            3.0       5\n   2 \u2502 bb            2.5       5\n</code></pre> <p>source</p> <p># <code>TidierDB.@summarize</code> \u2014 Macro.</p> <pre><code>   @summarize(sql_query, exprs...)\n</code></pre> <p>Aggregate and summarize specified columns of a SQL table.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>exprs</code>: Expressions defining the aggregation and summarization operations. These can specify simple aggregations like mean, sum, and count, or more complex expressions involving existing column values.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(across((ends_with(\"e\"), starts_with(\"p\")), (mean, sum)))\n         @arrange(groups)\n         @collect\n       end\n2\u00d75 DataFrame\n Row \u2502 groups   mean_value  mean_percent  sum_value  sum_percent \n     \u2502 String?  Float64?    Float64?      Int128?    Float64?    \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa              3.0           0.6         15          3.0\n   2 \u2502 bb              3.0           0.5         15          2.5\n\njulia&gt; @chain db_table(db, :df_mem) begin\n         @group_by(groups)\n         @summarise(test = sum(percent), n = n())\n         @arrange(groups)\n         @collect\n       end\n2\u00d73 DataFrame\n Row \u2502 groups   test      n      \n     \u2502 String?  Float64?  Int64? \n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 aa            3.0       5\n   2 \u2502 bb            2.5       5\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_frame</code> \u2014 Macro.</p> <pre><code>@window_frame(sql_query, frame_start::Int, frame_end::Int)\n</code></pre> <p>Define the window frame for window functions in a SQL query, specifying the range of rows to include in the calculation relative to the current row.</p> <p>Arguments</p> <p>sql_query: The SQL query to operate on, expected to be an instance of SQLQuery.</p> <ul> <li><code>frame_start</code>: The starting point of the window frame. A positive value indicates the start after the current row (FOLLOWING), a negative value indicates before the current row (PRECEDING), and 0 indicates the current row.</li> <li><code>frame_end</code>: The ending point of the window frame. A positive value indicates the end after the current row (FOLLOWING), a negative value indicates before the current row (PRECEDING), and 0 indicates the current row.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n</code></pre> <p>source</p> <p># <code>TidierDB.@window_order</code> \u2014 Macro.</p> <pre><code>   @window_order(sql_query, columns...)\n</code></pre> <p>Specify the order of rows for window functions within a SQL query.</p> <p>Arguments</p> <ul> <li><code>sql_query</code>: The SQL query to operate on.</li> <li><code>columns</code>: Columns to order the rows by for the window function. Can include multiple columns for nested sorting. Prepend a column name with - for descending order.</li> </ul> <p>Examples</p> <pre><code>julia&gt; df = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9], \n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10], \n                        value = repeat(1:5, 2), \n                        percent = 0.1:0.1:1.0);\n\njulia&gt; db = connect(:duckdb);\n\njulia&gt; copy_to(db, df, \"df_mem\");\n</code></pre> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":""},{"location":"examples/generated/UserGuide/athena/","title":"Using Athena","text":"<p>To use the Athena AWS backend with TidierDB, set up and a small syntax difference are covered here.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#connecting","title":"Connecting","text":"<p>Connection is established through AWS.jl as shwon below.</p> <pre><code>using TidierDB, AWS\nset_sql_mode(:athena)\n# Replace your credentials as needed below\naws_access_key_id = get(ENV,\"AWS_ACCESS_KEY_ID\",\"key\")\naws_secret_access_key = get(ENV, \"AWS_SECRET_ACCESS_KEY\",\"secret_key\")\naws_region = get(ENV,\"AWS_DEFAULT_REGION\",\"region\")\n\nconst AWS_GLOBAL_CONFIG = Ref{AWS.AWSConfig}()\ncreds = AWSCredentials(aws_access_key_id, aws_secret_access_key)\n\nAWS_GLOBAL_CONFIG[] = AWS.global_aws_config(region=aws_region, creds=creds)\n\ncatalog = \"AwsDataCatalog\"\nworkgroup = \"primary\"\ndb = \"demodb\"\nall_results = true\nresults_per_increment = 10\nout_loc = \"s3://location/\"\n\nathena_params = Dict(\n    \"ResultConfiguration\" =&gt; Dict(\n        \"OutputLocation\" =&gt; out_loc\n    ),\n    \"QueryExecutionContext\" =&gt; Dict(\n        \"Database\" =&gt; db,\n        \"Catalog\" =&gt; catalog\n    ),\n    \"Workgroup\" =&gt; workgroup\n)\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#db_table-differences","title":"<code>db_table</code> differences","text":"<p>There are two differences for <code>db_table</code> which are seen in the query below</p> <ol> <li>The table needs to be passed as a string in the format database.table, ie <code>\"demodb.table_name</code></li> <li><code>db_table</code> requires a third argument: the athena_params from above.</li> </ol> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/athena/#leveraging-from_query-with-athena-to-reduce-number-of-queries","title":"Leveraging <code>from_query</code> with Athena to reduce number of queries","text":"<p>Throughout TidierDB, each time <code>db_table</code> is called, it queries the databases to get the metadata. Consider how AWS Athena logs queries, a user may want to reduce the number of queries. This can be done saving the results of <code>db_table</code>, and then using from_query with those results for furthe queries as shown below.</p> <pre><code>mtcars = db_table(AWS_GLOBAL_CONFIG[], \"demodb.mtcars\", athena_params)\n@chain from_query(mtcars) begin\n    @filter(cyl &gt; 4)\n    @group_by(cyl)\n    @summarize(mpg = mean(mpg))\n   #@show_query\n    @collect\nend\n</code></pre> <pre><code>2\u00d72 DataFrame\n Row \u2502 cyl    mpg\n     \u2502 Int64  Float64\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502     6  19.7429\n   2 \u2502     8  15.1\n</code></pre> <p>I would like to acknowledge the work of Manu Francis and this blog post, which helped guide this process</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/from_queryex/","title":"Reusing Part of a Query","text":"<p>While using TidierDB, you may need to generate part of a query and reuse it multiple times. <code>from_query()</code> enables a query portion to be reused multiple times as shown below.</p> <pre><code>import TidierDB as DB\ncon = DB.connect(:duckdb)\nDB.copy_to(con, \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\", \"mtcars2\")\n</code></pre> <p>Start a query to analyze fuel efficiency by number of cylinders. However, to further build on this query later, end the chain without using <code>@show_query</code> or <code>@collect</code></p> <pre><code>query = DB.@chain DB.db_table(con, :mtcars2) begin\n    DB.@group_by cyl\n    DB.@summarize begin\n        across(mpg, (mean, minimum, maximum))\n        num_cars = n()\n        end\n    DB.@mutate begin\n        efficiency = case_when(\n            mean_mpg &gt;= 25, \"High\",\n            mean_mpg &gt;= 15, \"Moderate\",\n            \"Low\" )\n       end\nend;\n</code></pre> <p>Now, <code>from_query</code> will allow you to reuse the query to calculate the average horsepower for each efficiency category</p> <pre><code>DB.@chain DB.from_query(query) begin\n   DB.@left_join(mtcars2, cyl, cyl)\n   DB.@group_by(efficiency)\n   DB.@summarize(avg_hp = mean(hp))\n   DB.@collect\nend\n</code></pre> <pre><code>2\u00d72 DataFrame\n Row \u2502 efficiency  avg_hp\n     \u2502 String?     Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Moderate    180.238\n   2 \u2502 High         82.6364\n</code></pre> <p>Reuse the query again to find the car with the highest MPG for each cylinder category</p> <pre><code>DB.@chain DB.from_query(query) begin\n   DB.@left_join(mtcars2, cyl, cyl)\n   DB.@group_by cyl\n   DB.@slice_max(mpg)\n   DB.@select model cyl mpg\n   DB.@collect\nend\n</code></pre> <pre><code>3\u00d73 DataFrame\n Row \u2502 model             cyl     mpg\n     \u2502 String?           Int64?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Pontiac Firebird       8      19.2\n   2 \u2502 Toyota Corolla         4      33.9\n   3 \u2502 Hornet 4 Drive         6      21.4\n</code></pre> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/","title":"Writing Functions/Macros with TidierDB Chains","text":"<p>How can functions pass arguments to a TidierDB chain?</p> <p>In short, you have to use a macro instead in conjuction with <code>@interpolate</code></p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/functions_pass_to_DB/#setting-up-the-macro","title":"Setting up the macro","text":"<p>To write a macro that will take arguments and pass them to a TidierDB chain, there are 3 steps:</p> <ol> <li>Write macro with the desired argument(s), and, after the quote, add the chain. Arguments to be changed/interpolated must be prefixed with <code>!!</code></li> <li>Use <code>@interpolate</code> to make these arguemnts accessible to the chain. <code>@interpolate</code> takes touples as argument (one for the <code>!!</code>name, and one for the actual content you want the chain to use)</li> <li>Run <code>@interpolate</code> and then the chain macro sequentially</li> </ol> <pre><code>using TidierDB\npath = \"https://gist.githubusercontent.com/seankross/a412dfbd88b3db70b74b/raw/5f23f993cd87c283ce766e7ac6b329ee7cc2e1d1/mtcars.csv\"\ncopy_to(db, path, \"mtcars\");\n\n# STEP 1\nmacro f1(conditions, columns) # The arguemnt names will be names of the `!!` values\n    return quote\n    # add chain here\n      @chain db_table(db, :mtcars) begin\n           @filter(!!conditions &gt; 3)\n           @select(!!columns)\n           @aside @show_query _\n           @collect\n         end # ends the chain\n    end # ends the quote.\nend # ends the macro\n</code></pre> <pre><code># STEP 2\nvariable = :gear;\ncols = [:model, :mpg, :gear, :wt];\n@interpolate((conditions, variable), (columns, cols));\n@f1(variable, cols)\n</code></pre> <pre><code>17\u00d74 DataFrame\n Row \u2502 model           mpg       gear    wt\n     \u2502 String?         Float64?  Int32?  Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Mazda RX4           21.0       4     2.62\n   2 \u2502 Mazda RX4 Wag       21.0       4     2.875\n   3 \u2502 Datsun 710          22.8       4     2.32\n  \u22ee  \u2502       \u22ee            \u22ee        \u22ee        \u22ee\n  15 \u2502 Ferrari Dino        19.7       5     2.77\n  16 \u2502 Maserati Bora       15.0       5     3.57\n  17 \u2502 Volvo 142E          21.4       4     2.78\n                                   11 rows omitted\n</code></pre> <p>Lets say you wanted to filter on new variable with a different name and select new columns,</p> <pre><code>new_condition = :wt;\nnew_cols = [:model, :drat]\n@interpolate((conditions, new_condition), (columns, new_cols));\n@f1(new_condition, new_cols)\n</code></pre> <pre><code>20\u00d72 DataFrame\n Row \u2502 model              drat\n     \u2502 String?            Float64?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 Hornet 4 Drive         3.08\n   2 \u2502 Hornet Sportabout      3.15\n   3 \u2502 Valiant                2.76\n  \u22ee  \u2502         \u22ee             \u22ee\n  18 \u2502 Pontiac Firebird       3.08\n  19 \u2502 Ford Pantera L         4.22\n  20 \u2502 Maserati Bora          3.54\n                    14 rows omitted\n</code></pre> <p>You can also interpolate vectors of strings into a <code>@filter(col in (values))</code> as well by using the following syntax <code>@filter(col in [!!values])</code></p> <p>In short, the first argument in <code>@interpolate</code> must be the name of the macro argument it refers to, and the second argument is what you would like to replace it.</p> <p>We recognize this adds friction and that it is not ideal, but given the TidierDB macro expressions/string interplay, this is currently the most graceful and functional option available and hopefully a temporary solution to better interpolation that mirrors TidierData.jl.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/getting_started/","title":"Getting Started","text":"<p>To use TidierDB.jl, you will have to set up a connection. TidierDB.jl gives you access to duckdb via <code>duckdb_open</code> and <code>duckdb_connect</code>. However, to use MySql, ClickHouse, MSSQL, Postgres, or SQLite, you will have to load those packages in first.</p> <p>If you plan to use TidierDB.jl with TidierData.jl or Tidier.jl, it is most convenenient to load the packages as follows:</p> <pre><code>using TidierData\nimport TidierDB as DB\n</code></pre> <p>Alternatively, <code>using Tidier</code> will import TidierDB in the above manner for you, where TidierDB functions and macros will be available as <code>DB.@mutate()</code> and so on, and the TidierData equivalent would be <code>@mutate()</code>.</p> <p>There are two ways to connect to the database.  you can use <code>connect</code> without any need to load any additional packages.</p> <p>For example Connecting to MySQL</p> <pre><code>conn = connect(:mysql; host=\"localhost\", user=\"root\", password=\"password\", db=\"mydb\")\n</code></pre> <p>versus connecting to DuckDB</p> <pre><code>conn = connect(:duckdb)\n</code></pre> <ul> <li>Oracle and AWS are not yet supported with <code>connect()</code> and will require using the respective libraries outlined below to establish a connection</li> </ul> <p>Alternatively, you can use the packages outlined below to establish a connection through their respective methods.</p> <ul> <li>DuckDB: DuckDB.jl</li> <li>ClickHouse: ClickHouse.jl</li> <li>MySQL and MariaDB: MySQL.jl</li> <li>MSSQL: ODBC.jl</li> <li>Postgres: LibPQ.jl</li> <li>SQLite: SQLite.jl</li> <li>Athena: AWS.jl</li> <li>Oracle: Oracle.jl</li> </ul> <p>For DuckDB, SQLite, and MySQL, <code>copy_to()</code> lets you copy data to the database and query there. ClickHouse, MSSQL, and Postgres support for <code>copy_to()</code> has not been added yet.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"examples/generated/UserGuide/key_differences/","title":"Key Differences from TidierData.jl","text":"<p>There are a few important syntax and behavior differences between TidierDB.jl and TidierData.jl outlined below.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#creating-a-database","title":"Creating a database","text":"<p>For these examples we will use DuckDB, the default backend, although SQLite, Postgres, MySQL, MariaDB, MSSQL, and ClickHouse are possible. If you have an existing DuckDB connection, then this step is not required. For these examples, we will create a data frame and copy it to an in-memory DuckDB database.</p> <pre><code>using DataFrames, TidierDB\n\ndf = DataFrame(id = [string('A' + i \u00f7 26, 'A' + i % 26) for i in 0:9],\n                        groups = [i % 2 == 0 ? \"aa\" : \"bb\" for i in 1:10],\n                        value = repeat(1:5, 2),\n                        percent = 0.1:0.1:1.0);\n\ndb = connect(:duckdb);\n\ncopy_to(db, df, \"df_mem\"); # copying over the data frame to an in-memory database\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#row-ordering","title":"Row ordering","text":"<p>DuckDB benefits from aggressive parallelization of pipelines. This means that if you have multiple threads enabled in Julia, which you can check or set using <code>Threads.nthreads()</code>, DuckDB will use multiple threads. However, because many operations are multi-threaded, the resulting row order is inconsistent. If row order needs to be deterministic for your use case, make sure to apply an <code>@arrange(column_name_1, column_name_2, etc...)</code> prior to collecting the results.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#starting-a-chain","title":"Starting a chain","text":"<p>When using TidierDB, <code>db_table(connection, :table_name)</code> is used to start a chain.</p> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#grouped-mutation","title":"Grouped mutation","text":"<p>In TidierDB, when performing <code>@group_by</code> then <code>@mutate</code>, the table will be ungrouped after applying all of the mutations in the clause to the grouped data. To perform subsequent grouped operations, the user would have to regroup the data. This is demonstrated below.</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @summarize(mean_percent = mean(percent))\n    @collect\n end\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentString?Float64?1bb0.52aa0.6 <p>Regrouping following <code>@mutate</code></p> <pre><code>@chain db_table(db, :df_mem) begin\n    @group_by(groups)\n    @mutate(max = maximum(percent), min = minimum(percent))\n    @group_by(groups)\n    @summarise(mean_percent = mean(percent))\n    @collect\nend\n</code></pre> 2\u00d72 DataFrame Rowgroupsmean_percentString?Float64?1bb0.52aa0.6 <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#joining","title":"Joining","text":"<p>There is one key difference for joining:</p> <p>The column on both the new and old table must be specified. They do not need to be the same, and given SQL behavior where both columns are kept when joining two tables, it is preferable if they have different names. This avoids \"ambiguous reference\" errors that would otherwise come up and complicate the use of tidy selection for columns. Athena has an additional slight difference given the need for parameters, which is covered in the Athena documentation page.</p> <pre><code>df2 = DataFrame(id2 = [\"AA\", \"AC\", \"AE\", \"AG\", \"AI\", \"AK\", \"AM\"],\n                category = [\"X\", \"Y\", \"X\", \"Y\", \"X\", \"Y\", \"X\"],\n                score = [88, 92, 77, 83, 95, 68, 74]);\n\ncopy_to(db, df2, \"df_join\");\n\n@chain db_table(db, :df_mem) begin\n    @left_join(df_join, id2, id)\n    @collect\nend\n</code></pre> 10\u00d77 DataFrame Rowidgroupsvaluepercentid2categoryscoreString?String?Int64?Float64?String?String?Int64?1AAbb10.1AAX882ACbb30.3ACY923AEbb50.5AEX774AGbb20.7AGY835AIbb40.9AIX956ABaa20.2missingmissingmissing7ADaa40.4missingmissingmissing8AFaa10.6missingmissingmissing9AHaa30.8missingmissingmissing10AJaa51.0missingmissingmissing <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#differences-in-case_when","title":"Differences in <code>case_when()</code>","text":"<p>In TidierDB, after the clause is completed, the result for the new column should is separated by a comma <code>,</code> in contrast to TidierData.jl, where the result for the new column is separated by a <code>=&gt;</code> .</p> <pre><code>@chain db_table(db, :df_mem) begin\n    @mutate(new_col = case_when(percent &gt; .5, \"Pass\",  # in TidierData, percent &gt; .5 =&gt; \"Pass\",\n                                percent &lt;= .5, \"Try Again\", # percent &lt;= .5 =&gt; \"Try Again\"\n                                true, \"middle\"))\n    @collect\n end\n</code></pre> 10\u00d75 DataFrame Rowidgroupsvaluepercentnew_colString?String?Int64?Float64?String?1AAbb10.1Try Again2ABaa20.2Try Again3ACbb30.3Try Again4ADaa40.4Try Again5AEbb50.5Try Again6AFaa10.6Pass7AGbb20.7Pass8AHaa30.8Pass9AIbb40.9Pass10AJaa51.0Pass <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#interpolation","title":"Interpolation","text":"<p>To use !! Interpolation, instead of being able to define the alternate names/value in the global context, the user has to use <code>@interpolate</code>. This will hopefully be fixed in future versions. Otherwise, the behavior is generally the same, although this creates friction around calling functions.</p> <p>Also, when using interpolation with exponenents, the interpolated value must go inside of parenthesis.</p> <pre><code>@interpolate((test, :percent)); # this still supports strings, vectors of names, and values\n\n@chain db_table(db, :df_mem) begin\n    @mutate(new_col = case_when((!!test)^2 &gt; .5, \"Pass\",\n                                (!!test)^2 &lt; .5, \"Try Again\",\n                                \"middle\"))\n    @collect\nend\n</code></pre> <pre><code>10\u00d75 DataFrame\n Row \u2502 id       groups   value   percent   new_col\n     \u2502 String?  String?  Int64?  Float64?  String?\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n   1 \u2502 AA       bb            1       0.1  Try Again\n   2 \u2502 AB       aa            2       0.2  Try Again\n   3 \u2502 AC       bb            3       0.3  Try Again\n  \u22ee  \u2502    \u22ee        \u22ee       \u22ee        \u22ee          \u22ee\n   8 \u2502 AH       aa            3       0.8  Pass\n   9 \u2502 AI       bb            4       0.9  Pass\n  10 \u2502 AJ       aa            5       1.0  Pass\n                                       4 rows omitted\n</code></pre> <p></p> <p></p>"},{"location":"examples/generated/UserGuide/key_differences/#slicing-ties","title":"Slicing ties","text":"<p><code>slice_min()</code> and <code>@slice_max()</code> will always return ties due to SQL behavior.</p> <p>This page was generated using Literate.jl.</p>"}]}